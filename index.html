<!DOCTYPE html>
<!--
  SECURITY HARDENED VERSION

  This version includes the following security enhancements:
  
  1. XSS PROTECTION:
     - Added escapeHtml() function for sanitizing user input
     - Replaced document.write() in printTrade() with safe DOM methods
     - Added input validation for all user-controlled data
  
  2. URL VALIDATION:
     - Added sanitizeUrl() for URL validation
     - Added safeOpenURL() to safely open external links
     - All window.open() calls now validate URLs and use noopener,noreferrer
  
  3. FILE UPLOAD SECURITY:
     - Added MAX_FILE_SIZE constant (50MB limit)
     - File size validation for CSV and JSON imports
     - Trade data validation before processing
  
  4. INJECTION PREVENTION:
     - Added validateTrade() function to validate trade objects
     - Enhanced input validation in CSV and JSON parsers
     - Symbol validation to prevent numeric-only symbols
  
  5. CODE QUALITY:
     - Fixed duplicate updateTradeField() function
     - Fixed syntax error in string concatenation (line 5151)
  
  REMAINING CONSIDERATIONS:
  - Some inline event handlers (onclick, onchange) remain for backwards compatibility
  - Future enhancement: Convert remaining inline handlers to addEventListener
  - Regular security audits recommended for production use
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Trading Journal</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
  /* Primitive Color Tokens */
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-teal-800: rgba(41, 150, 161, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-orange-400: rgba(230, 129, 97, 1);
  --color-orange-500: rgba(168, 75, 47, 1);

  /* RGB versions for opacity control */
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;
  --color-slate-500-rgb: 98, 108, 113;
  --color-red-500-rgb: 192, 21, 47;
  --color-red-400-rgb: 255, 84, 89;
  --color-orange-500-rgb: 168, 75, 47;
  --color-orange-400-rgb: 230, 129, 97;

  /* Background color tokens (Light Mode) */
  --color-bg-1: rgba(59, 130, 246, 0.08); /* Light blue */
  --color-bg-2: rgba(245, 158, 11, 0.08); /* Light yellow */
  --color-bg-3: rgba(34, 197, 94, 0.08); /* Light green */
  --color-bg-4: rgba(239, 68, 68, 0.08); /* Light red */
  --color-bg-5: rgba(147, 51, 234, 0.08); /* Light purple */
  --color-bg-6: rgba(249, 115, 22, 0.08); /* Light orange */
  --color-bg-7: rgba(236, 72, 153, 0.08); /* Light pink */
  --color-bg-8: rgba(6, 182, 212, 0.08); /* Light cyan */

  /* Semantic Color Tokens (Light Mode) */
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
  --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

  /* Common style patterns */
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --status-bg-opacity: 0.15;
  --status-border-opacity: 0.25;
  --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

  /* RGB versions for opacity control */
  --color-success-rgb: 33, 128, 141;
  --color-error-rgb: 192, 21, 47;
  --color-warning-rgb: 168, 75, 47;
  --color-info-rgb: 98, 108, 113;

  /* Typography */
  --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system,
    BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo,
    Monaco, Consolas, monospace;
  --font-size-xs: 11px;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  --font-size-md: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-2xl: 20px;
  --font-size-3xl: 24px;
  --font-size-4xl: 30px;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 550;
  --font-weight-bold: 600;
  --line-height-tight: 1.2;
  --line-height-normal: 1.5;
  --letter-spacing-tight: -0.01em;

  /* Spacing */
  --space-0: 0;
  --space-1: 1px;
  --space-2: 2px;
  --space-4: 4px;
  --space-6: 6px;
  --space-8: 8px;
  --space-10: 10px;
  --space-12: 12px;
  --space-16: 16px;
  --space-20: 20px;
  --space-24: 24px;
  --space-32: 32px;

  /* Border Radius */
  --radius-sm: 6px;
  --radius-base: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-full: 9999px;

  /* Shadows */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04),
    0 2px 4px -1px rgba(0, 0, 0, 0.02);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04),
    0 4px 6px -2px rgba(0, 0, 0, 0.02);
  --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15),
    inset 0 -1px 0 rgba(0, 0, 0, 0.03);

  /* Animation */
  --duration-fast: 150ms;
  --duration-normal: 250ms;
  --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

  /* Layout */
  --container-sm: 640px;
  --container-md: 768px;
  --container-lg: 1024px;
  --container-xl: 1280px;
}

/* Dark mode colors */
@media (prefers-color-scheme: dark) {
  :root {
    /* RGB versions for opacity control (Dark Mode) */
    --color-gray-400-rgb: 119, 124, 124;
    --color-teal-300-rgb: 50, 184, 198;
    --color-gray-300-rgb: 167, 169, 169;
    --color-gray-200-rgb: 245, 245, 245;

    /* Background color tokens (Dark Mode) */
    --color-bg-1: rgba(29, 78, 216, 0.15); /* Dark blue */
    --color-bg-2: rgba(180, 83, 9, 0.15); /* Dark yellow */
    --color-bg-3: rgba(21, 128, 61, 0.15); /* Dark green */
    --color-bg-4: rgba(185, 28, 28, 0.15); /* Dark red */
    --color-bg-5: rgba(107, 33, 168, 0.15); /* Dark purple */
    --color-bg-6: rgba(194, 65, 12, 0.15); /* Dark orange */
    --color-bg-7: rgba(190, 24, 93, 0.15); /* Dark pink */
    --color-bg-8: rgba(8, 145, 178, 0.15); /* Dark cyan */

    /* Semantic Color Tokens (Dark Mode) */
    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
    --color-primary: var(--color-teal-300);
    --color-primary-hover: var(--color-teal-400);
    --color-primary-active: var(--color-teal-800);
    --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
    --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
    --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
    --color-border: rgba(var(--color-gray-400-rgb), 0.3);
    --color-error: var(--color-red-400);
    --color-success: var(--color-teal-300);
    --color-warning: var(--color-orange-400);
    --color-info: var(--color-gray-300);
    --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
    --color-btn-primary-text: var(--color-slate-900);
    --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
    --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
    --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    --button-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
    --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
    --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

    /* Common style patterns - updated for dark mode */
    --focus-ring: 0 0 0 3px var(--color-focus-ring);
    --focus-outline: 2px solid var(--color-primary);
    --status-bg-opacity: 0.15;
    --status-border-opacity: 0.25;
    --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

    /* RGB versions for dark mode */
    --color-success-rgb: var(--color-teal-300-rgb);
    --color-error-rgb: var(--color-red-400-rgb);
    --color-warning-rgb: var(--color-orange-400-rgb);
    --color-info-rgb: var(--color-gray-300-rgb);
  }
}

/* Data attribute for manual theme switching */
[data-color-scheme="dark"] {
  /* RGB versions for opacity control (dark mode) */
  --color-gray-400-rgb: 119, 124, 124;
  --color-teal-300-rgb: 50, 184, 198;
  --color-gray-300-rgb: 167, 169, 169;
  --color-gray-200-rgb: 245, 245, 245;

  /* Colorful background palette - Dark Mode */
  --color-bg-1: rgba(29, 78, 216, 0.15); /* Dark blue */
  --color-bg-2: rgba(180, 83, 9, 0.15); /* Dark yellow */
  --color-bg-3: rgba(21, 128, 61, 0.15); /* Dark green */
  --color-bg-4: rgba(185, 28, 28, 0.15); /* Dark red */
  --color-bg-5: rgba(107, 33, 168, 0.15); /* Dark purple */
  --color-bg-6: rgba(194, 65, 12, 0.15); /* Dark orange */
  --color-bg-7: rgba(190, 24, 93, 0.15); /* Dark pink */
  --color-bg-8: rgba(8, 145, 178, 0.15); /* Dark cyan */

  /* Semantic Color Tokens (Dark Mode) */
  --color-background: var(--color-charcoal-700);
  --color-surface: var(--color-charcoal-800);
  --color-text: var(--color-gray-200);
  --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
  --color-primary: var(--color-teal-300);
  --color-primary-hover: var(--color-teal-400);
  --color-primary-active: var(--color-teal-800);
  --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
  --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
  --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
  --color-border: rgba(var(--color-gray-400-rgb), 0.3);
  --color-error: var(--color-red-400);
  --color-success: var(--color-teal-300);
  --color-warning: var(--color-orange-400);
  --color-info: var(--color-gray-300);
  --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
  --color-btn-primary-text: var(--color-slate-900);
  --color-card-border: rgba(var(--color-gray-400-rgb), 0.15);
  --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
  --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
    inset 0 -1px 0 rgba(0, 0, 0, 0.15);
  --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
  --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

  /* Common style patterns - updated for dark mode */
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --status-bg-opacity: 0.15;
  --status-border-opacity: 0.25;
  --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

  /* RGB versions for dark mode */
  --color-success-rgb: var(--color-teal-300-rgb);
  --color-error-rgb: var(--color-red-400-rgb);
  --color-warning-rgb: var(--color-orange-400-rgb);
  --color-info-rgb: var(--color-gray-300-rgb);
}

[data-color-scheme="light"] {
  /* RGB versions for opacity control (light mode) */
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;

  /* Semantic Color Tokens (Light Mode) */
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);

  /* RGB versions for light mode */
  --color-success-rgb: var(--color-teal-500-rgb);
  --color-error-rgb: var(--color-red-500-rgb);
  --color-warning-rgb: var(--color-orange-500-rgb);
  --color-info-rgb: var(--color-slate-500-rgb);
}

/* Base styles */
html {
  font-size: var(--font-size-base);
  font-family: var(--font-family-base);
  line-height: var(--line-height-normal);
  color: var(--color-text);
  background-color: var(--color-background);
  -webkit-font-smoothing: antialiased;
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

/* Typography */
h1,
h2,
h3,
h4,
h5,
h6 {
  margin: 0;
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  color: var(--color-text);
  letter-spacing: var(--letter-spacing-tight);
}

h1 {
  font-size: var(--font-size-4xl);
}
h2 {
  font-size: var(--font-size-3xl);
}
h3 {
  font-size: var(--font-size-2xl);
}
h4 {
  font-size: var(--font-size-xl);
}
h5 {
  font-size: var(--font-size-lg);
}
h6 {
  font-size: var(--font-size-md);
}

p {
  margin: 0 0 var(--space-16) 0;
}

a {
  color: var(--color-primary);
  text-decoration: none;
  transition: color var(--duration-fast) var(--ease-standard);
}

a:hover {
  color: var(--color-primary-hover);
}

code,
pre {
  font-family: var(--font-family-mono);
  font-size: calc(var(--font-size-base) * 0.95);
  background-color: var(--color-secondary);
  border-radius: var(--radius-sm);
}

code {
  padding: var(--space-1) var(--space-4);
}

pre {
  padding: var(--space-16);
  margin: var(--space-16) 0;
  overflow: auto;
  border: 1px solid var(--color-border);
}

pre code {
  background: none;
  padding: 0;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-8) var(--space-16);
  border-radius: var(--radius-base);
  font-size: var(--font-size-base);
  font-weight: 500;
  line-height: 1.5;
  cursor: pointer;
  transition: all var(--duration-normal) var(--ease-standard);
  border: none;
  text-decoration: none;
  position: relative;
}

.btn:focus-visible {
  outline: none;
  box-shadow: var(--focus-ring);
}

.btn--primary {
  background: var(--color-primary);
  color: var(--color-btn-primary-text);
}

.btn--primary:hover {
  background: var(--color-primary-hover);
}

.btn--primary:active {
  background: var(--color-primary-active);
}

.btn--secondary {
  background: var(--color-secondary);
  color: var(--color-text);
}

.btn--secondary:hover {
  background: var(--color-secondary-hover);
}

.btn--secondary:active {
  background: var(--color-secondary-active);
}

.btn--outline {
  background: transparent;
  border: 1px solid var(--color-border);
  color: var(--color-text);
}

.btn--outline:hover {
  background: var(--color-secondary);
}

.btn--sm {
  padding: var(--space-4) var(--space-12);
  font-size: var(--font-size-sm);
  border-radius: var(--radius-sm);
}

.btn--lg {
  padding: var(--space-10) var(--space-20);
  font-size: var(--font-size-lg);
  border-radius: var(--radius-md);
}

.btn--full-width {
  width: 100%;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Form elements */
.form-control {
  display: block;
  width: 100%;
  padding: var(--space-8) var(--space-12);
  font-size: var(--font-size-md);
  line-height: 1.5;
  color: var(--color-text);
  background-color: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  transition: border-color var(--duration-fast) var(--ease-standard),
    box-shadow var(--duration-fast) var(--ease-standard);
}

textarea.form-control {
  font-family: var(--font-family-base);
  font-size: var(--font-size-base);
}

select.form-control {
  padding: var(--space-8) var(--space-12);
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: var(--select-caret-light);
  background-repeat: no-repeat;
  background-position: right var(--space-12) center;
  background-size: 16px;
  padding-right: var(--space-32);
}

/* Add a dark mode specific caret */
@media (prefers-color-scheme: dark) {
  select.form-control {
    background-image: var(--select-caret-dark);
  }
}

/* Also handle data-color-scheme */
[data-color-scheme="dark"] select.form-control {
  background-image: var(--select-caret-dark);
}

[data-color-scheme="light"] select.form-control {
  background-image: var(--select-caret-light);
}

.form-control:focus {
  border-color: var(--color-primary);
  outline: var(--focus-outline);
}

.form-label {
  display: block;
  margin-bottom: var(--space-8);
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
}

.form-group {
  margin-bottom: var(--space-16);
}

/* Card component */
.card {
  background-color: var(--color-surface);
  border-radius: var(--radius-lg);
  border: 1px solid var(--color-card-border);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  transition: box-shadow var(--duration-normal) var(--ease-standard);
}

.card:hover {
  box-shadow: var(--shadow-md);
}

.card__body {
  padding: var(--space-16);
}

.card__header,
.card__footer {
  padding: var(--space-16);
  border-bottom: 1px solid var(--color-card-border-inner);
}

/* Status indicators - simplified with CSS variables */
.status {
  display: inline-flex;
  align-items: center;
  padding: var(--space-6) var(--space-12);
  border-radius: var(--radius-full);
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
}

.status--success {
  background-color: rgba(
    var(--color-success-rgb, 33, 128, 141),
    var(--status-bg-opacity)
  );
  color: var(--color-success);
  border: 1px solid
    rgba(var(--color-success-rgb, 33, 128, 141), var(--status-border-opacity));
}

.status--error {
  background-color: rgba(
    var(--color-error-rgb, 192, 21, 47),
    var(--status-bg-opacity)
  );
  color: var(--color-error);
  border: 1px solid
    rgba(var(--color-error-rgb, 192, 21, 47), var(--status-border-opacity));
}

.status--warning {
  background-color: rgba(
    var(--color-warning-rgb, 168, 75, 47),
    var(--status-bg-opacity)
  );
  color: var(--color-warning);
  border: 1px solid
    rgba(var(--color-warning-rgb, 168, 75, 47), var(--status-border-opacity));
}

.status--info {
  background-color: rgba(
    var(--color-info-rgb, 98, 108, 113),
    var(--status-bg-opacity)
  );
  color: var(--color-info);
  border: 1px solid
    rgba(var(--color-info-rgb, 98, 108, 113), var(--status-border-opacity));
}

/* Container layout */
.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: var(--space-16);
  padding-left: var(--space-16);
}

@media (min-width: 640px) {
  .container {
    max-width: var(--container-sm);
  }
}
@media (min-width: 768px) {
  .container {
    max-width: var(--container-md);
  }
}
@media (min-width: 1024px) {
  .container {
    max-width: var(--container-lg);
  }
}
@media (min-width: 1280px) {
  .container {
    max-width: var(--container-xl);
  }
}

/* Utility classes */
.flex {
  display: flex;
}
.flex-col {
  flex-direction: column;
}
.items-center {
  align-items: center;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-4 {
  gap: var(--space-4);
}
.gap-8 {
  gap: var(--space-8);
}
.gap-16 {
  gap: var(--space-16);
}

.m-0 {
  margin: 0;
}
.mt-8 {
  margin-top: var(--space-8);
}
.mb-8 {
  margin-bottom: var(--space-8);
}
.mx-8 {
  margin-left: var(--space-8);
  margin-right: var(--space-8);
}
.my-8 {
  margin-top: var(--space-8);
  margin-bottom: var(--space-8);
}

.p-0 {
  padding: 0;
}
.py-8 {
  padding-top: var(--space-8);
  padding-bottom: var(--space-8);
}
.px-8 {
  padding-left: var(--space-8);
  padding-right: var(--space-8);
}
.py-16 {
  padding-top: var(--space-16);
  padding-bottom: var(--space-16);
}
.px-16 {
  padding-left: var(--space-16);
  padding-right: var(--space-16);
}

.block {
  display: block;
}
.hidden {
  display: none;
}

/* Accessibility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

:focus-visible {
  outline: var(--focus-outline);
  outline-offset: 2px;
}

/* Dark mode specifics */
[data-color-scheme="dark"] .btn--outline {
  border: 1px solid var(--color-border-secondary);
}

@font-face {
  font-family: 'FKGroteskNeue';
  src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2')
    format('woff2');
}

        /* Comprehensive Trading Journal Styles */
        .trading-journal {
            min-height: 100vh;
            background: #0f172a;
            color: #f8fafc;
        }

        .gradient-header {
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 2rem;
        }

        .section {
            background: #1e293b;
            border-radius: 12px;
            border: 1px solid #334155;
            margin-bottom: 2rem;
            overflow: visible;
        }

        .section-header {
            position: relative;
            background: linear-gradient(90deg, #60a5fa 0%, #a78bfa 100%);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header h3 {
            margin: 0;
            color: white;
        }

        .section-content {
            padding: 1.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .stat-card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: transform 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: #60a5fa;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .positive { color: #10b981; }
        .negative { color: #ef4444; }
        .neutral { color: #6b7280; }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1rem;
        }

        .chart-container {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
        }

        .chart {
            height: 300px;
            position: relative;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            background: #60a5fa;
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3b82f6;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .trade-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .trade-row:hover {
            background: #334155;
        }

        .trade-details {
            background: #0f172a;
            padding: 1.5rem;
            border-top: 1px solid #334155;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .form-control {
            width: 100%;
            padding: 0.5rem;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 4px;
            color: white;
        }

        .form-control:focus {
            outline: none;
            border-color: #60a5fa;
        }

        .screenshot-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .screenshot {
            max-width: 100%;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .screenshot:hover {
            transform: scale(1.05);
        }

        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox img {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
        }

        .rules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .rule-card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
        }

        .rule-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin: 1rem 0;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 0.75rem;
            position: relative;
            cursor: pointer;
            min-height: 40px;
            border: 1px solid transparent;
        }
        
        .calendar-day:hover {
            border-color: #60a5fa;
        }

        .calendar-day.has-trades {
            font-weight: bold;
        }

        .calendar-day.profit {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .calendar-day.loss {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .performance-section {
            margin-bottom: 2rem;
        }

        .breakdown-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .breakdown-item {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
        }

        .breakdown-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .breakdown-stats {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .toggle-button {
            background: #374151;
            border: none;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .toggle-button.active {
            background: #60a5fa;
        }

        .message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .message.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        .message.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .collapsible {
            margin-bottom: 1rem;
        }

        .collapsible-header {
            background: #374151;
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-content {
            padding: 1rem;
            display: none;
        }

        .collapsible.open .collapsible-content {
            display: block;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #334155;
        }

        .table th {
            background: #374151;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .charts-grid,
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .download-notification {
                width: calc(100vw - 20px);
                right: 10px;
                left: 10px;
            }
        }
        
        @keyframes slide-down {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }


        /* Enhanced Screenshot and TradingView Button Styles */
        .screenshot-container {
            position: relative;
            display: inline-block;
        }

        .screenshot-container img {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .screenshot-container img:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
        }

        .btn-group {
            display: flex;
            gap: var(--space-8);
            align-items: center;
        }

        .btn-group .btn {
            flex: 1;
        }

        .btn-group .btn-icon {
            flex: none;
            padding: var(--space-8);
            min-width: 40px;
        }

        /* TradingView button specific styling */
        .btn-tradingview {
            background: linear-gradient(135deg, #2962FF, #1E88E5);
            color: white;
            border: none;
            font-weight: var(--font-weight-medium);
        }

        .btn-tradingview:hover:not(:disabled) {
            background: linear-gradient(135deg, #1E88E5, #1565C0);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-tradingview:disabled {
            background: var(--color-secondary);
            color: var(--color-text-secondary);
            cursor: not-allowed;
        }

        /* Screenshot upload button styling */
        .btn-screenshot {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            border: none;
            font-weight: var(--font-weight-medium);
        }

        .btn-screenshot:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        /* Clear button styling */
        .btn-clear {
            background: var(--color-error);
            color: white;
            border: none;
            padding: var(--space-8);
            min-width: 40px;
        }

        .btn-clear:hover {
            background: #DC2626;
            transform: translateY(-1px);
        }

        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
            cursor: pointer;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-border);
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--color-primary);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .toggle-switch:hover .toggle-slider {
            opacity: 0.9;
        }

        /* Section Info Tooltip Styles */
        .section-info-container {
            position: relative;
            display: inline-block;
            margin-left: var(--space-8);
        }

        .section-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-standard);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .section-info-icon:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .section-info-tooltip {
            display: none;
            position: fixed;
            top: auto;
            left: auto;
            transform: none;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            padding: var(--space-12);
            box-shadow: var(--shadow-lg);
            z-index: 99999;
            min-width: 280px;
            max-width: 400px;
        }

        .section-info-tooltip.show {
            display: block;
        }

        .section-info-tooltip-title {
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            color: var(--color-text);
            margin-bottom: var(--space-8);
            display: flex;
            align-items: center;
            gap: var(--space-6);
        }

        .section-info-tooltip-content {
            font-size: var(--font-size-xs);
            color: var(--color-text-secondary);
            line-height: var(--line-height-normal);
        }

        .section-info-tooltip-content ul {
            margin: var(--space-8) 0 0 0;
            padding-left: var(--space-16);
        }

        .section-info-tooltip-content li {
            margin-bottom: var(--space-4);
        }

        /* Arrow for tooltip */
        .section-info-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: var(--color-border);
        }

        .section-info-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-bottom-color: var(--color-surface);
            margin-bottom: -1px;
        }

    </style>
</head>
<body>
    <div class="trading-journal">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <!-- Header -->
            <h1 class="gradient-header">Z-APP</h1>
            <h2 style="text-align: center; color: #94a3b8; font-size: 1.25rem; margin-top: -1rem; margin-bottom: 1rem; font-weight: 400;">Comprehensive Trading Journal</h2>

            <!-- Features Button -->
            <div style="text-align: center; margin-bottom: 2rem;">
                <button class="btn btn--primary" onclick="toggleFeaturesModal()" title="Learn about all app features">
                    ‚ÑπÔ∏è Features Guide
                </button>
            </div>

            <!-- Save Status Indicator -->
            <div style="text-align: center; margin-bottom: 1rem; padding: 0.75rem; background: var(--color-bg-1); border: 1px solid var(--color-border); border-radius: var(--radius-base); display: flex; justify-content: center; align-items: center; gap: 1rem; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                    <span id="saveStatusIndicator" style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">
                        üíæ Not saved
                    </span>
                    <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0.75rem; background: var(--color-secondary); border-radius: var(--radius-base);">
                        <span id="autoSaveStatus" style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium);">Auto-save: ON</span>
                        <label class="toggle-switch" title="Toggle auto-save every 30 seconds">
                            <input type="checkbox" id="autoSaveToggle" onchange="toggleAutoSave()" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="btn btn--sm btn--secondary" onclick="saveToLocalStorage(); showMessage('‚úÖ Manual save successful');" title="Save data now">
                        üíæ Save Now
                    </button>
                    <button id="storageInfoButton" class="btn btn--sm btn--secondary" onclick="showStorageInfo()" title="View storage information">
                        üìä Storage Info (100MB)
                    </button>
                </div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <input type="file" id="csvInput" class="file-input" accept=".csv" />
                <button class="btn" onclick="document.getElementById('csvInput').click()">
                    üìÑ Import CSV
                </button>

                <select id="platform" class="form-control" style="width: auto;">
                    <option value="ctrader">cTrader</option>
                    <option value="mt4">MT4</option>
                    <option value="mt5">MT5</option>
                </select>

                <select id="importMode" class="form-control" style="width: auto;">
                    <option value="overwrite">Overwrite</option>
                    <option value="append">Append</option>
                    <option value="update-open-datetime">Update Open Date/Time</option>
                </select>

                <input type="file" id="jsonInput" class="file-input" accept=".json" />
                <button class="btn btn-secondary" onclick="document.getElementById('jsonInput').click()">
                    üìÅ Import Data
                </button>

                <button class="btn" onclick="toggleAPIImportModal()" title="Import trades from API">
                    üîå Import from API
                </button>

                <button class="btn btn-secondary" onclick="printTrades()" id="printBtn" disabled>
                    üñ®Ô∏è Print
                </button>

                <!-- Export with dropdown -->
                <div class="export-menu-container" style="position: relative; display: inline-block;">
                    <button onclick="toggleExportMenu()" class="btn btn-secondary" id="exportBtn" disabled title="Export options">üíæ Export ‚ñæ</button>

                    <!-- Export Options Dropdown -->
                    <div id="exportDropdown" style="display: none; position: absolute; top: 100%; left: 0; width: 320px; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); box-shadow: var(--shadow-lg); z-index: 2000; margin-top: 4px;">
                        <!-- Info box at top -->
                        <div style="padding: 12px; background: var(--color-bg-1); border-bottom: 1px solid var(--color-border);">
                            <div style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); margin-bottom: 4px; color: var(--color-primary);">
                                üíæ Save Location
                            </div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">
                                Files save to your browser's default download folder (usually "Downloads")
                            </div>
                        </div>

                        <div style="padding: 8px;">
                            <button
                                onclick="handleExportData('full'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">üì¶ Full Export</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Everything (trades, screenshots, settings)
                                </div>
                            </button>

                            <button
                                onclick="handleExportData('trades-only'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">üìä Trades Only</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Just trade data (no screenshots or settings)
                                </div>
                            </button>

                            <button
                                onclick="handleExportData('no-screenshots'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">üìã Without Screenshots</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Trades and settings (smaller file size)
                                </div>
                            </button>

                            <button
                                onclick="handleExportData('screenshots-only'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">üì∏ Screenshots Only</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Just screenshots in JSON format (for backup/sharing)
                                </div>
                            </button>

                            <div style="border-top: 1px solid var(--color-border); margin: 8px 0;"></div>

                            <button
                                onclick="handleExportData('csv'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">üìÑ Export as CSV</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Trade data in CSV format (Excel compatible)
                                </div>
                            </button>
                        </div>

                        <!-- Size estimates at bottom -->
                        <div style="padding: 12px; background: var(--color-bg-8); border-top: 1px solid var(--color-border);">
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); display: grid; grid-template-columns: 1fr auto; gap: var(--space-8);">
                                <div>üì¶ Full Export:</div>
                                <div id="fullSizeEstimate">~calculating...</div>

                                <div>üìã Without Screenshots:</div>
                                <div id="noScreenshotsSizeEstimate">~calculating...</div>

                                <div>üì∏ Screenshots Only:</div>
                                <div id="screenshotsSizeEstimate">~calculating...</div>

                                <div>üìä Trades Only:</div>
                                <div id="tradesSizeEstimate">~calculating...</div>
                            </div>
                            <div style="text-align: center; margin-top: var(--space-8);">
                                <button
                                    onclick="showDownloadLocationInfo()"
                                    style="background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xs); cursor: pointer; text-decoration: underline;">
                                    Where do files save? üìÇ
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Download help button removed -->
            </div>

            <!-- Messages -->
            <div id="messages"></div>

            <!-- ACCOUNT SETTINGS SECTION - NEW LOCATION -->
            <div id="accountSettingsSection" class="section" style="margin-bottom: 1.5rem;">
                <button
                    onclick="toggleAccountSettings()"
                    class="btn btn--outline"
                    style="width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); margin-bottom: 0; font-weight: var(--font-weight-medium);">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <span style="font-size: var(--font-size-lg);">‚öôÔ∏è</span>
                        <span>Account Settings</span>
                        <div class="section-info-container">
                            <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                i
                            </span>
                            <div class="section-info-tooltip">
                                <div class="section-info-tooltip-title">‚öôÔ∏è Account Settings</div>
                                <div class="section-info-tooltip-content">
                                    Configure your trading account preferences and data management.
                                    <ul>
                                        <li><strong>Starting Balance:</strong> Set your initial account equity</li>
                                        <li><strong>Platform:</strong> Choose between cTrader, MT4, or MT5</li>
                                        <li><strong>Import Mode:</strong> Control how imported data is handled</li>
                                        <li><strong>Clear Data:</strong> Reset your trading history</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <span id="accountSettingsArrow" style="font-size: var(--font-size-xl); transition: transform var(--duration-normal) var(--ease-standard);">‚ñ∂</span>
                </button>

                <div id="accountSettingsContent" class="account-settings-content" style="display: none; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-top: none; border-radius: 0 0 var(--radius-base) var(--radius-base);">
                    <!-- Starting Balance -->
                    <div style="margin-bottom: 1rem;">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">
                            <span>üí∞</span>
                            <span>Starting Balance</span>
                        </label>
                        <div style="display: flex; gap: var(--space-8);">
                            <input
                                type="number"
                                id="editStartingBalance"
                                class="form-control"
                                style="flex: 1;"
                                placeholder="e.g., 100000"
                                onchange="updateStartingBalanceValue(this.value)">
                            <button
                                onclick="saveStartingBalance()"
                                class="btn btn--primary">Save</button>
                            <button
                                onclick="cancelStartingBalance()"
                                class="btn btn--secondary">Cancel</button>
                        </div>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4); margin-bottom: 0;">
                            Current: $<span id="currentStartingBalance">10,000.00</span>
                        </p>
                    </div>

                    <!-- Platform Selection -->
                    <div style="margin-bottom: 1rem;">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">
                            <span>üîß</span>
                            <span>Trading Platform</span>
                        </label>
                        <div style="display: flex; gap: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="platformRadio"
                                    value="ctrader"
                                    checked
                                    onchange="updatePlatform('ctrader')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">cTrader</div>
                                </div>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="platformRadio"
                                    value="mt4"
                                    onchange="updatePlatform('mt4')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">MT4</div>
                                </div>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="platformRadio"
                                    value="mt5"
                                    onchange="updatePlatform('mt5')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">MT5</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Import Mode -->
                    <div style="margin-bottom: 1rem;">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">
                            <span>üì•</span>
                            <span>CSV Import Mode</span>
                        </label>
                        <div style="display: flex; flex-direction: column; gap: var(--space-8);">
                            <div style="display: flex; gap: var(--space-8);">
                                <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                    <input
                                        type="radio"
                                        name="importModeRadio"
                                        value="overwrite"
                                        checked
                                        onchange="updateImportMode('overwrite')"
                                        style="accent-color: var(--color-primary);">
                                    <div>
                                        <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">Overwrite</div>
                                        <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Replace all trades</div>
                                    </div>
                                </label>
                                <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                    <input
                                        type="radio"
                                        name="importModeRadio"
                                        value="append"
                                        onchange="updateImportMode('append')"
                                        style="accent-color: var(--color-primary);">
                                    <div>
                                        <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">Append</div>
                                        <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Add to existing</div>
                                    </div>
                                </label>
                            </div>
                            <label style="display: flex; align-items: center; gap: var(--space-8); padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="importModeRadio"
                                    value="update-open-datetime"
                                    onchange="updateImportMode('update-open-datetime')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">Update Open Date/Time</div>
                                    <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Add opening date/time to existing trades without replacing data</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Clear Data - Danger Zone -->
                    <div>
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium); color: var(--color-error);">
                            <span>üóëÔ∏è</span>
                            <span>Danger Zone</span>
                        </label>
                        <button
                            onclick="clearAllData()"
                            class="btn"
                            style="width: 100%; background: var(--color-error); color: var(--color-btn-primary-text); font-weight: var(--font-weight-medium);">
                            Clear All Data
                        </button>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4); margin-bottom: 0;">
                            ‚ö†Ô∏è This will permanently delete all your trading data
                        </p>
                    </div>
                </div>
            </div>

            <!-- API SETTINGS SECTION -->
            <div class="section" style="margin-bottom: 1.5rem;">
                <button
                    onclick="toggleAPISettings()"
                    class="btn btn--outline"
                    style="width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); margin-bottom: 0; font-weight: var(--font-weight-medium);">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <span style="font-size: var(--font-size-lg);">üîå</span>
                        <span>API Settings</span>
                        <span style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">(Import Historic Trades)</span>
                        <div class="section-info-container">
                            <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                i
                            </span>
                            <div class="section-info-tooltip">
                                <div class="section-info-tooltip-title">üîå API Settings</div>
                                <div class="section-info-tooltip-content">
                                    Connect your trading platform to automatically import historical trade data.
                                    <ul>
                                        <li><strong>MetaTrader API:</strong> Import trades from MT4/MT5 using API tokens</li>
                                        <li><strong>Account ID:</strong> Your unique trading account identifier</li>
                                        <li><strong>Date Range:</strong> Select which trades to import</li>
                                        <li><strong>Auto-sync:</strong> Keep your journal updated automatically</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    <span id="apiSettingsArrow" style="font-size: var(--font-size-xl); transition: transform var(--duration-normal) var(--ease-standard);">‚ñ∂</span>
                </button>

                <div id="apiSettingsSection" style="display: none; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-top: none; border-radius: 0 0 var(--radius-base) var(--radius-base);">
                    <!-- MetaTrader API Settings -->
                    <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--color-bg-1); border-radius: var(--radius-base);">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-12); font-weight: var(--font-weight-medium);">
                            <span>üìä</span>
                            <span>MetaTrader API (MetaApi)</span>
                        </label>

                        <div style="margin-bottom: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-4);">
                                <input
                                    type="checkbox"
                                    id="mtEnabled"
                                    onchange="apiCredentials.metatrader.enabled = this.checked"
                                    style="accent-color: var(--color-primary);">
                                <span style="font-size: var(--font-size-sm);">Enable MetaTrader API</span>
                            </label>
                        </div>

                        <div style="margin-bottom: var(--space-8);">
                            <label class="form-label" style="font-size: var(--font-size-xs); margin-bottom: var(--space-4);">Auth Token</label>
                            <input
                                type="password"
                                id="mtAuthToken"
                                class="form-control"
                                placeholder="Your MetaApi auth token"
                                onchange="apiCredentials.metatrader.authToken = this.value"
                                style="font-size: var(--font-size-sm);">
                            <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4); margin-bottom: 0;">
                                Get your token at <a href="https://app.metaapi.cloud/token" target="_blank" rel="noopener noreferrer" style="color: var(--color-primary);">app.metaapi.cloud/token</a>
                            </p>
                        </div>

                        <div style="margin-bottom: var(--space-8);">
                            <label class="form-label" style="font-size: var(--font-size-xs); margin-bottom: var(--space-4);">Account ID</label>
                            <input
                                type="text"
                                id="mtAccountId"
                                class="form-control"
                                placeholder="Your MetaApi account ID"
                                onchange="apiCredentials.metatrader.accountId = this.value"
                                style="font-size: var(--font-size-sm);">
                        </div>
                    </div>

                    <!-- cTrader API Settings -->
                    <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--color-bg-3); border-radius: var(--radius-base);">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-12); font-weight: var(--font-weight-medium);">
                            <span>üî∑</span>
                            <span>cTrader API</span>
                            <span style="font-size: var(--font-size-xs); padding: 2px 8px; background: var(--color-orange-400); color: white; border-radius: var(--radius-sm);">Advanced</span>
                        </label>

                        <div style="padding: var(--space-12); background: rgba(var(--color-orange-500-rgb), 0.1); border-left: 3px solid var(--color-orange-400); border-radius: var(--radius-sm); margin-bottom: var(--space-12);">
                            <p style="font-size: var(--font-size-xs); color: var(--color-text); margin: 0;">
                                ‚ö†Ô∏è cTrader API requires WebSocket connection with Protocol Buffers. This requires additional JavaScript libraries and is not yet implemented in this version. Please use CSV import for cTrader data.
                            </p>
                        </div>

                        <div style="margin-bottom: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-4);">
                                <input
                                    type="checkbox"
                                    id="ctEnabled"
                                    disabled
                                    style="accent-color: var(--color-primary);">
                                <span style="font-size: var(--font-size-sm); opacity: 0.6;">Enable cTrader API (Coming Soon)</span>
                            </label>
                        </div>
                    </div>

                    <!-- Save Button -->
                    <div style="display: flex; gap: var(--space-8);">
                        <button
                            onclick="saveAPICredentials()"
                            class="btn btn--primary"
                            style="flex: 1;">
                            üíæ Save API Settings
                        </button>
                        <button
                            onclick="toggleAPIImportModal()"
                            class="btn btn--secondary"
                            style="flex: 1;">
                            üì• Import from API
                        </button>
                    </div>
                </div>
            </div>

            <!-- Statistics Dashboard -->
            <div class="section" id="statisticsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleStatistics()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            üìä Performance Statistics
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìä Performance Statistics</div>
                                    <div class="section-info-tooltip-content">
                                        Comprehensive metrics analyzing your trading performance and profitability.
                                        <ul>
                                            <li><strong>Win Rate:</strong> Percentage of profitable trades</li>
                                            <li><strong>Profit Factor:</strong> Gross profit divided by gross loss</li>
                                            <li><strong>Expectancy:</strong> Average profit/loss per trade</li>
                                            <li><strong>Sharpe Ratio:</strong> Risk-adjusted returns</li>
                                            <li><strong>Max Drawdown:</strong> Largest peak-to-trough decline</li>
                                        </ul>
                                        Use the gear icon to customize which stats to display.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="statisticsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: var(--space-8);">
                        <div style="display: flex; align-items: center; gap: var(--space-8); padding: var(--space-4) var(--space-12); background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                            <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">‚Äπ</button>
                            <span id="analyticsStatsMonthDisplay" style="font-weight: bold; min-width: 140px; text-align: center; font-size: var(--font-size-sm);"></span>
                            <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">‚Ä∫</button>
                        </div>
                        <button class="btn btn-secondary" onclick="resetToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time statistics">TOTAL</button>
                        <div style="display: flex; align-items: center; gap: var(--space-8);">
                            <label style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin: 0;">Setup:</label>
                            <select id="setupFilterSelect" onchange="changeSetupFilter(this.value); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs); background: rgba(var(--color-surface), 0.5); border: 1px solid var(--color-border); border-radius: var(--radius-sm); color: var(--color-text); cursor: pointer;">
                                <option value="all">All Setups</option>
                                <option value="Breakout">Breakout</option>
                                <option value="Pullback">Pullback</option>
                                <option value="Reversal">Reversal</option>
                                <option value="Range">Range</option>
                                <option value="Trend Following">Trend Following</option>
                            </select>
                        </div>
                        <button class="toggle-button" onclick="toggleStatsConfig(); event.stopPropagation();" title="Configure Statistics">‚öôÔ∏è</button>
                    </div>
                </div>
                <div class="section-content">
                    <div id="statsConfigPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìã Configure Statistics Display</h4>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-12);">Check which statistics to display. Drag to reorder (future feature).</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-8);" id="statsConfigGrid">
                            <!-- Stats checkboxes will be generated here -->
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border);">
                            <button onclick="showAllStats()" style="background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xs); cursor: pointer; padding: 0;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Show All</button>
                            <button onclick="toggleStatsConfig()" class="btn btn--sm">Done</button>
                        </div>
                    </div>
                    <div class="stats-grid" id="statsGrid">
                        <!-- Stats cards will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Performance Charts -->
            <div class="section" id="chartsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleCharts()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            üìà Performance Charts
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìà Performance Charts</div>
                                    <div class="section-info-tooltip-content">
                                        Visual representations of your trading performance over time.
                                        <ul>
                                            <li><strong>Equity Curve:</strong> Account balance progression</li>
                                            <li><strong>Daily P&L:</strong> Profit/loss by day</li>
                                            <li><strong>Win/Loss Distribution:</strong> Trade outcome patterns</li>
                                            <li><strong>Monthly Performance:</strong> Returns by month</li>
                                        </ul>
                                        Adjust zoom level and configure which charts to display.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="chartsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: var(--space-8);">
                        <select id="chartZoomSelect" onchange="updateChartZoom(this.value); event.stopPropagation();" onclick="event.stopPropagation();" style="padding: var(--space-4) var(--space-8); background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-sm); color: var(--color-text); font-size: var(--font-size-xs);" title="Chart Zoom">
                            <option value="100">100%</option>
                            <option value="150">150%</option>
                            <option value="200">200%</option>
                            <option value="250">250%</option>
                            <option value="300">300%</option>
                        </select>
                        <button class="toggle-button" onclick="toggleChartsConfig(); event.stopPropagation();" title="Configure Charts">‚öôÔ∏è</button>
                    </div>
                </div>
                <div class="section-content">
                    <div id="chartsConfigPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìä Configure Charts Display</h4>
                        <div style="display: flex; flex-direction: column; gap: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="showEquityCurve" checked onchange="toggleChart('equityCurve', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Equity Curve</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="showDailyPL" checked onchange="toggleChart('dailyPL', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Daily P&L</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="showWinLoss" checked onchange="toggleChart('winLoss', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Win/Loss Distribution</span>
                            </label>
                        </div>
                        <div style="display: flex; justify-content: flex-end; margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border);">
                            <button onclick="toggleChartsConfig()" class="btn btn--sm">Done</button>
                        </div>
                    </div>
                    <div class="charts-grid">
                        <div class="chart-container" id="equityContainer">
                            <h4>Equity Curve</h4>
                            <div class="chart">
                                <canvas id="equityChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container" id="dailyPLContainer">
                            <h4>Daily P&amp;L</h4>
                            <div class="chart">
                                <canvas id="dailyPLChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container" id="winLossContainer">
                            <h4>Win/Loss Distribution</h4>
                            <div class="chart">
                                <canvas id="winLossChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Trade History - COLLAPSIBLE -->
            <div class="section" id="tradeHistorySection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleTradeHistory()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            üìã Trade History
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìã Trade History</div>
                                    <div class="section-info-tooltip-content">
                                        Detailed table of all your trades with customizable columns and sorting.
                                        <ul>
                                            <li><strong>View All Trades:</strong> Complete trade history in one table</li>
                                            <li><strong>Customize Columns:</strong> Show/hide specific trade details</li>
                                            <li><strong>Edit Trades:</strong> Click any trade to view and modify details</li>
                                            <li><strong>Sort & Filter:</strong> Click column headers to sort</li>
                                        </ul>
                                        Use the gear icon to configure which columns to display.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="tradeHistoryToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                        <span id="tradeHistoryCount" style="font-size: var(--font-size-sm); color: rgba(255,255,255,0.8); display: none;"></span>
                    </div>
                    <button class="toggle-button" onclick="toggleColumnConfig(); event.stopPropagation();" title="Configure Columns">‚öôÔ∏è</button>
                </div>
                <div class="section-content">
                    <!-- Column configuration (always visible when open) -->
                    <div id="columnsConfigPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìã Configure Table Columns</h4>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-12);">Select which columns to display in the trade history table.</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: var(--space-8);" id="columnsConfigGrid">
                            <!-- Column checkboxes will be generated here -->
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border);">
                            <button onclick="showAllColumns()" style="background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xs); cursor: pointer; padding: 0;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Show All</button>
                            <button onclick="toggleColumnConfig()" class="btn btn--sm">Done</button>
                        </div>
                    </div>

                    <!-- Trade History Table - Collapsible -->
                    <div id="tradeHistoryTableContainer" class="trade-history-content">
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr id="tableHeader">
                                        <!-- Headers will be generated -->
                                    </tr>
                                </thead>
                                <tbody id="tradesTableBody">
                                    <!-- Trade rows will be generated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Collapsed state message -->
                    <div id="tradeHistoryCollapsedMessage" style="display: none; padding: 2rem; background: rgba(var(--color-surface), 0.5); border-radius: var(--radius-base); border: 1px dashed var(--color-border); text-align: center;">
                        <p style="color: var(--color-text-secondary); margin: 0;">
                            Trade History collapsed. Click ‚ñ∂ to expand and view <span id="collapsedTradeCount">0</span> trades.
                        </p>
                    </div>
                </div>
            </div>

            <!-- RULE COMBINATIONS ANALYSIS - NEW -->
            <div class="section" style="display: none;" id="ruleCombinationsSection">
                <div class="section-header" style="cursor: pointer;" onclick="toggleRuleCombinations()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            üî¨ Rule Combinations Analysis
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üî¨ Rule Combinations Analysis</div>
                                    <div class="section-info-tooltip-content">
                                        Discover which combinations of custom trading rules perform best together.
                                        <ul>
                                            <li><strong>Performance Metrics:</strong> Win rate, P&L for each combination</li>
                                            <li><strong>Trade Count:</strong> Number of trades per combination</li>
                                            <li><strong>Best Combinations:</strong> Identify winning rule patterns</li>
                                            <li><strong>Month Navigation:</strong> Analyze combinations by time period</li>
                                        </ul>
                                        Requires custom trading rules to be defined first.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="ruleCombinationsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                        <span style="font-size: var(--font-size-xs); color: rgba(255,255,255,0.8);">
                            (Find best rule combinations)
                        </span>
                    </div>
                    <div style="display: flex; align-items: center; gap: var(--space-8);">
                        <div style="display: flex; align-items: center; gap: var(--space-8); padding: var(--space-4) var(--space-12); background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                            <button class="btn btn-secondary" onclick="changeRuleCombinationsMonth(-1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">‚Äπ</button>
                            <span id="ruleCombinationsMonthDisplay" style="font-weight: bold; min-width: 140px; text-align: center; font-size: var(--font-size-sm);"></span>
                            <button class="btn btn-secondary" onclick="changeRuleCombinationsMonth(1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">‚Ä∫</button>
                        </div>
                        <button class="btn btn-secondary" onclick="resetRuleCombinationsToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time rule combinations">TOTAL</button>
                    </div>
                </div>
                <div class="section-content">
                    <div id="ruleCombinationsContent">
                        <p style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: 1rem;">
                            This analysis shows performance for all possible combinations of your custom trading rules.
                            Find which rules work best together to maximize your win rate and profitability.
                        </p>

                        <div id="ruleCombinationsResults">
                            <!-- Results will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Custom Trading Rules -->
            <div class="section" id="rulesSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleRules()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            Custom Trading Rules
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìù Custom Trading Rules</div>
                                    <div class="section-info-tooltip-content">
                                        Define up to 10 custom rules to categorize and analyze your trades.
                                        <ul>
                                            <li><strong>Create Rules:</strong> Name and define custom trading criteria</li>
                                            <li><strong>Tag Trades:</strong> Apply rules to individual trades</li>
                                            <li><strong>Track Performance:</strong> See win rate and P&L per rule</li>
                                            <li><strong>Combination Analysis:</strong> Find best rule combinations</li>
                                        </ul>
                                        Examples: "Trend Following", "Support/Resistance", "Morning Trades"
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="rulesToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                    <button class="btn btn-secondary" onclick="addCustomRule(); event.stopPropagation();">+ Add Rule</button>
                </div>
                <div class="section-content">
                    <div class="rules-grid" id="rulesGrid">
                        <!-- Rules will be generated here -->
                    </div>
                    <div style="margin-top: 1rem;">
                        <h4>Rule Performance</h4>
                        <div id="ruleStats"></div>
                    </div>
                </div>
            </div>

            <!-- Performance Breakdowns -->
            <div class="section" id="breakdownsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleBreakdowns()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            Performance Breakdowns
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìä Performance Breakdowns</div>
                                    <div class="section-info-tooltip-content">
                                        Analyze performance across different trading categories and conditions.
                                        <ul>
                                            <li><strong>Setup Type:</strong> Performance by trade setup patterns</li>
                                            <li><strong>Market Condition:</strong> Trending vs ranging markets</li>
                                            <li><strong>Emotional State:</strong> Confident, uncertain, FOMO, revenge</li>
                                            <li><strong>Rule Adherence:</strong> Followed vs violated trading rules</li>
                                        </ul>
                                        Add these tags to trades for deeper insights.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="breakdownsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                </div>
                <div class="section-content">
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Setup Type</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="breakdownSetupMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                                <button class="btn btn-secondary" onclick="resetBreakdownToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time breakdown">TOTAL</button>
                            </div>
                            <div class="breakdown-grid" id="setupBreakdown"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Market Condition</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="breakdownMarketMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                                <button class="btn btn-secondary" onclick="resetBreakdownToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time breakdown">TOTAL</button>
                            </div>
                            <div class="breakdown-grid" id="marketBreakdown"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Emotional State</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="breakdownEmotionalMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                                <button class="btn btn-secondary" onclick="resetBreakdownToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time breakdown">TOTAL</button>
                            </div>
                            <div class="breakdown-grid" id="emotionalBreakdown"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Rule Adherence</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="breakdownRuleMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                                <button class="btn btn-secondary" onclick="resetBreakdownToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time breakdown">TOTAL</button>
                            </div>
                            <div class="breakdown-grid" id="ruleBreakdown"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Time-based Analytics -->
            <div class="section" id="timeAnalyticsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleTimeAnalytics()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            Time-based Analytics
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìÖ Time-based Analytics</div>
                                    <div class="section-info-tooltip-content">
                                        Discover when you trade most profitably throughout different time periods.
                                        <ul>
                                            <li><strong>Monthly Performance:</strong> P&L trends by month</li>
                                            <li><strong>Daily Analysis:</strong> Best and worst days of the week</li>
                                            <li><strong>Hourly Performance:</strong> Optimal trading hours</li>
                                            <li><strong>Open vs Close:</strong> Entry vs exit time patterns</li>
                                        </ul>
                                        Identify your most profitable trading times.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="timeAnalyticsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                </div>
                <div class="section-content">
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>Monthly Performance</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="analyticsMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                            </div>
                            <div id="monthlyStats"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>Daily Performance</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="analyticsDailyMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                            </div>
                            <div id="dailyStats"></div>
                        </div>
                    </div>

                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>OPEN HOURLY PERFORMANCE</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="analyticsOpenHourlyMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                            </div>
                            <div id="openHourlyStats"></div>
                        </div>
                    </div>

                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>CLOSE HOURLY PERFORMANCE</span>
                            <span>‚ñº</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                                <span id="analyticsCloseHourlyMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                            </div>
                            <div id="hourlyStats"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Calendar View -->
            <div class="section" id="calendarSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleCalendar()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            Calendar View
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üìÖ Calendar View</div>
                                    <div class="section-info-tooltip-content">
                                        Visual calendar showing trading activity and performance by day.
                                        <ul>
                                            <li><strong>Trading Days:</strong> Days with trades highlighted</li>
                                            <li><strong>Daily P&L:</strong> Profit/loss shown for each day</li>
                                            <li><strong>Color Coding:</strong> Green for profits, red for losses</li>
                                            <li><strong>Monthly Navigation:</strong> Browse through trading history</li>
                                        </ul>
                                        Quickly identify patterns in your trading schedule.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="calendarToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                    <div>
                        <button class="btn btn-secondary" onclick="changeMonth(-1); event.stopPropagation();">‚Äπ Prev</button>
                        <span id="calendarMonth"></span>
                        <button class="btn btn-secondary" onclick="changeMonth(1); event.stopPropagation();">Next ‚Ä∫</button>
                    </div>
                </div>
                <div class="section-content">
                    <div class="calendar" id="calendar"></div>
                </div>
            </div>

            <!-- Monte Carlo Simulation -->
            <div class="section" id="monteCarloSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleMonteCarlo()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            üé≤ Monte Carlo Simulation
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">üé≤ Monte Carlo Simulation</div>
                                    <div class="section-info-tooltip-content">
                                        Run thousands of simulations to assess risk and potential outcomes.
                                        <ul>
                                            <li><strong>Risk Analysis:</strong> Probability of drawdowns and profits</li>
                                            <li><strong>Simulations:</strong> Randomize trade order 10,000 times</li>
                                            <li><strong>Percentiles:</strong> Best/worst case scenarios (5th, 50th, 95th)</li>
                                            <li><strong>Visualizations:</strong> Distribution charts and equity curves</li>
                                        </ul>
                                        Understand the range of possible outcomes from your trading strategy.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="monteCarloToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                    <div>
                        <button class="btn btn-primary" onclick="runMonteCarloSimulation(); event.stopPropagation();">Run Simulation</button>
                    </div>
                </div>
                <div class="section-content">
                    <!-- Simulation Mode Selector -->
                    <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üéØ Simulation Mode</h4>
                        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                            <button id="mcModeStandard" class="btn btn-secondary" onclick="switchMCMode('standard')" style="flex: 1; background: var(--color-primary); border-color: var(--color-primary);">Standard Monte Carlo</button>
                            <button id="mcModePropFirm" class="btn btn-secondary" onclick="switchMCMode('propfirm')" style="flex: 1;">Prop Firm Challenge</button>
                        </div>
                    </div>

                    <!-- Configuration Panel - Standard Mode -->
                    <div id="mcStandardConfig" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">‚öôÔ∏è Standard Simulation Settings</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Number of Simulations</label>
                                <input type="number" id="mcNumSimulations" value="1000" min="100" max="10000" step="100"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Number of Trades to Simulate</label>
                                <input type="number" id="mcNumTrades" value="100" min="10" max="1000" step="10"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Position Size (% of Account)</label>
                                <input type="number" id="mcPositionSize" value="2" min="0.1" max="100" step="0.1"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                        </div>
                    </div>

                    <!-- Configuration Panel - Prop Firm Mode -->
                    <div id="mcPropFirmConfig" style="display: none; margin-bottom: 1.5rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üè¢ Prop Firm Challenge Settings</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem;">
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Number of Simulations</label>
                                <input type="number" id="pfNumSimulations" value="1000" min="100" max="10000" step="100"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Challenge Balance ($)</label>
                                <input type="number" id="pfChallengeBalance" value="100000" min="1000" max="1000000" step="1000"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Profit Target (%)</label>
                                <input type="number" id="pfProfitTarget" value="10" min="1" max="100" step="0.5"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Max Drawdown (%)</label>
                                <input type="number" id="pfMaxDrawdown" value="10" min="1" max="50" step="0.5"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                                <div style="font-size: 10px; color: var(--color-text-secondary); margin-top: 4px;">From initial balance</div>
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Daily Loss Limit (%)</label>
                                <input type="number" id="pfDailyLossLimit" value="5" min="1" max="50" step="0.5"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                                <div style="font-size: 10px; color: var(--color-text-secondary); margin-top: 4px;">From previous day close</div>
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Min Trading Days</label>
                                <input type="number" id="pfMinTradingDays" value="5" min="1" max="100" step="1"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Position Size (% of Account)</label>
                                <input type="number" id="pfPositionSize" value="2" min="0.1" max="100" step="0.1"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Min Trades Per Day</label>
                                <input type="number" id="pfMinTradesPerDay" value="3" min="1" max="50" step="1"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Max Trades Per Day</label>
                                <input type="number" id="pfMaxTradesPerDay" value="10" min="1" max="50" step="1"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Custom Avg Win ($)</label>
                                <input type="number" id="pfCustomAvgWin" value="" placeholder="Leave empty for historical"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                                <div style="font-size: 10px; color: var(--color-text-secondary); margin-top: 4px;">Optional override</div>
                            </div>
                            <div>
                                <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-8);">Custom Avg Loss ($)</label>
                                <input type="number" id="pfCustomAvgLoss" value="" placeholder="Leave empty for historical"
                                    style="width: 100%; padding: var(--space-8); border: 1px solid var(--color-border); border-radius: var(--radius-sm); background: var(--color-background); color: var(--color-text);">
                                <div style="font-size: 10px; color: var(--color-text-secondary); margin-top: 4px;">Optional override (enter as negative)</div>
                            </div>
                        </div>
                        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(74, 158, 255, 0.1); border: 1px solid rgba(74, 158, 255, 0.3); border-radius: var(--radius-sm); font-size: var(--font-size-xs); color: var(--color-text-secondary);">
                            <strong>‚ÑπÔ∏è Challenge Rules:</strong>
                            <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
                                <li>Pass: Reach profit target while meeting minimum trading days</li>
                                <li>Fail: Exceed max drawdown OR daily loss limit</li>
                                <li>Max Drawdown: Measured from initial balance</li>
                                <li>Daily Loss Limit: Measured from previous trading day's closing balance</li>
                            </ul>
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(74, 158, 255, 0.2);">
                                <strong>üí° Custom Settings:</strong>
                                <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
                                    <li>Trades Per Day: Simulation will randomly use between min and max trades per day</li>
                                    <li>Custom Avg Win/Loss: Override historical averages for hypothetical scenarios</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- Baseline Data -->
                    <div id="monteCarloBaselineData" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìä Baseline Historical Data</h4>
                        <div id="monteCarloBaselineContent" style="color: var(--color-text-secondary); font-size: var(--font-size-xs);">
                            <!-- Baseline stats will be dynamically inserted here -->
                        </div>
                    </div>

                    <!-- Results Summary - Standard Mode -->
                    <div id="monteCarloResults" style="display: none;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div class="stat-card">
                                <div class="stat-label">Expected Final Balance</div>
                                <div class="stat-value" id="mcExpectedBalance">$0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">95% Confidence Interval</div>
                                <div class="stat-value" id="mcConfidenceInterval">$0 - $0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Probability of Profit</div>
                                <div class="stat-value" id="mcProfitProb">0%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Risk of Ruin (50% Loss)</div>
                                <div class="stat-value" id="mcRiskOfRuin">0%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Best Case (95th %ile)</div>
                                <div class="stat-value" id="mcBestCase">$0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Worst Case (5th %ile)</div>
                                <div class="stat-value" id="mcWorstCase">$0</div>
                            </div>
                        </div>

                        <!-- Charts -->
                        <div style="display: grid; grid-template-columns: 1fr; gap: 1.5rem;">
                            <div style="background: var(--color-surface); padding: 1rem; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <h4 style="margin: 0 0 1rem 0; font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold);">Distribution of Final Account Balance</h4>
                                <canvas id="mcDistributionChart"></canvas>
                            </div>
                            <div style="background: var(--color-surface); padding: 1rem; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <h4 style="margin: 0 0 1rem 0; font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold);">Sample Equity Curves (100 simulations)</h4>
                                <canvas id="mcEquityChart"></canvas>
                            </div>
                            <div style="background: var(--color-surface); padding: 1rem; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <h4 style="margin: 0 0 1rem 0; font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold);">Drawdown Distribution</h4>
                                <canvas id="mcDrawdownChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Results Summary - Prop Firm Mode -->
                    <div id="propFirmResults" style="display: none;">
                        <!-- Key Statistics -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div class="stat-card">
                                <div class="stat-label">Challenge Success Rate</div>
                                <div class="stat-value" id="pfSuccessRate">0%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Avg Days to Pass</div>
                                <div class="stat-value" id="pfAvgDaysPass">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Avg Days to Fail</div>
                                <div class="stat-value" id="pfAvgDaysFail">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Max DD Violations</div>
                                <div class="stat-value" id="pfMaxDDViolations">0%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Daily Loss Violations</div>
                                <div class="stat-value" id="pfDailyLossViolations">0%</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Avg Final Balance (Passed)</div>
                                <div class="stat-value" id="pfAvgFinalBalance">$0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Avg Trade Profit</div>
                                <div class="stat-value" id="pfAvgTradeProfit">$0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Avg Trade Loss</div>
                                <div class="stat-value" id="pfAvgTradeLoss">$0</div>
                            </div>
                        </div>

                        <!-- Outcome Breakdown -->
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                            <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìä Outcome Breakdown</h4>
                            <div id="pfOutcomeBreakdown" style="color: var(--color-text-secondary); font-size: var(--font-size-xs);">
                                <!-- Outcome details will be dynamically inserted here -->
                            </div>
                        </div>

                        <!-- Charts -->
                        <div style="display: grid; grid-template-columns: 1fr; gap: 1.5rem;">
                            <div style="background: var(--color-surface); padding: 1rem; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <h4 style="margin: 0 0 1rem 0; font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold);">Challenge Outcomes Distribution</h4>
                                <canvas id="pfOutcomeChart"></canvas>
                            </div>
                            <div style="background: var(--color-surface); padding: 1rem; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <h4 style="margin: 0 0 1rem 0; font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold);">Sample Equity Curves</h4>
                                <canvas id="pfEquityChart"></canvas>
                            </div>
                            <div style="background: var(--color-surface); padding: 1rem; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <h4 style="margin: 0 0 1rem 0; font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold);">Days to Complete Distribution</h4>
                                <canvas id="pfDaysChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Loading Indicator -->
                    <div id="monteCarloLoading" style="display: none; text-align: center; padding: 3rem;">
                        <div style="display: inline-block; width: 60px; height: 60px; border: 6px solid rgba(33, 128, 141, 0.2); border-top-color: rgba(33, 128, 141, 1); border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <p style="margin-top: 1.5rem; font-size: var(--font-size-base); color: var(--color-text); font-weight: var(--font-weight-semibold);">Running simulation...</p>
                        <p style="margin-top: 0.5rem; font-size: var(--font-size-sm); color: var(--color-text-secondary);">This may take a few moments depending on the number of simulations.</p>
                    </div>

                    <div id="monteCarloPlaceholder" style="text-align: center; padding: 3rem; color: var(--color-text-secondary);">
                        <p style="font-size: var(--font-size-base); margin: 0;">Configure settings above and click "Run Simulation" to analyze your trading strategy's risk profile.</p>
                    </div>
                </div>
            </div>

            <!-- AI Analysis -->
            <div class="section" id="aiSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleAI()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">
                            ü§ñ AI Analysis
                            <div class="section-info-container">
                                <span class="section-info-icon" onclick="toggleInfoTooltip(event, this.nextElementSibling);">
                                    i
                                </span>
                                <div class="section-info-tooltip">
                                    <div class="section-info-tooltip-title">ü§ñ AI Analysis</div>
                                    <div class="section-info-tooltip-content">
                                        Generate AI-powered insights from your trading data using ChatGPT or Claude.
                                        <ul>
                                            <li><strong>Auto-Generated Prompts:</strong> Pre-formatted analysis requests</li>
                                            <li><strong>Custom Context:</strong> Include stats, trades, rules, and more</li>
                                            <li><strong>Trade Selection:</strong> Analyze all trades or specific ones</li>
                                            <li><strong>Copy & Paste:</strong> Easy export to AI platforms</li>
                                        </ul>
                                        Get personalized trading insights and improvement suggestions.
                                    </div>
                                </div>
                            </div>
                        </h3>
                        <button
                            id="aiToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">‚ñº</button>
                    </div>
                </div>
                <div class="section-content">
                    <!-- Strategy Context Box - NEW -->
                    <div style="margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìã Strategy Context (Optional)</h4>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-12);">
                            Describe your trading strategy to help AI provide more relevant insights. You can select an example below and customize it, or write your own from scratch.
                        </p>
                        
                        <!-- Example Strategy Selector -->
                        <div style="margin-bottom: var(--space-12);">
                            <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-4);">
                                üí° Load Example Strategy:
                            </label>
                            <select
                                id="strategyExampleSelector"
                                class="form-control"
                                style="margin-bottom: var(--space-4);"
                                onchange="loadStrategyExample(this.value)">
                                <option value="">-- Select an example or write your own --</option>
                                <option value="ict">ICT (Inner Circle Trader) Strategy</option>
                                <option value="supplyDemand">Supply &amp; Demand Zones</option>
                                <option value="priceAction">Pure Price Action Day Trading</option>
                                <option value="breakout">Breakout Trading</option>
                                <option value="trendFollowing">Trend Following (MA Crossover)</option>
                                <option value="scalpingStrategy">Scalping Strategy</option>
                                <option value="swingTrading">Swing Trading</option>
                            </select>
                            <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">
                                üí° Select an example to load it, then customize it to match your specific approach
                            </p>
                        </div>
                        <textarea
                            id="strategyContextTextarea"
                            class="form-control"
                            rows="6"
                            placeholder="Describe your trading strategy, methodology, timeframes, risk management, entry/exit criteria, trading sessions, instruments, and goals..."
                            style="width: 100%; margin-bottom: var(--space-8); resize: vertical;"
                            maxlength="2000"
                            onchange="updateStrategyContext(this.value)"
                            oninput="updateStrategyContextCounter()"></textarea>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-8);">
                            <button
                                type="button"
                                onclick="clearStrategyContext()"
                                style="background: none; border: none; color: var(--color-error); font-size: var(--font-size-xs); cursor: pointer; padding: 0;"
                                onmouseover="this.style.textDecoration='underline'"
                                onmouseout="this.style.textDecoration='none'">Clear</button>
                            <div id="strategyContextCounter" style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">
                                0 / 2000 characters
                            </div>
                        </div>
                    </div>
                    
                    <!-- Include in Prompt checkboxes -->
                    <div style="margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">üìã Include in AI Prompt:</h4>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeOverview" checked onchange="updateAiPromptInclusion('overview', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Performance Overview</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeSetupPerformance" checked onchange="updateAiPromptInclusion('setupPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Setup Type Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeMarketCondition" checked onchange="updateAiPromptInclusion('marketCondition', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Market Conditions</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeEmotionalState" checked onchange="updateAiPromptInclusion('emotionalState', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Emotional State</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeRuleAdherence" checked onchange="updateAiPromptInclusion('ruleAdherence', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Rule Adherence</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeMonthlyPerformance" checked onchange="updateAiPromptInclusion('monthlyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Monthly Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeMonthOverMonth" checked onchange="updateAiPromptInclusion('monthOverMonthAnalysis', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Month-over-Month Evolution</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeDailyPerformance" checked onchange="updateAiPromptInclusion('dailyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Daily Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeOpenHourlyPerformance" checked onchange="updateAiPromptInclusion('openHourlyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Open Hourly Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeCloseHourlyPerformance" checked onchange="updateAiPromptInclusion('closeHourlyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Close Hourly Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeCustomRules" checked onchange="updateAiPromptInclusion('customRules', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Custom Trading Rules</span>
                            </label>
                            <!-- Trade details dropdown replaces checkbox -->
                            <div style="grid-column: span 2; margin-top: var(--space-8); padding-top: var(--space-8); border-top: 1px solid var(--color-border);">
                                <label style="display: block; font-size: var(--font-size-sm); font-weight: var(--font-weight-medium); margin-bottom: var(--space-8); color: var(--color-text);">
                                    üìù Individual Trade Details:
                                </label>
                                <select id="tradesOption" class="form-control" onchange="updateAiPromptInclusion('tradesOption', this.value)" style="width: 100%;">
                                    <option value="none">None - Don't include trades</option>
                                    <option value="recent10">Recent 10 trades</option>
                                    <option value="recent20">Recent 20 trades</option>
                                    <option value="recent50">Recent 50 trades</option>
                                    <option value="all">All trades</option>
                                    <option value="winning">Winning trades only</option>
                                    <option value="losing">Losing trades only</option>
                                    <option value="bestWorst">Best 5 &amp; Worst 5 trades</option>
                                </select>
                                <p id="tradesOptionHelper" style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);"></p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Analysis Format</label>
                        <select id="analysisFormat" class="form-control" onchange="appState.exportPromptFormat = this.value">
                            <option value="readable">Easy to Read</option>
                            <option value="json">JSON Technical</option>
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: var(--space-8); margin-bottom: var(--space-16);">
                        <button class="btn" onclick="generateAIAnalysisPrompt()">Generate AI Analysis</button>
                        <button class="btn btn-secondary" onclick="copyAIPromptToClipboard()" id="copyPromptBtn" disabled>üìã Copy Prompt</button>
                    </div>
                    
                    <div id="promptCopiedMessage" style="display: none; padding: var(--space-8); background: var(--color-bg-3); color: var(--color-success); border-radius: var(--radius-base); font-size: var(--font-size-sm); margin-bottom: var(--space-16);">‚úÖ Prompt copied to clipboard!</div>
                    
                    <div id="analysisPrompt" style="margin-top: 1rem; display: none;">
                        <label for="promptText" style="display: block; margin-bottom: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text-secondary);">
                            üí° Edit the prompt below if needed, then click Copy Prompt
                        </label>
                        <textarea id="promptText" class="form-control" rows="15"></textarea>
                    </div>
                </div>
            </div>

            <!-- Download Notification -->
            <div id="downloadNotificationContainer"></div>

            <!-- Footer -->
            <footer style="margin-top: var(--space-32); padding-top: var(--space-16); border-top: 1px solid var(--color-border); text-align: center; font-size: var(--font-size-sm); color: var(--color-text-secondary);">
                <p>Comprehensive Trading Journal | Built with Chart.js &amp; Modern Web Technologies</p>
                <p style="font-size: var(--font-size-xs); margin-top: var(--space-4);">¬© 2025 | Your complete trading analysis solution</p>
            </footer>

            <!-- Empty State -->
            <div id="emptyState" class="section" style="text-align: center; padding: 4rem 2rem;">
                <h2>üìä Welcome to Your Trading Journal</h2>
                <p style="color: #94a3b8; margin: 1rem 0;">Import your trading data to start analyzing your performance</p>
                <p style="font-size: 0.875rem; color: #6b7280;">Supported platforms: cTrader, MT4, MT5<br>
                <em>Note: Trades with numeric-only symbols will be automatically filtered out</em></p>
                <button class="btn" onclick="document.getElementById('csvInput').click()" style="margin-top: 1rem;">
                    üìÑ Import Your First CSV
                </button>
            </div>
        </div>
    </div>

    <!-- Lightbox for screenshots -->
    <div id="lightbox" class="lightbox" style="display: none;" onclick="closeLightbox()">
        <button class="lightbox-close" onclick="closeLightbox()">√ó</button>
        <img id="lightboxImage" alt="Trade Screenshot">
    </div>

    <!-- API Import Modal -->
    <div id="apiImportModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: var(--color-surface); padding: 2rem; border-radius: var(--radius-lg); max-width: 500px; width: 90%; box-shadow: var(--shadow-xl);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h3 style="margin: 0; color: var(--color-text); display: flex; align-items: center; gap: var(--space-8);">
                    <span>üì•</span>
                    <span>Import from API</span>
                </h3>
                <button onclick="toggleAPIImportModal()" style="background: none; border: none; font-size: 2rem; color: var(--color-text-secondary); cursor: pointer; line-height: 1; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.color='var(--color-text)'" onmouseout="this.style.color='var(--color-text-secondary)'">√ó</button>
            </div>

            <div style="margin-bottom: 1rem;">
                <label class="form-label" style="display: block; margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">Platform</label>
                <select id="apiPlatform" class="form-control">
                    <option value="metatrader">MetaTrader (via MetaApi)</option>
                    <option value="ctrader" disabled>cTrader (Coming Soon)</option>
                </select>
            </div>

            <div style="margin-bottom: 1rem;">
                <label class="form-label" style="display: block; margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">Start Date</label>
                <input type="date" id="apiStartDate" class="form-control">
            </div>

            <div style="margin-bottom: 1rem;">
                <label class="form-label" style="display: block; margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">End Date</label>
                <input type="date" id="apiEndDate" class="form-control">
            </div>

            <div style="margin-bottom: 1.5rem;">
                <label class="form-label" style="display: block; margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">Import Mode</label>
                <select id="apiImportMode" class="form-control">
                    <option value="append">Append (Add to existing trades)</option>
                    <option value="overwrite">Overwrite (Replace all trades)</option>
                </select>
            </div>

            <div style="padding: var(--space-12); background: var(--color-bg-1); border-radius: var(--radius-base); margin-bottom: 1.5rem;">
                <p style="font-size: var(--font-size-xs); color: var(--color-text); margin: 0;">
                    üí° Make sure you've configured your API credentials in the <strong>API Settings</strong> section before importing.
                </p>
            </div>

            <div style="display: flex; gap: var(--space-8);">
                <button onclick="toggleAPIImportModal()" class="btn btn--secondary" style="flex: 1;">Cancel</button>
                <button onclick="handleAPIImport()" class="btn btn--primary" style="flex: 1;">Import Trades</button>
            </div>
        </div>
    </div>

    <!-- Features Modal -->
    <div id="featuresModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; justify-content: center; align-items: center; overflow-y: auto;">
        <div style="background: var(--color-surface); padding: 2rem; border-radius: var(--radius-lg); max-width: 800px; width: 90%; box-shadow: var(--shadow-xl); margin: 2rem auto; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; position: sticky; top: 0; background: var(--color-surface); z-index: 1; padding-bottom: 1rem;">
                <h3 style="margin: 0; color: var(--color-text); display: flex; align-items: center; gap: var(--space-8);">
                    <span>‚ÑπÔ∏è</span>
                    <span>Z-APP Features Guide</span>
                </h3>
                <button onclick="toggleFeaturesModal()" style="background: none; border: none; font-size: 2rem; color: var(--color-text-secondary); cursor: pointer; line-height: 1; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.color='var(--color-text)'" onmouseout="this.style.color='var(--color-text-secondary)'">√ó</button>
            </div>

            <div style="color: var(--color-text); line-height: 1.6;">
                <!-- Introduction -->
                <div style="padding: 1rem; background: var(--color-bg-1); border-radius: var(--radius-base); margin-bottom: 1.5rem; border-left: 4px solid var(--color-primary);">
                    <p style="margin: 0; font-size: var(--font-size-base);">
                        <strong>Z-APP</strong> is a comprehensive trading journal designed to help you track, analyze, and optimize your trading performance. Here's everything you can do:
                    </p>
                </div>

                <!-- Data Management -->
                <div style="margin-bottom: 2rem;">
                    <h4 style="color: var(--color-primary); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>üíæ</span> Data Management
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; display: grid; gap: 0.75rem;">
                        <li><strong>Auto-Save:</strong> Automatically saves your data every 30 seconds (toggle on/off)</li>
                        <li><strong>Manual Save:</strong> Save your data instantly at any time</li>
                        <li><strong>Storage Info:</strong> Monitor your data usage (100MB limit with IndexedDB)</li>
                        <li><strong>Import CSV:</strong> Import trades from CSV files (cTrader, MT4, MT5 formats)</li>
                        <li><strong>Import Data:</strong> Import complete journal data from JSON files</li>
                        <li><strong>Import from API:</strong> Connect to MetaTrader API for automated trade imports</li>
                        <li><strong>Export Options:</strong> Full export, trades only, without screenshots, screenshots only, or CSV format</li>
                    </ul>
                </div>

                <!-- Trade Management -->
                <div style="margin-bottom: 2rem;">
                    <h4 style="color: var(--color-primary); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>üìä</span> Trade Management
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; display: grid; gap: 0.75rem;">
                        <li><strong>Add Trades:</strong> Manually add new trades with detailed information</li>
                        <li><strong>Edit Trades:</strong> Modify existing trade details at any time</li>
                        <li><strong>Delete Trades:</strong> Remove trades from your history</li>
                        <li><strong>Trade Details:</strong> Track symbol, direction, entry/exit prices, volume, commission, swap</li>
                        <li><strong>Journal Notes:</strong> Add setup type, market condition, emotional state, and notes</li>
                        <li><strong>Rule Adherence:</strong> Track which trading rules you followed</li>
                        <li><strong>Screenshots:</strong> Attach entry and exit screenshots to trades</li>
                        <li><strong>TradingView Integration:</strong> Paste TradingView URLs to automatically capture chart snapshots</li>
                    </ul>
                </div>

                <!-- Analytics & Statistics -->
                <div style="margin-bottom: 2rem;">
                    <h4 style="color: var(--color-primary); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>üìà</span> Analytics & Statistics
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; display: grid; gap: 0.75rem;">
                        <li><strong>Performance Metrics:</strong> Win rate, total P&L, average win/loss, profit factor, expectancy</li>
                        <li><strong>Monthly Performance:</strong> Track profit/loss by month with visual charts</li>
                        <li><strong>Daily Performance:</strong> Analyze performance by day of the week</li>
                        <li><strong>Hourly Performance:</strong> Identify your most profitable trading hours</li>
                        <li><strong>Rule Performance:</strong> See which trading rules contribute to your success</li>
                        <li><strong>Setup Performance:</strong> Analyze performance by setup type</li>
                        <li><strong>Market Condition Analysis:</strong> Compare performance across different market conditions</li>
                        <li><strong>Equity Curve:</strong> Visualize your account balance over time</li>
                    </ul>
                </div>

                <!-- Advanced Analysis -->
                <div style="margin-bottom: 2rem;">
                    <h4 style="color: var(--color-primary); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>üé≤</span> Advanced Analysis
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; display: grid; gap: 0.75rem;">
                        <li><strong>Monte Carlo Simulation:</strong> Run 1000-5000 simulations to project potential outcomes</li>
                        <li><strong>Risk of Ruin:</strong> Calculate probability of losing a percentage of your account</li>
                        <li><strong>Drawdown Analysis:</strong> Track maximum drawdown and recovery periods</li>
                        <li><strong>Confidence Intervals:</strong> 10th, 50th, and 90th percentile projections</li>
                        <li><strong>Probability Analysis:</strong> Understand the range of possible trading outcomes</li>
                    </ul>
                </div>

                <!-- Customization -->
                <div style="margin-bottom: 2rem;">
                    <h4 style="color: var(--color-primary); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>‚öôÔ∏è</span> Customization
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; display: grid; gap: 0.75rem;">
                        <li><strong>Custom Rules:</strong> Create and manage your own trading rules</li>
                        <li><strong>Starting Balance:</strong> Set your initial account equity</li>
                        <li><strong>Platform Selection:</strong> Choose between cTrader, MT4, or MT5</li>
                        <li><strong>Import Modes:</strong> Overwrite, append, or update existing data</li>
                        <li><strong>Dark Mode:</strong> Automatic dark mode based on system preferences</li>
                        <li><strong>Collapsible Sections:</strong> Customize your view by expanding/collapsing sections</li>
                    </ul>
                </div>

                <!-- Visualization -->
                <div style="margin-bottom: 2rem;">
                    <h4 style="color: var(--color-primary); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <span>üìä</span> Visualization Tools
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; display: grid; gap: 0.75rem;">
                        <li><strong>Interactive Charts:</strong> Powered by Chart.js for rich visualizations</li>
                        <li><strong>Calendar View:</strong> See your P&L on a monthly calendar</li>
                        <li><strong>Performance Graphs:</strong> Multiple chart types for different metrics</li>
                        <li><strong>Screenshot Lightbox:</strong> View trade screenshots in full screen</li>
                        <li><strong>Color-Coded Data:</strong> Green for profits, red for losses, visual indicators</li>
                    </ul>
                </div>

                <!-- Tips -->
                <div style="padding: 1rem; background: var(--color-bg-1); border-radius: var(--radius-base); border-left: 4px solid var(--color-teal-500);">
                    <h4 style="margin: 0 0 0.75rem 0; color: var(--color-teal-500); display: flex; align-items: center; gap: 0.5rem;">
                        <span>üí°</span> Pro Tips
                    </h4>
                    <ul style="margin: 0; padding-left: 1.5rem; font-size: var(--font-size-sm); display: grid; gap: 0.5rem;">
                        <li>Click the <strong>‚ÑπÔ∏è (i) icons</strong> next to each section for detailed help</li>
                        <li>Use <strong>auto-save</strong> to prevent data loss</li>
                        <li>Export your data regularly as a backup</li>
                        <li>Attach screenshots to trades for better review and analysis</li>
                        <li>Define custom rules to track your strategy adherence</li>
                        <li>Use Monte Carlo simulations to set realistic expectations</li>
                        <li>Review your performance by time of day to optimize your trading schedule</li>
                    </ul>
                </div>
            </div>

            <div style="margin-top: 1.5rem; text-align: center;">
                <button onclick="toggleFeaturesModal()" class="btn btn--primary">Got it!</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // SECURITY FUNCTIONS - Added for XSS and injection protection
        // ============================================================================
        
        // Security: HTML sanitization helper
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Security: URL sanitization helper
        function sanitizeUrl(url) {
            if (!url) return '';
            try {
                const urlObj = new URL(url);
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    return '';
                }
                return urlObj.href;
            } catch {
                return '';
            }
        }

        // Security: Screenshot URL sanitization - allows data URIs and http/https URLs
        function sanitizeScreenshotUrl(url) {
            if (!url || typeof url !== 'string') return '';

            // Allow data URIs for base64 images (from paste/upload)
            if (url.startsWith('data:image/')) {
                return url;
            }

            // Allow http/https URLs (for TradingView links, etc.)
            try {
                const urlObj = new URL(url);
                if (['http:', 'https:'].includes(urlObj.protocol)) {
                    return urlObj.href;
                }
            } catch {
                // Invalid URL format
            }

            return '';
        }

        // Security: Safe URL opener with validation
        function safeOpenURL(url) {
            if (!url || !url.trim()) {
                showMessage('Please enter a valid URL first', 'error');
                return;
            }
            try {
                const fullUrl = url.startsWith('http') ? url : 'https://' + url;
                const urlObj = new URL(fullUrl);
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    throw new Error('Invalid protocol - only HTTP and HTTPS are allowed');
                }
                window.open(urlObj.href, '_blank', 'noopener,noreferrer');
            } catch (error) {
                showMessage('Invalid URL: ' + error.message, 'error');
            }
        }

        // Security: File size validation constant
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB

        // Security: Trade data validation
        function validateTrade(trade) {
            if (!trade || typeof trade !== 'object') {
                throw new Error('Invalid trade object');
            }
            if (!trade.symbol || typeof trade.symbol !== 'string' || trade.symbol.length === 0) {
                throw new Error('Invalid symbol');
            }
            if (!Number.isFinite(trade.entryPrice) || trade.entryPrice < 0) {
                throw new Error('Invalid entry price');
            }
            if (!Number.isFinite(trade.exitPrice) || trade.exitPrice < 0) {
                throw new Error('Invalid exit price');
            }
            return true;
        }

        // ============================================================================
        // END SECURITY FUNCTIONS
        // ============================================================================

        // ============================================================================
        // INFO TOOLTIP POSITIONING - Fixed positioning to appear on top of everything
        // ============================================================================
        document.addEventListener('DOMContentLoaded', function() {
            const infoIcons = document.querySelectorAll('.section-info-icon');

            infoIcons.forEach(icon => {
                const tooltip = icon.querySelector('.section-info-tooltip');
                if (!tooltip) return;

                icon.addEventListener('mouseenter', function() {
                    const iconRect = icon.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();

                    // Position tooltip below the icon, centered horizontally
                    const left = iconRect.left + (iconRect.width / 2) - (tooltipRect.width / 2);
                    const top = iconRect.bottom + 8;

                    // Adjust if tooltip would go off the right edge of the screen
                    const adjustedLeft = Math.min(left, window.innerWidth - tooltipRect.width - 16);
                    // Adjust if tooltip would go off the left edge of the screen
                    const finalLeft = Math.max(16, adjustedLeft);

                    tooltip.style.left = finalLeft + 'px';
                    tooltip.style.top = top + 'px';
                });
            });
        });
        // ============================================================================
        // END INFO TOOLTIP POSITIONING
        // ============================================================================

        // Symbol Validation Function
        // Filters out numeric-only symbols (e.g. "123", "456789") during import
        // Valid symbols: "EURUSD", "GBPUSD", "US30", "BTC-USD", etc.
        // Invalid symbols: "123", "456789", "001", "999", etc.
        function isValidSymbol(symbol) {
            if (!symbol || typeof symbol !== 'string') return false;
            // Skip if symbol is only digits (regex matches start-to-end digits only)
            if (/^\d+$/.test(symbol)) return false;
            // Must contain at least one letter or valid symbol character
            return /[a-zA-Z]/.test(symbol);
        }

        // Strategy Examples Object
        const strategyExamples = {
            ict: `I trade using ICT (Inner Circle Trader) concepts including market structure, order blocks, fair value gaps, and liquidity sweeps. I focus on 15-minute and 1-hour timeframes during London and New York sessions. My entry criteria include waiting for liquidity sweeps above/below key levels, followed by a market structure shift, and entering on pullbacks to order blocks or fair value gaps. I target a minimum 2:1 risk-reward ratio and risk 1-2% per trade. I primarily trade EURUSD, GBPUSD, and USDJPY.`,
            
            supplyDemand: `I trade supply and demand zones with confirmation from technical indicators. I look for fresh zones where price has spent minimal time, preferring zones with strong rejection wicks. I use stochastic oscillator for overbought/oversold confirmation and enter on reversal patterns at zone boundaries. I trade on 1-hour and 4-hour charts across all trading sessions. My targets are set at 3:1 minimum risk-reward ratio with a trailing stop to capture extended moves.`,
            
            priceAction: `I'm a pure price action day trader focusing on key support/resistance levels and candlestick patterns. I trade exclusively on 5-minute charts during the New York session (8 AM - 12 PM EST). My setup includes identifying key levels from higher timeframes, waiting for price to reach these levels, and entering on reversal candlestick patterns (pin bars, engulfing, inside bars). I use fixed stops at 20 pips and targets at 40 pips for consistent 2:1 risk-reward.`,
            
            breakout: `I trade breakout strategies on range-bound markets. I identify consolidation zones on 1-hour and 4-hour charts, mark key support and resistance levels, and wait for volume confirmation on the breakout. I enter on the first pullback after breakout with stops below/above the breakout level. My targets are measured moves (height of the range projected from breakout point). I focus on major forex pairs and trade during high liquidity sessions.`,
            
            trendFollowing: `I follow established trends using moving average crossovers (20/50 EMA) on daily charts. I only trade in the direction of the major trend and wait for pullbacks to key moving averages for entry. I use higher highs/higher lows for uptrends and lower highs/lower lows for downtrends to confirm trend continuation. Position sizing is 1% risk per trade with stops below recent swing lows/highs. I trail stops using the 20 EMA and target previous highs/lows.`,
            
            scalpingStrategy: `I scalp forex markets on 1-minute and 5-minute charts during high volatility sessions (London open and NY open). I use a combination of Bollinger Bands and RSI to identify overbought/oversold conditions at key levels. My entries are quick with tight 5-10 pip stops and targets of 10-15 pips for 1.5:1 to 2:1 RR. I limit myself to 10 trades per day maximum and stop trading after 3 consecutive losses. I primarily scalp EURUSD and GBPUSD due to tight spreads.`,
            
            swingTrading: `I swing trade forex using weekly and daily chart analysis. I identify major support and resistance zones, trend lines, and chart patterns (triangles, flags, head and shoulders). I enter on confirmations from daily chart and hold positions for several days to weeks. My risk management includes 2% risk per trade with stops at logical levels (below structure, not arbitrary pips). Targets are based on measured moves or next major resistance/support zone. I review positions once daily and avoid intraday noise.`
        };

        // Global State Management
        let appState = {
            downloadNotification: null,
            showExportMenu: false,
            trades: [],
            startingBalance: 10000,
            currentBalance: 10000,
            customRules: [],
            statistics: {},
            chartInstances: {},
            activeTradeIndex: null,
            activePasteTarget: 'entry', // 'entry' or 'exit'
            viewSettings: {
                showStats: {
                    totalTrades: true,
                    winningTrades: true,
                    losingTrades: true,
                    winRate: true,
                    rulesWinRate: true,
                    netPL: true,
                    totalFees: true,
                    profitFactor: true,
                    avgWin: true,
                    avgLoss: true,
                    largestWin: true,
                    largestLoss: true,
                    expectancy: true,
                    accountGrowth: true,
                    currentBalance: true,
                    startingBalance: true
                },
                showColumns: {
                    date: true,
                    time: true,
                    symbol: true,
                    direction: true,
                    entry: true,
                    exit: true,
                    pips: true,
                    pl: true,
                    setup: true
                },
                showCharts: {
                    equity: true,
                    dailyPL: true,
                    winLoss: true
                }
            },
            currentMonth: new Date().getMonth(),
            currentYear: new Date().getFullYear(),
            // Monthly analytics navigation state
            analyticsCurrentMonth: -1,  // -1 means "TOTAL (All Time)" view
            analyticsCurrentYear: new Date().getFullYear(),
            // Setup filter state
            selectedSetup: 'all',  // 'all' or specific setup type
            // Rule combinations navigation state
            ruleCombinationsCurrentMonth: -1,  // -1 means "TOTAL (All Time)" view
            ruleCombinationsCurrentYear: new Date().getFullYear(),
            // Performance breakdowns navigation state
            breakdownCurrentMonth: -1,  // -1 means "TOTAL (All Time)" view
            breakdownCurrentYear: new Date().getFullYear(),
            aiPromptInclusions: {
                overview: true,
                setupPerformance: true,
                marketCondition: true,
                emotionalState: true,
                ruleAdherence: true,
                monthlyPerformance: true,
                monthOverMonthAnalysis: true,
                dailyPerformance: true,
                openHourlyPerformance: true,
                closeHourlyPerformance: true,
                customRules: true,
                tradesOption: 'none',  // Changed from boolean to string with options
                screenshots: false  // Don't include screenshots in prompt
            },
            exportPromptFormat: 'readable',
            showPromptCopied: false,
            strategyContext: '',
            // Configuration state
            showStatsConfig: false,
            showChartsConfig: false,
            showColumnsConfig: false,
            chartZoom: 100,
            // UI Collapse States
            showTradeHistory: true,
            showAccountSettings: false,
            showRuleCombinations: false,
            showStatistics: true,
            showCharts: true,
            showRules: true,
            showBreakdowns: true,
            showTimeAnalytics: true,
            showCalendar: true,
            showMonteCarlo: true,
            showAI: true,
            visibleStats: {
                startingBalance: true,
                currentBalance: true,
                accountGrowth: true,
                totalTrades: true,
                winningTrades: true,
                losingTrades: true,
                winRate: true,
                rulesWinRate: true,
                profitFactor: true,
                netPL: true,
                avgWin: true,
                avgLoss: true,
                largestWin: true,
                largestLoss: true,
                expectancy: true,
                totalFees: true,
                // Phase 1 New Stats
                maxDrawdown: true,
                maxDrawdownPercent: true,
                recoveryFactor: true,
                currentStreak: true,
                longestWinStreak: true,
                longestLossStreak: true,
                riskRewardRatio: true,
                avgTradeDuration: true
            },
            visibleCharts: {
                equityCurve: true,
                dailyPL: true,
                winLoss: true
            },
            visibleColumns: {
                openDate: true,
                openTime: true,
                date: true,
                time: true,
                symbol: true,
                direction: true,
                entry: true,
                exit: true,
                pips: true,
                pl: true,
                setup: true
            }
        };

        // Setup type options
        const setupTypes = ['Breakout', 'Pullback', 'Reversal', 'Range', 'Trend Following'];
        const marketConditions = ['Trending', 'Ranging', 'Volatile'];
        const emotionalStates = ['Confident', 'Uncertain', 'Fearful', 'Greedy', 'Disciplined', 'Impulsive'];
        const ruleAdherence = ['Perfect', 'Custom', 'Partial', 'None'];

        // ============================================================================
        // DATA PERSISTENCE & AUTO-SAVE SYSTEM
        // ============================================================================

        const STORAGE_KEYS = {
            APP_STATE: 'tradingJournal_appState',
            LAST_SAVE: 'tradingJournal_lastSave',
            VERSION: 'tradingJournal_version',
            API_CONFIG: 'tradingJournal_apiConfig'
        };

        const APP_VERSION = '1.0.0';
        const AUTO_SAVE_INTERVAL = 30000; // 30 seconds
        const STORAGE_LIMIT_MB = 100; // 100MB storage limit for IndexedDB
        const DB_NAME = 'TradingJournalDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'journalData';

        let autoSaveTimer = null;
        let lastSaveTimestamp = null;
        let saveStatusUpdateTimer = null;
        let autoSaveEnabled = localStorage.getItem('tradingJournal_autoSaveEnabled') !== 'false'; // Enabled by default
        let db = null; // IndexedDB connection

        // ============================================================================
        // INDEXEDDB IMPLEMENTATION FOR LARGER STORAGE (100MB)
        // ============================================================================

        // Initialize IndexedDB
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('IndexedDB failed to open:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    db = request.result;
                    console.log('IndexedDB initialized successfully');
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    db = event.target.result;

                    // Create object store if it doesn't exist
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'key' });
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log('IndexedDB object store created');
                    }
                };
            });
        }

        // Save to IndexedDB
        async function saveToIndexedDB(key, data) {
            try {
                if (!db) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(STORE_NAME);

                    const record = {
                        key: key,
                        data: data,
                        timestamp: new Date().toISOString()
                    };

                    const request = objectStore.put(record);

                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB save error:', error);
                throw error;
            }
        }

        // Load from IndexedDB
        async function loadFromIndexedDB(key) {
            try {
                if (!db) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    const request = objectStore.get(key);

                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(request.result.data);
                        } else {
                            resolve(null);
                        }
                    };

                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB load error:', error);
                return null;
            }
        }

        // Get all keys from IndexedDB
        async function getAllKeysFromIndexedDB() {
            try {
                if (!db) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    const request = objectStore.getAllKeys();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB getAllKeys error:', error);
                return [];
            }
        }

        // Delete from IndexedDB
        async function deleteFromIndexedDB(key) {
            try {
                if (!db) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    const request = objectStore.delete(key);

                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            } catch (error) {
                console.error('IndexedDB delete error:', error);
                return false;
            }
        }

        // Get IndexedDB storage size estimate
        async function getIndexedDBSize() {
            try {
                if (navigator.storage && navigator.storage.estimate) {
                    const estimate = await navigator.storage.estimate();
                    return {
                        usage: estimate.usage || 0,
                        quota: estimate.quota || 0
                    };
                }
                return { usage: 0, quota: 0 };
            } catch (error) {
                console.error('Error getting storage estimate:', error);
                return { usage: 0, quota: 0 };
            }
        }

        // ============================================================================
        // END INDEXEDDB IMPLEMENTATION
        // ============================================================================

        // ============================================================================
        // API INTEGRATION FOR HISTORIC TRADES
        // ============================================================================

        // API Configuration
        const API_CONFIG = {
            ctrader: {
                name: 'cTrader Open API',
                type: 'websocket', // cTrader uses WebSocket + Protocol Buffers
                demoEndpoint: 'demo.ctraderapi.com:5035',
                liveEndpoint: 'live.ctraderapi.com:5035',
                rateLimit: 5, // 5 requests per second for historical data
                maxTimeRangeMs: 604800000, // 1 week max per request
                requiresWebSocket: true
            },
            metatrader: {
                name: 'MetaTrader (via MetaApi)',
                type: 'rest',
                endpoint: 'https://metastats-api-v1.new-york.agiliumtrade.ai',
                rateLimit: 10, // Configurable based on API plan
                requiresWebSocket: false
            }
        };

        // API credentials storage
        let apiCredentials = {
            ctrader: {
                enabled: false,
                clientId: '',
                clientSecret: '',
                accessToken: '',
                accountId: '',
                environment: 'demo' // 'demo' or 'live'
            },
            metatrader: {
                enabled: false,
                authToken: '',
                accountId: ''
            }
        };

        // Rate limiting for API calls
        const apiRateLimiter = {
            metatrader: {
                lastCallTime: 0,
                minInterval: 100 // 100ms between calls (10 calls per second)
            },
            ctrader: {
                lastCallTime: 0,
                minInterval: 200 // 200ms between calls (5 calls per second)
            }
        };

        // Rate limiter helper
        async function enforceRateLimit(platform) {
            const limiter = apiRateLimiter[platform];
            if (!limiter) return;

            const now = Date.now();
            const timeSinceLastCall = now - limiter.lastCallTime;

            if (timeSinceLastCall < limiter.minInterval) {
                const waitTime = limiter.minInterval - timeSinceLastCall;
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }

            limiter.lastCallTime = Date.now();
        }

        // Load API credentials from localStorage
        function loadAPICredentials() {
            try {
                const saved = localStorage.getItem(STORAGE_KEYS.API_CONFIG);
                if (saved) {
                    apiCredentials = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading API credentials:', error);
            }
        }

        // Save API credentials to localStorage
        function saveAPICredentials() {
            try {
                localStorage.setItem(STORAGE_KEYS.API_CONFIG, JSON.stringify(apiCredentials));
                showMessage('‚úÖ API credentials saved successfully');
            } catch (error) {
                console.error('Error saving API credentials:', error);
                showMessage('‚ùå Error saving API credentials', 'error');
            }
        }

        // Populate API credentials UI from loaded data
        function populateAPICredentialsUI() {
            try {
                // MetaTrader fields
                const mtEnabled = document.getElementById('mtEnabled');
                const mtAuthToken = document.getElementById('mtAuthToken');
                const mtAccountId = document.getElementById('mtAccountId');

                if (mtEnabled) mtEnabled.checked = apiCredentials.metatrader.enabled || false;
                if (mtAuthToken) mtAuthToken.value = apiCredentials.metatrader.authToken || '';
                if (mtAccountId) mtAccountId.value = apiCredentials.metatrader.accountId || '';
            } catch (error) {
                console.error('Error populating API credentials UI:', error);
            }
        }

        // Fetch historic trades from MetaTrader via MetaApi
        async function fetchMetaTraderTrades(startDate, endDate) {
            if (!apiCredentials.metatrader.enabled || !apiCredentials.metatrader.authToken) {
                throw new Error('MetaTrader API not configured. Please set up your API credentials.');
            }

            const { authToken, accountId } = apiCredentials.metatrader;

            if (!accountId) {
                throw new Error('MetaTrader Account ID is required. Please configure it in API Settings.');
            }

            const endpoint = `${API_CONFIG.metatrader.endpoint}/users/current/accounts/${accountId}/historical-trades/${startDate}/${endDate}`;

            try {
                // Enforce rate limiting
                await enforceRateLimit('metatrader');

                showMessage('üîÑ Fetching trades from MetaTrader API...');

                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'auth-token': authToken
                    }
                });

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.message || errorData.error || errorMessage;
                    } catch (e) {
                        // If response is not JSON, try text
                        try {
                            errorMessage = await response.text();
                        } catch (e2) {
                            // Use default error message
                        }
                    }
                    throw new Error(`MetaTrader API error (${response.status}): ${errorMessage}`);
                }

                const data = await response.json();
                console.log('Received trades from MetaTrader API:', data);
                return transformMetaTraderTrades(data);
            } catch (error) {
                console.error('MetaTrader API fetch error:', error);

                // Provide user-friendly error messages
                if (error.message.includes('Failed to fetch')) {
                    throw new Error('Network error: Unable to connect to MetaTrader API. Please check your internet connection.');
                } else if (error.message.includes('401')) {
                    throw new Error('Authentication failed: Invalid auth token. Please check your API credentials.');
                } else if (error.message.includes('404')) {
                    throw new Error('Account not found: Please verify your Account ID in API Settings.');
                } else {
                    throw error;
                }
            }
        }

        // Transform MetaTrader API response to app trade format
        function transformMetaTraderTrades(apiResponse) {
            if (!Array.isArray(apiResponse)) {
                console.warn('Unexpected MetaTrader API response format:', apiResponse);
                return [];
            }

            return apiResponse.map(trade => {
                // Parse opening and closing timestamps
                const openDate = new Date(trade.openTime);
                const closeDate = new Date(trade.closeTime);

                return {
                    id: trade.positionId || trade._id || `mt-${Date.now()}-${Math.random()}`,
                    symbol: trade.symbol || '',
                    direction: trade.type === 'DEAL_TYPE_BUY' || trade.type === 'buy' ? 'Buy' : 'Sell',
                    openDate: openDate.toISOString().split('T')[0],
                    openTime: openDate.toTimeString().split(' ')[0],
                    date: closeDate.toISOString().split('T')[0],
                    time: closeDate.toTimeString().split(' ')[0],
                    closeTime: trade.closeTime,
                    entryPrice: parseFloat(trade.openPrice) || 0,
                    exitPrice: parseFloat(trade.closePrice) || 0,
                    volume: parseFloat(trade.volume) || 0,
                    pips: parseFloat(trade.pips) || 0,
                    grossProfit: parseFloat(trade.profit) || 0,
                    netProfit: parseFloat(trade.profit) || 0,
                    netPL: parseFloat(trade.profit) || 0,
                    profit: parseFloat(trade.profit) || 0,
                    commission: parseFloat(trade.commission) || 0,
                    swap: parseFloat(trade.swap) || 0,
                    balance: parseFloat(trade.balance) || 0,
                    setupType: '',
                    marketCondition: '',
                    emotionalState: '',
                    ruleAdherence: '',
                    notes: '',
                    entryScreenshot: null,
                    exitScreenshot: null,
                    tradingViewEntry: '',
                    tradingViewExit: '',
                    rulesFollowed: []
                };
            }).filter(trade => validateTrade(trade));
        }

        // Note: cTrader WebSocket implementation requires additional libraries
        // For now, we provide the configuration structure
        async function fetchCTraderTrades(startDate, endDate) {
            showMessage('‚ö†Ô∏è cTrader API requires WebSocket connection. This feature requires additional setup.', 'error');
            throw new Error('cTrader WebSocket API not yet implemented. Please use CSV import or implement WebSocket client.');

            // TODO: Implement WebSocket connection with Protocol Buffers
            // Requirements:
            // 1. Establish WebSocket connection to cTrader API endpoint
            // 2. Authenticate using OAuth2 flow (clientId, clientSecret, accessToken)
            // 3. Send ProtoOADealListReq message with:
            //    - ctidTraderAccountId
            //    - fromTimestamp (milliseconds since epoch)
            //    - toTimestamp (milliseconds since epoch)
            //    - maxRows (optional)
            // 4. Receive ProtoOADealListRes response
            // 5. Transform deals to app trade format
            // 6. Handle rate limiting (5 requests/second for historical data)
        }

        // Import trades from API
        async function importFromAPI(platform, startDate, endDate, mode = 'append') {
            try {
                let trades = [];

                // Fetch trades based on platform
                if (platform === 'metatrader') {
                    trades = await fetchMetaTraderTrades(startDate, endDate);
                } else if (platform === 'ctrader') {
                    trades = await fetchCTraderTrades(startDate, endDate);
                } else {
                    throw new Error('Invalid platform selected');
                }

                if (trades.length === 0) {
                    showMessage('‚ÑπÔ∏è No trades found in the specified date range');
                    return;
                }

                // Import trades using existing logic
                if (mode === 'overwrite') {
                    appState.trades = trades;
                    showMessage(`‚úÖ Imported ${trades.length} trades from ${platform} API`);
                } else if (mode === 'append') {
                    // Append with duplicate detection
                    const existingFingerprints = new Set(appState.trades.map(t => getTradeFingerprint(t)));
                    const newTrades = trades.filter(t => !existingFingerprints.has(getTradeFingerprint(t)));
                    appState.trades = [...appState.trades, ...newTrades];
                    showMessage(`‚úÖ Added ${newTrades.length} new trades from ${platform} API (${trades.length - newTrades.length} duplicates skipped)`);
                } else {
                    throw new Error('Invalid import mode');
                }

                // Refresh the display
                displayTrades();
                updateStats();
                updateCharts();
                await saveToLocalStorage();

            } catch (error) {
                console.error('API import error:', error);
                showMessage(`‚ùå ${error.message}`, 'error');
            }
        }

        // Toggle API settings section
        function toggleAPISettings() {
            const section = document.getElementById('apiSettingsSection');
            const arrow = document.getElementById('apiSettingsArrow');
            const isHidden = section.style.display === 'none';

            section.style.display = isHidden ? 'block' : 'none';
            arrow.style.transform = isHidden ? 'rotate(90deg)' : 'rotate(0deg)';
        }

        // Toggle API import modal
        function toggleAPIImportModal() {
            const modal = document.getElementById('apiImportModal');
            modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
        }

        // Toggle features modal
        function toggleFeaturesModal() {
            const modal = document.getElementById('featuresModal');
            modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
        }

        // Handle API import form submission
        async function handleAPIImport() {
            const platform = document.getElementById('apiPlatform').value;
            const startDate = document.getElementById('apiStartDate').value;
            const endDate = document.getElementById('apiEndDate').value;
            const mode = document.getElementById('apiImportMode').value;

            if (!startDate || !endDate) {
                showMessage('‚ùå Please select both start and end dates', 'error');
                return;
            }

            // Validate date range
            const start = new Date(startDate);
            const end = new Date(endDate);
            if (start > end) {
                showMessage('‚ùå Start date must be before end date', 'error');
                return;
            }

            // Format dates for API (YYYY-MM-DD HH:MM:SS.SSS)
            const formattedStart = `${startDate} 00:00:00.000`;
            const formattedEnd = `${endDate} 23:59:59.999`;

            // Close modal and start import
            toggleAPIImportModal();
            await importFromAPI(platform, formattedStart, formattedEnd, mode);
        }

        // ============================================================================
        // END API INTEGRATION
        // ============================================================================

        // Save app state (using IndexedDB for larger capacity)
        async function saveToLocalStorage() {
            try {
                const dataToSave = {
                    version: APP_VERSION,
                    timestamp: new Date().toISOString(),
                    trades: appState.trades,
                    startingBalance: appState.startingBalance,
                    customRules: appState.customRules,
                    strategyContext: appState.strategyContext,
                    visibleStats: appState.visibleStats,
                    visibleCharts: appState.visibleCharts,
                    visibleColumns: appState.visibleColumns,
                    aiPromptInclusions: appState.aiPromptInclusions,
                    selectedSetup: appState.selectedSetup,
                    // Section collapse states
                    showTradeHistory: appState.showTradeHistory,
                    showAccountSettings: appState.showAccountSettings,
                    showRuleCombinations: appState.showRuleCombinations,
                    showStatistics: appState.showStatistics,
                    showCharts: appState.showCharts,
                    showRules: appState.showRules,
                    showBreakdowns: appState.showBreakdowns,
                    showTimeAnalytics: appState.showTimeAnalytics,
                    showCalendar: appState.showCalendar,
                    showMonteCarlo: appState.showMonteCarlo,
                    showAI: appState.showAI
                };

                const jsonString = JSON.stringify(dataToSave);

                // Check storage size (now 100MB limit with IndexedDB)
                const sizeInBytes = new Blob([jsonString]).size;
                const sizeInMB = (sizeInBytes / (1024 * 1024)).toFixed(2);

                if (sizeInBytes > STORAGE_LIMIT_MB * 1024 * 1024) { // 100MB warning
                    console.warn(`Data size (${sizeInMB}MB) exceeds ${STORAGE_LIMIT_MB}MB limit. Consider exporting and clearing old data.`);
                    showMessage(`‚ö†Ô∏è Data size (${sizeInMB}MB) is very large! Consider exporting and archiving old trades.`, 'error');
                }

                // Try IndexedDB first (supports larger data), fallback to localStorage
                try {
                    await saveToIndexedDB(STORAGE_KEYS.APP_STATE, dataToSave);
                    console.log(`Saved ${sizeInMB}MB to IndexedDB`);
                } catch (idbError) {
                    console.warn('IndexedDB save failed, falling back to localStorage:', idbError);
                    // Fallback to localStorage
                    localStorage.setItem(STORAGE_KEYS.APP_STATE, jsonString);
                }

                localStorage.setItem(STORAGE_KEYS.LAST_SAVE, new Date().toISOString());
                localStorage.setItem(STORAGE_KEYS.VERSION, APP_VERSION);

                lastSaveTimestamp = new Date();
                updateSaveStatusIndicator();
                updateStorageInfoButton();

                return true;
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    showMessage('‚ö†Ô∏è Storage limit exceeded! Export your data and clear old trades.', 'error');
                    console.error('Storage quota exceeded:', error);
                } else {
                    console.error('Error saving data:', error);
                    showMessage('Failed to save data: ' + error.message, 'error');
                }
                return false;
            }
        }

        // Load app state from storage (IndexedDB first, fallback to localStorage)
        async function loadFromLocalStorage() {
            try {
                // Try IndexedDB first
                let data = null;
                try {
                    data = await loadFromIndexedDB(STORAGE_KEYS.APP_STATE);
                    if (data) {
                        console.log('Loaded data from IndexedDB');
                    }
                } catch (idbError) {
                    console.warn('IndexedDB load failed, trying localStorage:', idbError);
                }

                // Fallback to localStorage if IndexedDB didn't work
                if (!data) {
                    const savedData = localStorage.getItem(STORAGE_KEYS.APP_STATE);
                    if (!savedData) {
                        console.log('No saved data found');
                        return false;
                    }
                    data = JSON.parse(savedData);
                    console.log('Loaded data from localStorage');
                }

                const lastSave = localStorage.getItem(STORAGE_KEYS.LAST_SAVE);

                // Version check
                if (data.version && data.version !== APP_VERSION) {
                    console.warn(`Data version mismatch: ${data.version} vs ${APP_VERSION}`);
                    // Could implement migration logic here if needed
                }

                // Restore data
                if (data.trades && Array.isArray(data.trades)) {
                    appState.trades = data.trades;
                }
                if (data.startingBalance !== undefined) {
                    appState.startingBalance = data.startingBalance;
                }
                if (data.customRules && Array.isArray(data.customRules)) {
                    appState.customRules = data.customRules;
                }
                if (data.strategyContext) {
                    appState.strategyContext = data.strategyContext;
                }
                if (data.visibleStats) {
                    Object.assign(appState.visibleStats, data.visibleStats);
                }
                if (data.visibleCharts) {
                    Object.assign(appState.visibleCharts, data.visibleCharts);
                }
                if (data.visibleColumns) {
                    Object.assign(appState.visibleColumns, data.visibleColumns);
                }
                if (data.aiPromptInclusions) {
                    Object.assign(appState.aiPromptInclusions, data.aiPromptInclusions);
                }
                if (data.selectedSetup !== undefined) {
                    appState.selectedSetup = data.selectedSetup;
                }
                // Restore section collapse states
                if (data.showTradeHistory !== undefined) {
                    appState.showTradeHistory = data.showTradeHistory;
                }
                if (data.showAccountSettings !== undefined) {
                    appState.showAccountSettings = data.showAccountSettings;
                }
                if (data.showRuleCombinations !== undefined) {
                    appState.showRuleCombinations = data.showRuleCombinations;
                }
                if (data.showStatistics !== undefined) {
                    appState.showStatistics = data.showStatistics;
                }
                if (data.showCharts !== undefined) {
                    appState.showCharts = data.showCharts;
                }
                if (data.showRules !== undefined) {
                    appState.showRules = data.showRules;
                }
                if (data.showBreakdowns !== undefined) {
                    appState.showBreakdowns = data.showBreakdowns;
                }
                if (data.showTimeAnalytics !== undefined) {
                    appState.showTimeAnalytics = data.showTimeAnalytics;
                }
                if (data.showCalendar !== undefined) {
                    appState.showCalendar = data.showCalendar;
                }
                if (data.showMonteCarlo !== undefined) {
                    appState.showMonteCarlo = data.showMonteCarlo;
                }
                if (data.showAI !== undefined) {
                    appState.showAI = data.showAI;
                }

                lastSaveTimestamp = lastSave ? new Date(lastSave) : new Date();

                const tradeCount = appState.trades.length;
                const timeAgo = getTimeAgo(lastSaveTimestamp);
                showMessage(`‚úÖ Loaded ${tradeCount} trade${tradeCount !== 1 ? 's' : ''} from last session (${timeAgo})`, 'success');

                updateStorageInfoButton();

                return true;
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                showMessage('Failed to load saved data: ' + error.message, 'error');
                return false;
            }
        }

        // Start auto-save timer
        function startAutoSave() {
            if (!autoSaveEnabled) {
                console.log('Auto-save is disabled');
                return;
            }

            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }

            autoSaveTimer = setInterval(() => {
                if (appState.trades.length > 0 && autoSaveEnabled) {
                    saveToLocalStorage();
                    console.log('Auto-save completed');
                }
            }, AUTO_SAVE_INTERVAL);

            console.log(`Auto-save started (every ${AUTO_SAVE_INTERVAL / 1000} seconds)`);
        }

        // Stop auto-save timer
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
                console.log('Auto-save stopped');
            }
        }

        // Toggle auto-save on/off
        function toggleAutoSave() {
            autoSaveEnabled = !autoSaveEnabled;
            localStorage.setItem('tradingJournal_autoSaveEnabled', autoSaveEnabled.toString());

            const toggle = document.getElementById('autoSaveToggle');
            if (toggle) {
                toggle.checked = autoSaveEnabled;
            }

            if (autoSaveEnabled) {
                startAutoSave();
                showMessage('‚úÖ Auto-save enabled (every 30 seconds)', 'success');
            } else {
                stopAutoSave();
                showMessage('‚ö†Ô∏è Auto-save disabled - remember to save manually!', 'info');
            }

            updateAutoSaveStatus();
        }

        // Update auto-save status indicator
        function updateAutoSaveStatus() {
            const statusText = document.getElementById('autoSaveStatus');
            if (statusText) {
                if (autoSaveEnabled) {
                    statusText.textContent = 'Auto-save: ON';
                    statusText.style.color = 'var(--color-success)';
                } else {
                    statusText.textContent = 'Auto-save: OFF';
                    statusText.style.color = 'var(--color-warning)';
                }
            }
        }

        // Update save status indicator
        function updateSaveStatusIndicator() {
            const indicator = document.getElementById('saveStatusIndicator');
            if (!indicator) return;

            if (!lastSaveTimestamp) {
                indicator.innerHTML = 'üíæ Not saved';
                indicator.style.color = 'var(--color-warning)';
                return;
            }

            const timeAgo = getTimeAgo(lastSaveTimestamp);
            indicator.innerHTML = `‚úÖ Saved ${timeAgo}`;
            indicator.style.color = 'var(--color-success)';
        }

        // Update storage info button with current usage
        function updateStorageInfoButton() {
            const button = document.getElementById('storageInfoButton');
            if (!button) return;

            try {
                const savedData = localStorage.getItem(STORAGE_KEYS.APP_STATE);
                if (!savedData) {
                    button.innerHTML = 'üìä Storage Info (0MB)';
                    return;
                }

                const totalSize = new Blob([savedData]).size;
                const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
                button.innerHTML = `üìä Storage Info (${totalSizeMB}MB)`;
            } catch (error) {
                console.error('Error updating storage info button:', error);
                button.innerHTML = 'üìä Storage Info';
            }
        }

        // Start periodic save status updates
        function startSaveStatusUpdates() {
            if (saveStatusUpdateTimer) {
                clearInterval(saveStatusUpdateTimer);
            }

            saveStatusUpdateTimer = setInterval(() => {
                updateSaveStatusIndicator();
                updateStorageInfoButton();
            }, 10000); // Update every 10 seconds
        }

        // Get human-readable time ago
        function getTimeAgo(timestamp) {
            const now = new Date();
            const diff = now - new Date(timestamp);
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days} day${days !== 1 ? 's' : ''} ago`;
            if (hours > 0) return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
            if (minutes > 0) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
            return 'just now';
        }

        // Clear all data
        function clearAllStoredData() {
            const confirmed = confirm(
                '‚ö†Ô∏è WARNING: This will delete ALL data!\n\n' +
                'This action cannot be undone. Are you absolutely sure?'
            );

            if (!confirmed) return false;

            try {
                // Remove all trading journal keys
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('tradingJournal_')) {
                        keysToRemove.push(key);
                    }
                }

                keysToRemove.forEach(key => localStorage.removeItem(key));

                showMessage(`‚úÖ Cleared all stored data (${keysToRemove.length} items)`, 'success');
                updateStorageInfoButton();
                return true;
            } catch (error) {
                console.error('Error clearing storage:', error);
                showMessage('Failed to clear storage: ' + error.message, 'error');
                return false;
            }
        }

        // Show storage information
        function showStorageInfo() {
            try {
                const savedData = localStorage.getItem(STORAGE_KEYS.APP_STATE);

                let totalSize = 0;
                let breakdown = [];

                // Calculate main app state size
                if (savedData) {
                    const appStateSize = new Blob([savedData]).size;
                    totalSize += appStateSize;
                    breakdown.push({
                        name: 'Current Data',
                        size: appStateSize,
                        percentage: 0  // Will calculate after total
                    });
                }

                // Calculate percentages
                breakdown.forEach(item => {
                    item.percentage = totalSize > 0 ? ((item.size / totalSize) * 100).toFixed(1) : 0;
                });

                const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
                const limitMB = STORAGE_LIMIT_MB; // 100MB limit with IndexedDB
                const usagePercent = ((totalSize / (limitMB * 1024 * 1024)) * 100).toFixed(1);

                let html = '<div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 500px; width: 90%; padding: 1.5rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-lg); box-shadow: var(--shadow-lg); z-index: 10000;">';
                html += '<h3 style="margin-top: 0;">üìä Storage Information</h3>';
                html += '<p style="color: var(--color-text-secondary); font-size: var(--font-size-xs); margin-bottom: 1rem;">Using IndexedDB for expanded storage capacity</p>';

                // Total usage
                html += '<div style="margin-bottom: 1.5rem;">';
                html += `<div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-semibold); margin-bottom: 0.5rem;">`;
                html += `Total: ${totalSizeMB} MB / ${limitMB} MB`;
                html += '</div>';

                // Progress bar
                const progressColor = usagePercent < 70 ? 'var(--color-success)' : usagePercent < 90 ? 'var(--color-warning)' : 'var(--color-error)';
                html += `<div style="width: 100%; height: 24px; background: var(--color-secondary); border-radius: var(--radius-full); overflow: hidden; position: relative;">`;
                html += `<div style="width: ${Math.min(usagePercent, 100)}%; height: 100%; background: ${progressColor}; transition: width 0.3s ease;"></div>`;
                html += `<span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: var(--font-size-xs); font-weight: var(--font-weight-semibold); color: var(--color-text);">${usagePercent}%</span>`;
                html += '</div>';
                html += '</div>';

                // Breakdown
                if (breakdown.length > 0) {
                    html += '<div style="margin-bottom: 1.5rem;">';
                    html += '<h4 style="font-size: var(--font-size-sm); margin-bottom: 0.75rem;">Storage Breakdown:</h4>';
                    breakdown.forEach(item => {
                        const sizeMB = (item.size / (1024 * 1024)).toFixed(2);
                        html += '<div style="display: flex; justify-content: space-between; padding: 0.5rem; background: var(--color-secondary); border-radius: var(--radius-sm); margin-bottom: 0.5rem;">';
                        html += `<span style="font-size: var(--font-size-sm);">${item.name}</span>`;
                        html += `<span style="font-size: var(--font-size-sm); color: var(--color-text-secondary);">${sizeMB} MB (${item.percentage}%)</span>`;
                        html += '</div>';
                    });
                    html += '</div>';
                }

                // Trade statistics
                html += '<div style="padding: 1rem; background: var(--color-bg-8); border-radius: var(--radius-base); margin-bottom: 1rem;">';
                html += `<div style="font-size: var(--font-size-sm);"><strong>Total Trades:</strong> ${appState.trades.length}</div>`;
                if (lastSaveTimestamp) {
                    html += `<div style="font-size: var(--font-size-sm); margin-top: 0.25rem;"><strong>Last Saved:</strong> ${getTimeAgo(lastSaveTimestamp)}</div>`;
                }
                html += '</div>';

                // Warnings/tips
                if (usagePercent > 80) {
                    html += '<div style="padding: 1rem; background: rgba(var(--color-error-rgb), 0.1); border: 1px solid var(--color-error); border-radius: var(--radius-base); margin-bottom: 1rem; font-size: var(--font-size-sm);">';
                    html += '<strong>‚ö†Ô∏è Storage Almost Full!</strong><br>';
                    html += 'Consider exporting your data and clearing old trades to free up space.';
                    html += '</div>';
                } else if (appState.trades.length > 500) {
                    html += '<div style="padding: 1rem; background: rgba(var(--color-warning-rgb), 0.1); border: 1px solid var(--color-warning); border-radius: var(--radius-base); margin-bottom: 1rem; font-size: var(--font-size-sm);">';
                    html += '<strong>üí° Tip:</strong> You have many trades. Consider exporting periodically to keep your data safe.';
                    html += '</div>';
                }

                html += '<div style="display: flex; gap: 0.5rem; justify-content: flex-end;">';
                html += '<button onclick="document.getElementById(\'storageInfoPanel\').remove();" class="btn btn--sm">Close</button>';
                html += '</div>';

                html += '</div>';

                // Add backdrop
                html = `<div onclick="document.getElementById('storageInfoPanel').remove();" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999;"></div>` + html;

                // Remove existing panel if any
                const existingPanel = document.getElementById('storageInfoPanel');
                if (existingPanel) existingPanel.remove();

                // Create and show panel
                const panel = document.createElement('div');
                panel.id = 'storageInfoPanel';
                panel.innerHTML = html;
                document.body.appendChild(panel);
            } catch (error) {
                console.error('Error showing storage info:', error);
                showMessage('Failed to load storage information', 'error');
            }
        }

        // Mark when user exports data (to track for reminders)
        function markExportTimestamp() {
            try {
                localStorage.setItem('tradingJournal_lastExport', new Date().toISOString());
            } catch (error) {
                console.error('Error marking export timestamp:', error);
            }
        }

        // ============================================================================
        // END DATA PERSISTENCE & AUTO-SAVE SYSTEM
        // ============================================================================

        // Initialize app
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize IndexedDB first
            try {
                await initIndexedDB();
                console.log('‚úÖ IndexedDB initialized (100MB capacity)');
            } catch (error) {
                console.warn('‚ö†Ô∏è IndexedDB initialization failed, using localStorage fallback:', error);
            }

            // Load saved data
            await loadFromLocalStorage();

            // Load API credentials
            loadAPICredentials();
            populateAPICredentialsUI();

            setupEventListeners();
            initializeDefaultRules();
            initializeUIStates();
            updateUI();

            // Set toggle switch initial state
            const toggle = document.getElementById('autoSaveToggle');
            if (toggle) {
                toggle.checked = autoSaveEnabled;
            }
            updateAutoSaveStatus();

            // Start auto-save and status updates
            startAutoSave();
            startSaveStatusUpdates();
            updateSaveStatusIndicator();
            updateStorageInfoButton();
        });
        
        function initializeUIStates() {
            // Initialize account settings collapse state
            updateAccountSettingsCollapseState();

            // Initialize trade history collapse state
            updateTradeHistoryCollapseState();

            // Initialize all section collapse states
            applySectionCollapseStates();

            // Initialize starting balance display
            updateStartingBalanceDisplay();

            // Sync import mode selector with radio buttons
            const importModeValue = document.getElementById('importMode').value;
            const radioButton = document.querySelector(`input[name="importModeRadio"][value="${importModeValue}"]`);
            if (radioButton) {
                radioButton.checked = true;
            }

            // Initialize setup filter dropdown
            const setupFilterSelect = document.getElementById('setupFilterSelect');
            if (setupFilterSelect) {
                setupFilterSelect.value = appState.selectedSetup || 'all';
            }
        }

        function setupEventListeners() {
            document.getElementById('csvInput').addEventListener('change', handleCSVImport);
            document.getElementById('jsonInput').addEventListener('change', handleJSONImport);
            
            // Click outside to close export menu and info tooltips
            document.addEventListener('click', function(e) {
                if (appState.showExportMenu && !e.target.closest('.export-menu-container')) {
                    setShowExportMenu(false);
                }

                // Close info tooltips if clicking outside
                if (!e.target.closest('.section-info-container')) {
                    closeAllInfoTooltips();
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeLightbox();
                }
            });
            
            // Paste event for screenshots
            document.addEventListener('paste', handlePaste);
        }

        function initializeDefaultRules() {
            // Only initialize if no rules exist (e.g., first-time user)
            if (!appState.customRules || appState.customRules.length === 0) {
                appState.customRules = [
                    { id: 1, text: 'Wait for confirmation candle', enabled: true },
                    { id: 2, text: 'Risk no more than 2% per trade', enabled: true },
                    { id: 3, text: 'Check higher timeframe trend', enabled: true }
                ];
            }
        }


        // Utility Functions
        function showMessage(message, type = 'success') {
            const messagesDiv = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.textContent = message;
            messagesDiv.innerHTML = '';
            messagesDiv.appendChild(messageEl);
            
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 5000);
        }

        function formatCurrency(amount) {
            return '$' + amount.toFixed(2);
        }

        function formatPercentage(value) {
            return value.toFixed(1) + '%';
        }

        function formatDuration(milliseconds) {
            if (milliseconds === 0) return '0m';

            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                const remainingHours = hours % 24;
                return remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days}d`;
            } else if (hours > 0) {
                const remainingMinutes = minutes % 60;
                return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
            } else if (minutes > 0) {
                return `${minutes}m`;
            } else {
                return `${seconds}s`;
            }
        }

        function updateUI() {
            const hasData = appState.trades.length > 0;
            
            // Show/hide sections
            document.getElementById('emptyState').style.display = hasData ? 'none' : 'block';
            // Account Settings section is always visible after import
            document.getElementById('statisticsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('chartsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('tradeHistorySection').style.display = hasData ? 'block' : 'none';
            document.getElementById('ruleCombinationsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('rulesSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('breakdownsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('timeAnalyticsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('calendarSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('monteCarloSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('aiSection').style.display = hasData ? 'block' : 'none';
            
            // Enable buttons
            document.getElementById('exportBtn').disabled = !hasData;
            document.getElementById('printBtn').disabled = !hasData;
            
            if (hasData) {
                calculateStatistics();
                updateStatisticsDisplay();
                updateChartsDisplay();
                updateTradesTable();
                updateCustomRulesDisplay();
                updatePerformanceBreakdowns();
                updateTimeAnalytics();
                updateCalendarView();
                updateRuleCombinationsMonthDisplay();
                updateRuleCombinationsAnalysis();

                // Initialize chart zoom selector
                document.getElementById('chartZoomSelect').value = appState.chartZoom;
                
                // Update collapse states
                updateTradeHistoryCollapseState();
                updateAccountSettingsCollapseState();
                updateStartingBalanceDisplay();
            }
        }

        // CSV Import Functions

        // Helper function to generate a unique fingerprint for a trade
        function getTradeFingerprint(trade) {
            // Create a unique identifier based on key trade properties
            return `${trade.symbol}_${trade.openDate}_${trade.openTime}_${trade.date}_${trade.time}_${trade.entryPrice}_${trade.exitPrice}_${trade.volume}`;
        }

        // Helper function to calculate similarity between existing and new trades
        function calculateTradeSimilarity(existingTrades, newTrades) {
            if (existingTrades.length === 0) {
                return 0; // No existing trades, 0% similarity
            }

            const existingFingerprints = new Set(existingTrades.map(t => getTradeFingerprint(t)));
            const matchingCount = newTrades.filter(t => existingFingerprints.has(getTradeFingerprint(t))).length;

            return (matchingCount / newTrades.length) * 100;
        }

        function handleCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Security: File size validation
            if (file.size > MAX_FILE_SIZE) {
                showMessage(`File too large. Maximum size: ${MAX_FILE_SIZE / (1024 * 1024)}MB`, 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.csv')) {
                showMessage('Please select a CSV file', 'error');
                return;
            }

            const mode = document.getElementById('importMode').value;
            const platform = document.getElementById('platform').value;
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;

                    // Route to appropriate parser based on platform
                    let result;
                    if (platform === 'mt4') {
                        result = parseMT4CSV(csvText);
                    } else if (platform === 'mt5') {
                        result = parseMT5CSV(csvText);
                    } else {
                        result = parseCSV(csvText); // cTrader
                    }
                    
                    if (result.trades.length === 0) {
                        showMessage('‚ùå Error: No valid trades found in CSV file', 'error');
                        return;
                    }

                    // Calculate similarity between existing and new trades
                    const similarity = calculateTradeSimilarity(appState.trades, result.trades);
                    console.log(`Trade similarity: ${similarity.toFixed(2)}%`);

                    // Intelligent merge: if 90% or more of data is the same, add only missing trades
                    if (appState.trades.length > 0 && similarity >= 90) {
                        // Smart merge: add only new trades that don't exist
                        const existingFingerprints = new Set(appState.trades.map(t => getTradeFingerprint(t)));
                        const newTrades = result.trades.filter(t => !existingFingerprints.has(getTradeFingerprint(t)));

                        if (newTrades.length > 0) {
                            appState.trades = [...appState.trades, ...newTrades];
                            if (result.skippedCount > 0) {
                                showMessage(`‚úÖ Smart merge: Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} existing, ${result.skippedCount} invalid symbols skipped)`);
                            } else {
                                showMessage(`‚úÖ Smart merge: Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} already exist)`);
                            }
                        } else {
                            showMessage(`‚ÑπÔ∏è No new trades to add - all ${result.trades.length} trades already exist`);
                        }
                    } else if (mode === 'overwrite') {
                        // Overwrite mode: replace all trades
                        appState.trades = result.trades;
                        appState.startingBalance = result.startingBalance || 10000;
                        // Update import mode to match the selected radio button
                        const checkedMode = document.querySelector('input[name="importModeRadio"]:checked');
                        if (checkedMode) {
                            document.getElementById('importMode').value = checkedMode.value;
                        }
                        if (result.skippedCount > 0) {
                            showMessage(`‚úÖ Imported ${result.trades.length} trades (${result.skippedCount} skipped - invalid symbols)`);
                        } else {
                            showMessage(`‚úÖ Imported ${result.trades.length} trades successfully`);
                        }
                    } else if (mode === 'append') {
                        // Append mode with duplicate detection
                        const existingFingerprints = new Set(appState.trades.map(t => getTradeFingerprint(t)));
                        const newTrades = result.trades.filter(t => !existingFingerprints.has(getTradeFingerprint(t)));
                        appState.trades = [...appState.trades, ...newTrades];
                        if (result.skippedCount > 0) {
                            showMessage(`‚úÖ Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} duplicates, ${result.skippedCount} invalid symbols skipped)`);
                        } else {
                            showMessage(`‚úÖ Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} duplicates skipped)`);
                        }
                    } else if (mode === 'update-open-datetime') {
                        // Update Open Date/Time mode: merge opening date/time without replacing other data
                        let updatedCount = 0;
                        let notFoundCount = 0;

                        // Create a map of existing trades using a fingerprint WITHOUT openDate/openTime
                        const existingTradesMap = new Map();
                        appState.trades.forEach(trade => {
                            const key = `${trade.symbol}_${trade.date}_${trade.time}_${trade.entryPrice}_${trade.exitPrice}_${trade.volume}`;
                            existingTradesMap.set(key, trade);
                        });

                        // Update matching trades with new openDate and openTime
                        result.trades.forEach(newTrade => {
                            const key = `${newTrade.symbol}_${newTrade.date}_${newTrade.time}_${newTrade.entryPrice}_${newTrade.exitPrice}_${newTrade.volume}`;
                            const existingTrade = existingTradesMap.get(key);

                            if (existingTrade) {
                                // Update only openDate and openTime fields
                                existingTrade.openDate = newTrade.openDate;
                                existingTrade.openTime = newTrade.openTime;
                                updatedCount++;
                            } else {
                                notFoundCount++;
                            }
                        });

                        if (updatedCount > 0) {
                            if (result.skippedCount > 0) {
                                showMessage(`‚úÖ Updated ${updatedCount} trades with opening date/time (${notFoundCount} not matched, ${result.skippedCount} invalid symbols skipped)`);
                            } else {
                                showMessage(`‚úÖ Updated ${updatedCount} trades with opening date/time (${notFoundCount} not matched)`);
                            }
                        } else {
                            showMessage(`‚ÑπÔ∏è No matching trades found to update. Processed ${result.trades.length} trades from CSV.`);
                        }
                    }

                    updateUI();

                    // Auto-expand trade history after successful import
                    if (result.trades.length > 0) {
                        appState.showTradeHistory = true;
                        updateTradeHistoryCollapseState();
                    }

                    // Save to localStorage after successful import
                    saveToLocalStorage();
                } catch (error) {
                    console.error('CSV parsing error:', error);
                    showMessage('‚ùå Error: ' + error.message, 'error');
                }
            };

            reader.readAsText(file);
        }
        
        // Download Notification Functions
        function showDownloadNotification(data) {
            const container = document.getElementById('downloadNotificationContainer');
            
            const notification = document.createElement('div');
            notification.className = 'download-notification';
            notification.innerHTML = `
                <div style="padding: var(--space-16);">
                    <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: var(--space-12);">
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8);">
                                <span style="font-size: var(--font-size-xl);">‚úÖ</span>
                                <span style="font-weight: var(--font-weight-bold); color: white;">Download Started!</span>
                            </div>
                            
                            <div style="font-size: var(--font-size-sm); color: rgba(255, 255, 255, 0.9); margin-bottom: var(--space-8);">
                                <div style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-4);">
                                    <span>üìÑ</span>
                                    <span style="font-family: var(--font-family-mono); font-size: var(--font-size-xs); word-break: break-all;">
                                        ${data.filename}
                                    </span>
                                </div>
                                <div style="display: flex; align-items: center; gap: var(--space-8);">
                                    <span>üïê</span>
                                    <span>${data.timestamp}</span>
                                </div>
                            </div>
                            
                            <div style="padding-top: var(--space-12); border-top: 1px solid rgba(255, 255, 255, 0.2); margin-bottom: var(--space-12);">
                                <div style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); color: white; margin-bottom: var(--space-8);">
                                    <strong>üìÇ Check your Downloads folder:</strong>
                                </div>
                                <div style="font-size: var(--font-size-xs); color: rgba(255, 255, 255, 0.9); line-height: 1.4;">
                                    ‚Ä¢ Look at bottom of browser window<br>
                                    ‚Ä¢ Open File Explorer ‚Üí Downloads<br>
                                    ‚Ä¢ Press Ctrl+J (Chrome) or Cmd+Shift+J (Mac)
                                </div>
                            </div>
                            
                            <button onclick="showDetailedInstructions()" style="background: white; color: #10b981; border: none; padding: var(--space-6) var(--space-12); border-radius: var(--radius-base); font-size: var(--font-size-sm); font-weight: var(--font-weight-medium); cursor: pointer; transition: all var(--duration-fast) var(--ease-standard);" onmouseover="this.style.background='#f0f9ff'" onmouseout="this.style.background='white'">
                                üìñ Detailed Instructions
                            </button>
                        </div>
                        
                        <button onclick="hideDownloadNotification()" style="background: none; border: none; color: white; font-size: var(--font-size-lg); cursor: pointer; margin-left: var(--space-8); padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                            ‚úï
                        </button>
                    </div>
                </div>
            `;
            
            container.appendChild(notification);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                hideDownloadNotification();
            }, 10000);
        }
        
        function hideDownloadNotification() {
            const container = document.getElementById('downloadNotificationContainer');
            const notification = container.querySelector('.download-notification');
            if (notification) {
                notification.style.animation = 'slide-down 0.3s ease-out';
                setTimeout(() => {
                    container.removeChild(notification);
                }, 300);
            }
        }
        
        function showDetailedInstructions() {
            alert(
                'üìÇ FINDING YOUR DOWNLOAD\n\n' +
                '1Ô∏è‚É£ BROWSER DOWNLOAD BAR\n' +
                '   Look at the BOTTOM of your browser window\n' +
                '   You should see the file downloading there\n\n' +
                '2Ô∏è‚É£ OPEN DOWNLOADS FOLDER\n' +
                '   Windows: Press Ctrl+J in Chrome/Edge\n' +
                '   Mac: Press Cmd+Shift+J or Cmd+Option+L\n' +
                '   Or manually open: File Explorer ‚Üí Downloads\n\n' +
                '3Ô∏è‚É£ FILE LOCATION\n' +
                '   Windows: C:\\Users\\YourName\\Downloads\n' +
                '   Mac: /Users/YourName/Downloads\n' +
                '   Linux: ~/Downloads\n\n' +
                '4Ô∏è‚É£ BROWSER SETTINGS\n' +
                '   Check browser settings if downloads aren\'t working:\n' +
                '   Settings ‚Üí Downloads ‚Üí Choose location\n\n' +
                '5Ô∏è‚É£ POP-UP BLOCKER\n' +
                '   Make sure pop-ups are allowed for this site'
            );
        }
        
        // Test Download Function
        function testDownload() {
            try {
                const testData = {
                    test: 'This is a test download',
                    timestamp: new Date().toISOString(),
                    message: 'If you can see this file, downloads are working correctly!'
                };
                const blob = new Blob([JSON.stringify(testData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'test-download.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show test download notification
                showDownloadNotification({
                    filename: 'test-download.json',
                    type: 'test',
                    timestamp: new Date().toLocaleTimeString()
                });
                
                alert(
                    '‚úÖ TEST DOWNLOAD STARTED\n\n' +
                    'Check your Downloads folder for:\n' +
                    'test-download.json\n\n' +
                    'If you see it, downloads are working!\n' +
                    'If not, check:\n' +
                    '1. Browser download settings\n' +
                    '2. Pop-up blocker settings\n' +
                    '3. Try a different browser'
                );
            } catch (error) {
                alert('‚ùå Download test failed: ' + error.message);
            }
        }
        
        // Download Help Functions
        function toggleDownloadHelp() {
            const helpSection = document.getElementById('downloadHelpSection');
            const isVisible = helpSection.style.display !== 'none';
            helpSection.style.display = isVisible ? 'none' : 'block';
        }

        function parseCSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim());
                
                // Find sections in cTrader format
                let dealsStartIndex = -1;
                let summaryStartIndex = -1;
                let balanceStartIndex = -1;
                let startingBalance = 10000;
                
                // Look for section headers (case insensitive)
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim().toLowerCase();
                    if (line === 'deals' || line.includes('deals')) {
                        dealsStartIndex = i;
                    } else if (line === 'summary' || line.includes('summary')) {
                        summaryStartIndex = i;
                    } else if (line === 'balance' || line.includes('balance')) {
                        balanceStartIndex = i;
                    }
                }
                
                // Extract starting balance from Summary section
                if (summaryStartIndex !== -1) {
                    // Look for deposit/starting balance in summary section
                    for (let i = summaryStartIndex + 1; i < Math.min(summaryStartIndex + 10, lines.length); i++) {
                        const line = lines[i].trim();
                        
                        // Skip empty lines
                        if (!line) continue;
                        
                        // Check if this is a header line containing 'Deposit'
                        if (line.toLowerCase().includes('deposit')) {
                            // Look for the corresponding data in next few lines
                            for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                                const dataLine = lines[j].trim();
                                if (!dataLine || dataLine.toLowerCase().includes('deposit')) continue;
                                
                                const parts = dataLine.split(',');
                                if (parts.length > 0) {
                                    // First column should be Deposit (starting balance)
                                    const depositStr = parts[0].trim();
                                    // Remove spaces and parse: "100 000.00" -> 100000.00
                                    const cleanDeposit = depositStr.replace(/\s+/g, '').replace(/[^\d.-]/g, '');
                                    const deposit = parseFloat(cleanDeposit);
                                    if (!isNaN(deposit) && deposit > 0) {
                                        startingBalance = deposit;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                        
                        // Alternative: look for any line with a large number (potential balance)
                        const possibleBalance = line.replace(/[^\d\s.-]/g, '').trim();
                        if (possibleBalance) {
                            const cleanBalance = possibleBalance.replace(/\s+/g, '');
                            const balance = parseFloat(cleanBalance);
                            if (!isNaN(balance) && balance > 1000) {
                                startingBalance = balance;
                                break;
                            }
                        }
                    }
                }
                
                // Parse trades from Deals section
                if (dealsStartIndex === -1) {
                    throw new Error('Invalid file format - Deals section not found. Please ensure this is a cTrader CSV export.');
                }
                
                let headerIndex = -1;
                let dataStartIndex = -1;
                
                // Find the header line in Deals section (more flexible matching)
                for (let i = dealsStartIndex + 1; i < Math.min(dealsStartIndex + 10, lines.length); i++) {
                    const line = lines[i].trim().toLowerCase();
                    // Check for key columns that indicate this is the header
                    if ((line.includes('symbol') || line.includes('instrument')) && 
                        (line.includes('direction') || line.includes('side')) && 
                        (line.includes('price') || line.includes('entry') || line.includes('open'))) {
                        headerIndex = i;
                        dataStartIndex = i + 1;
                        break;
                    }
                }
                
                if (headerIndex === -1) {
                    // Try alternative approach - look for any line with multiple columns
                    for (let i = dealsStartIndex + 1; i < Math.min(dealsStartIndex + 10, lines.length); i++) {
                        const line = lines[i].trim();
                        const parts = parseCSVLine(line);
                        if (parts.length >= 8) { // Minimum expected columns
                            headerIndex = i;
                            dataStartIndex = i + 1;
                            console.log('Using fallback header detection at line:', i);
                            break;
                        }
                    }
                }
                
                if (headerIndex === -1) {
                    throw new Error('Invalid file format - Could not find trade data header in Deals section');
                }
                
                const headerLine = lines[headerIndex];
                const headers = parseCSVLine(headerLine).map(h => h.trim().toLowerCase());
                
                // Map columns for cTrader format
                const columnMap = {
                    symbol: findColumnIndex(headers, ['symbol', 'instrument', 'pair']),
                    direction: findColumnIndex(headers, ['opening direction', 'direction', 'side', 'type']),
                    openingTime: findColumnIndex(headers, ['opening time (utc-4)', 'opening time', 'open time', 'entry time']),
                    closingTime: findColumnIndex(headers, ['closing time (utc-4)', 'closing time', 'close time', 'time', 'date']),
                    entryPrice: findColumnIndex(headers, ['entry price', 'open price', 'opening price', 'price']),
                    closingPrice: findColumnIndex(headers, ['closing price', 'close price', 'exit price']),
                    closingQuantity: findColumnIndex(headers, ['closing quantity', 'quantity', 'volume', 'size', 'lots']),
                    swap: findColumnIndex(headers, ['swap', 'rollover']),
                    commissions: findColumnIndex(headers, ['commissions', 'commission', 'fee']),
                    pips: findColumnIndex(headers, ['pips', 'points']),
                    grossUSD: findColumnIndex(headers, ['gross usd', 'gross p&l', 'gross pl', 'gross']),
                    netUSD: findColumnIndex(headers, ['net usd', 'net p&l', 'net pl', 'net', 'profit']),
                    balanceUSD: findColumnIndex(headers, ['balance usd', 'balance', 'running balance'])
                };
                
                console.log('Column mapping:', columnMap);
                console.log('Headers found:', headers);
                
                const trades = [];
                const skippedTrades = [];
                let tradeIndex = 1;
                
                // Parse trade data
                for (let i = dataStartIndex; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    // Stop if we hit another section or empty line starting with commas
                    if (!line || line === 'Summary' || line === 'Balance' || line.match(/^,+$/)) {
                        break;
                    }
                    
                    try {
                        const cells = parseCSVLine(line);
                        
                        // Skip if not enough columns or if symbol is empty
                        if (cells.length < 3) {
                            continue;
                        }
                        
                        // Check if we have a valid symbol
                        const symbolCell = columnMap.symbol >= 0 ? cells[columnMap.symbol] : cells[0];
                        if (!symbolCell || !symbolCell.trim() || symbolCell.trim().length < 2) {
                            continue;
                        }
                        
                        // SYMBOL FILTERING: Skip trades with numeric-only symbols
                        if (!isValidSymbol(symbolCell.trim())) {
                            skippedTrades.push({
                                symbol: symbolCell.trim(),
                                line: i + 1
                            });
                            console.log(`Filtered out trade with invalid symbol: "${symbolCell.trim()}" (numeric-only)`);
                            continue;
                        }
                        
                        // Parse opening time: "06 Oct 2025 04:29:33.732"
                        const openingTimeStr = columnMap.openingTime >= 0 ? cells[columnMap.openingTime] : '';
                        const openDateTime = parsecTraderDateTime(openingTimeStr);

                        // Parse closing time: "06 Oct 2025 04:29:33.732"
                        const closingTimeStr = columnMap.closingTime >= 0 ? cells[columnMap.closingTime] : '';
                        const { date, time } = parsecTraderDateTime(closingTimeStr);
                        
                        // Parse volume: "0.1 Lots" -> 0.1
                        const volumeStr = columnMap.closingQuantity >= 0 ? cells[columnMap.closingQuantity] : '1';
                        const volume = parseFloat(volumeStr.replace(/[^\d.-]/g, '')) || 1;
                        
                        // Parse balance: "100 003.84" -> 100003.84
                        const balanceStr = columnMap.balanceUSD >= 0 ? cells[columnMap.balanceUSD] : '0';
                        const balance = parseFloat(balanceStr.replace(/\s+/g, '').replace(/[^\d.-]/g, '')) || 0;
                        
                        // Parse other numeric fields with better error handling
                        const entryPrice = columnMap.entryPrice >= 0 ? parseFloat(cells[columnMap.entryPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const exitPrice = columnMap.closingPrice >= 0 ? parseFloat(cells[columnMap.closingPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const pips = columnMap.pips >= 0 ? parseFloat(cells[columnMap.pips].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const netProfit = columnMap.netUSD >= 0 ? parseFloat(cells[columnMap.netUSD].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const commission = columnMap.commissions >= 0 ? parseFloat(cells[columnMap.commissions].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const swap = columnMap.swap >= 0 ? parseFloat(cells[columnMap.swap].replace(/[^\d.-]/g, '')) || 0 : 0;
                        
                        const trade = {
                            id: `${Date.now()}_${tradeIndex}`,
                            symbol: symbolCell.trim(),
                            direction: columnMap.direction >= 0 ? cells[columnMap.direction] || 'Buy' : 'Buy',
                            openDate: openDateTime.date,
                            openTime: openDateTime.time,
                            date: date,
                            time: time,
                            closeTime: closingTimeStr, // Keep original for parsing
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            volume: volume,
                            pips: pips,
                            grossProfit: columnMap.grossUSD >= 0 ? parseFloat(cells[columnMap.grossUSD].replace(/[^\d.-]/g, '')) || 0 : 0,
                            netProfit: netProfit,
                            netPL: netProfit, // Primary field for calculations
                            profit: netProfit, // For compatibility
                            commission: commission,
                            swap: swap,
                            balance: balance,

                            // Additional fields for comprehensive journal
                            setupType: '',
                            marketCondition: '',
                            emotionalState: '',
                            ruleAdherence: '',
                            notes: '',
                            entryScreenshot: null,
                            exitScreenshot: null,
                            tradingViewEntry: '',
                            tradingViewExit: '',
                            rulesFollowed: []
                        };
                        
                        // Security: Validate trade data before adding
                        try {
                            validateTrade(trade);
                        } catch (validationError) {
                            console.warn(`Trade validation failed:`, validationError.message, trade);
                            continue;
                        }

                        trades.push(trade);
                        tradeIndex++;
                    } catch (error) {
                        console.warn(`Error parsing trade row ${i}:`, error, lines[i]);
                    }
                }
                
                if (trades.length === 0) {
                    if (skippedTrades.length > 0) {
                        throw new Error(`No valid trades found. ${skippedTrades.length} trades skipped due to invalid symbols (numeric-only): ${skippedTrades.slice(0, 3).map(t => t.symbol).join(', ')}${skippedTrades.length > 3 ? '...' : ''}`);
                    }
                    throw new Error('No valid trades found. Please check your CSV format.');
                }
                
                return { trades, startingBalance, skippedCount: skippedTrades.length };
            } catch (error) {
                console.error('CSV parsing failed:', error);
                throw new Error(`CSV parsing failed: ${error.message}`);
            }
        }

        // Parse MT4 CSV format
        function parseMT4CSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim());
                const trades = [];
                const skippedTrades = [];
                let tradeIndex = 1;

                // Find header line (usually first line or after some metadata)
                let headerIndex = -1;
                for (let i = 0; i < Math.min(lines.length, 10); i++) {
                    const line = lines[i].trim().toLowerCase();
                    if ((line.includes('order') || line.includes('ticket')) &&
                        (line.includes('time') || line.includes('open')) &&
                        line.includes('type') && line.includes('symbol')) {
                        headerIndex = i;
                        break;
                    }
                }

                if (headerIndex === -1) {
                    headerIndex = 0; // Assume first line is header
                }

                const headerLine = lines[headerIndex];
                const headers = parseCSVLine(headerLine).map(h => h.trim().toLowerCase());

                // Map columns for MT4 format
                const columnMap = {
                    order: findColumnIndex(headers, ['order', 'ticket', '#']),
                    openTime: findColumnIndex(headers, ['open time', 'time', 'open', 'date']),
                    type: findColumnIndex(headers, ['type', 'cmd', 'order type']),
                    size: findColumnIndex(headers, ['size', 'volume', 'lots', 'quantity']),
                    symbol: findColumnIndex(headers, ['symbol', 'item', 'instrument']),
                    openPrice: findColumnIndex(headers, ['price', 'open price', 'opening price']),
                    sl: findColumnIndex(headers, ['s/l', 'sl', 'stop loss', 'stoploss']),
                    tp: findColumnIndex(headers, ['t/p', 'tp', 'take profit', 'takeprofit']),
                    closeTime: findColumnIndex(headers, ['close time', 'closing time']),
                    closePrice: findColumnIndex(headers, ['close price', 'closing price', 'price']),
                    commission: findColumnIndex(headers, ['commission', 'commissions', 'fee']),
                    swap: findColumnIndex(headers, ['swap', 'rollover']),
                    profit: findColumnIndex(headers, ['profit', 'p/l', 'pl', 'net']),
                    balance: findColumnIndex(headers, ['balance'])
                };

                console.log('MT4 Column mapping:', columnMap);
                console.log('MT4 Headers found:', headers);

                // Parse trade data
                for (let i = headerIndex + 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    try {
                        const cells = parseCSVLine(line);
                        if (cells.length < 3) continue;

                        // Get basic trade info
                        const typeCell = columnMap.type >= 0 ? cells[columnMap.type].toLowerCase() : '';

                        // Skip balance adjustments and pending orders
                        if (typeCell.includes('balance') ||
                            typeCell.includes('credit') ||
                            typeCell.includes('deposit') ||
                            typeCell.includes('limit') ||
                            typeCell.includes('stop') && !typeCell.includes('buy') && !typeCell.includes('sell')) {
                            continue;
                        }

                        const symbolCell = columnMap.symbol >= 0 ? cells[columnMap.symbol] : '';
                        if (!symbolCell || !isValidSymbol(symbolCell.trim())) {
                            skippedTrades.push({ symbol: symbolCell, reason: 'Invalid symbol' });
                            continue;
                        }

                        // Parse times (MT4 format: YYYY.MM.DD HH:MM)
                        const openTimeStr = columnMap.openTime >= 0 ? cells[columnMap.openTime] : '';
                        const closeTimeStr = columnMap.closeTime >= 0 ? cells[columnMap.closeTime] : '';

                        const openDateTime = parseMT4DateTime(openTimeStr);
                        const closeDateTime = parseMT4DateTime(closeTimeStr);

                        // Parse direction
                        let direction = 'Buy';
                        if (typeCell.includes('sell')) {
                            direction = 'Sell';
                        } else if (typeCell.includes('buy')) {
                            direction = 'Buy';
                        }

                        // Parse numeric values
                        const volume = columnMap.size >= 0 ? parseFloat(cells[columnMap.size].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const entryPrice = columnMap.openPrice >= 0 ? parseFloat(cells[columnMap.openPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const exitPrice = columnMap.closePrice >= 0 ? parseFloat(cells[columnMap.closePrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const profit = columnMap.profit >= 0 ? parseFloat(cells[columnMap.profit].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const commission = columnMap.commission >= 0 ? parseFloat(cells[columnMap.commission].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const swap = columnMap.swap >= 0 ? parseFloat(cells[columnMap.swap].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const balance = columnMap.balance >= 0 ? parseFloat(cells[columnMap.balance].replace(/\s+/g, '').replace(/[^\d.-]/g, '')) || 0 : 0;

                        // Calculate pips (approximate)
                        const priceDiff = direction === 'Buy' ? exitPrice - entryPrice : entryPrice - exitPrice;
                        const symbol = symbolCell.trim();
                        const pipMultiplier = symbol.includes('JPY') ? 100 : 10000;
                        const pips = Math.round(priceDiff * pipMultiplier * 10) / 10;

                        const trade = {
                            id: `${Date.now()}_${tradeIndex++}`,
                            symbol: symbol,
                            direction: direction,
                            openDate: openDateTime.date,
                            openTime: openDateTime.time,
                            date: closeDateTime.date,
                            time: closeDateTime.time,
                            closeTime: closeTimeStr,
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            volume: volume,
                            pips: pips,
                            grossProfit: profit - commission - swap,
                            netProfit: profit,
                            netPL: profit,
                            profit: profit,
                            commission: commission,
                            swap: swap,
                            balance: balance,

                            // Journal fields
                            setupType: '',
                            marketCondition: '',
                            emotionalState: '',
                            ruleAdherence: '',
                            notes: '',
                            entryScreenshot: null,
                            exitScreenshot: null,
                            tradingViewEntry: '',
                            tradingViewExit: '',
                            rulesFollowed: []
                        };

                        if (validateTrade(trade)) {
                            trades.push(trade);
                        } else {
                            skippedTrades.push({ symbol: trade.symbol, reason: 'Validation failed' });
                        }
                    } catch (error) {
                        console.error('Error parsing MT4 trade line:', error, line);
                        continue;
                    }
                }

                return {
                    trades: trades,
                    skippedCount: skippedTrades.length,
                    startingBalance: 10000
                };
            } catch (error) {
                console.error('MT4 CSV parsing failed:', error);
                throw new Error(`MT4 CSV parsing failed: ${error.message}`);
            }
        }

        // Parse MT5 CSV format
        function parseMT5CSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim());
                const trades = [];
                const skippedTrades = [];
                let tradeIndex = 1;

                // Find header line
                let headerIndex = -1;
                for (let i = 0; i < Math.min(lines.length, 10); i++) {
                    const line = lines[i].trim().toLowerCase();
                    if ((line.includes('ticket') || line.includes('order')) &&
                        (line.includes('time') || line.includes('open')) &&
                        line.includes('type') && line.includes('symbol')) {
                        headerIndex = i;
                        break;
                    }
                }

                if (headerIndex === -1) {
                    headerIndex = 0; // Assume first line is header
                }

                const headerLine = lines[headerIndex];
                const headers = parseCSVLine(headerLine).map(h => h.trim().toLowerCase());

                // Map columns for MT5 format (similar to MT4 but may have different column names)
                const columnMap = {
                    ticket: findColumnIndex(headers, ['ticket', 'order', '#']),
                    openTime: findColumnIndex(headers, ['time', 'open time', 'entry time', 'date']),
                    type: findColumnIndex(headers, ['type', 'order type', 'action']),
                    volume: findColumnIndex(headers, ['volume', 'size', 'lots', 'quantity']),
                    symbol: findColumnIndex(headers, ['symbol', 'item', 'instrument']),
                    openPrice: findColumnIndex(headers, ['price', 'open price', 'entry price']),
                    sl: findColumnIndex(headers, ['s/l', 'sl', 'stop loss']),
                    tp: findColumnIndex(headers, ['t/p', 'tp', 'take profit']),
                    closeTime: findColumnIndex(headers, ['close time', 'closing time', 'exit time']),
                    closePrice: findColumnIndex(headers, ['close price', 'exit price', 'closing price']),
                    commission: findColumnIndex(headers, ['commission', 'fee']),
                    swap: findColumnIndex(headers, ['swap', 'rollover']),
                    profit: findColumnIndex(headers, ['profit', 'p/l', 'pl', 'net']),
                    balance: findColumnIndex(headers, ['balance'])
                };

                console.log('MT5 Column mapping:', columnMap);
                console.log('MT5 Headers found:', headers);

                // Parse trade data
                for (let i = headerIndex + 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    try {
                        const cells = parseCSVLine(line);
                        if (cells.length < 3) continue;

                        // Get basic trade info
                        const typeCell = columnMap.type >= 0 ? cells[columnMap.type].toLowerCase() : '';

                        // Skip balance adjustments and pending orders
                        if (typeCell.includes('balance') ||
                            typeCell.includes('credit') ||
                            typeCell.includes('deposit') ||
                            typeCell.includes('limit') ||
                            typeCell.includes('stop') && !typeCell.includes('buy') && !typeCell.includes('sell')) {
                            continue;
                        }

                        const symbolCell = columnMap.symbol >= 0 ? cells[columnMap.symbol] : '';
                        if (!symbolCell || !isValidSymbol(symbolCell.trim())) {
                            skippedTrades.push({ symbol: symbolCell, reason: 'Invalid symbol' });
                            continue;
                        }

                        // Parse times (MT5 format similar to MT4: YYYY.MM.DD HH:MM)
                        const openTimeStr = columnMap.openTime >= 0 ? cells[columnMap.openTime] : '';
                        const closeTimeStr = columnMap.closeTime >= 0 ? cells[columnMap.closeTime] : '';

                        const openDateTime = parseMT4DateTime(openTimeStr); // MT5 uses similar format
                        const closeDateTime = parseMT4DateTime(closeTimeStr);

                        // Parse direction
                        let direction = 'Buy';
                        if (typeCell.includes('sell')) {
                            direction = 'Sell';
                        } else if (typeCell.includes('buy')) {
                            direction = 'Buy';
                        }

                        // Parse numeric values
                        const volume = columnMap.volume >= 0 ? parseFloat(cells[columnMap.volume].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const entryPrice = columnMap.openPrice >= 0 ? parseFloat(cells[columnMap.openPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const exitPrice = columnMap.closePrice >= 0 ? parseFloat(cells[columnMap.closePrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const profit = columnMap.profit >= 0 ? parseFloat(cells[columnMap.profit].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const commission = columnMap.commission >= 0 ? parseFloat(cells[columnMap.commission].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const swap = columnMap.swap >= 0 ? parseFloat(cells[columnMap.swap].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const balance = columnMap.balance >= 0 ? parseFloat(cells[columnMap.balance].replace(/\s+/g, '').replace(/[^\d.-]/g, '')) || 0 : 0;

                        // Calculate pips (approximate)
                        const priceDiff = direction === 'Buy' ? exitPrice - entryPrice : entryPrice - exitPrice;
                        const symbol = symbolCell.trim();
                        const pipMultiplier = symbol.includes('JPY') ? 100 : 10000;
                        const pips = Math.round(priceDiff * pipMultiplier * 10) / 10;

                        const trade = {
                            id: `${Date.now()}_${tradeIndex++}`,
                            symbol: symbol,
                            direction: direction,
                            openDate: openDateTime.date,
                            openTime: openDateTime.time,
                            date: closeDateTime.date,
                            time: closeDateTime.time,
                            closeTime: closeTimeStr,
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            volume: volume,
                            pips: pips,
                            grossProfit: profit - commission - swap,
                            netProfit: profit,
                            netPL: profit,
                            profit: profit,
                            commission: commission,
                            swap: swap,
                            balance: balance,

                            // Journal fields
                            setupType: '',
                            marketCondition: '',
                            emotionalState: '',
                            ruleAdherence: '',
                            notes: '',
                            entryScreenshot: null,
                            exitScreenshot: null,
                            tradingViewEntry: '',
                            tradingViewExit: '',
                            rulesFollowed: []
                        };

                        if (validateTrade(trade)) {
                            trades.push(trade);
                        } else {
                            skippedTrades.push({ symbol: trade.symbol, reason: 'Validation failed' });
                        }
                    } catch (error) {
                        console.error('Error parsing MT5 trade line:', error, line);
                        continue;
                    }
                }

                return {
                    trades: trades,
                    skippedCount: skippedTrades.length,
                    startingBalance: 10000
                };
            } catch (error) {
                console.error('MT5 CSV parsing failed:', error);
                throw new Error(`MT5 CSV parsing failed: ${error.message}`);
            }
        }

        // Parse MT4/MT5 DateTime format (YYYY.MM.DD HH:MM or YYYY.MM.DD HH:MM:SS)
        function parseMT4DateTime(dateTimeStr) {
            if (!dateTimeStr || !dateTimeStr.trim()) {
                const now = new Date();
                const yyyy = now.getFullYear();
                const mm = (now.getMonth() + 1).toString().padStart(2, '0');
                const dd = now.getDate().toString().padStart(2, '0');
                return {
                    date: `${yyyy}-${mm}-${dd}`,
                    time: '12:00'
                };
            }

            try {
                // Match pattern: "YYYY.MM.DD HH:MM:SS" or "YYYY.MM.DD HH:MM"
                const match = dateTimeStr.match(/(\d{4})\.(\d{2})\.(\d{2})\s+(\d{1,2}):(\d{2})/);
                if (match) {
                    const [, year, month, day, hour, minute] = match;
                    return {
                        date: `${year}-${month}-${day}`,
                        time: `${hour.padStart(2, '0')}:${minute}`
                    };
                }
            } catch (error) {
                console.error('Error parsing MT4/MT5 date:', error, dateTimeStr);
            }

            // Fallback
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = (now.getMonth() + 1).toString().padStart(2, '0');
            const dd = now.getDate().toString().padStart(2, '0');
            return {
                date: `${yyyy}-${mm}-${dd}`,
                time: '12:00'
            };
        }

        function parsecTraderDateTime(dateTimeStr) {
            // Parse cTrader format: "06 Oct 2025 04:29:33.732"
            if (!dateTimeStr || !dateTimeStr.trim()) {
                const now = new Date();
                // FIX: Format date parts directly
                const yyyy = now.getFullYear();
                const mm = (now.getMonth() + 1).toString().padStart(2, '0');
                const dd = now.getDate().toString().padStart(2, '0');
                return {
                    date: `${yyyy}-${mm}-${dd}`,
                    time: '12:00'
                };
            }
            
            try {
                // Match pattern: "DD Mon YYYY HH:MM:SS.mmm"
                const match = dateTimeStr.match(/(\d{1,2})\s+(\w{3})\s+(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/);                
                if (match) {
                    const [, day, monthName, year, hour, minute] = match;
                    
                    // Convert month name to number
                    const months = {
                        'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5,
                        'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
                    };
                    
                    const monthNum = months[monthName.toLowerCase()];
                    if (monthNum !== undefined) {
                        // FIX: Format date parts directly to avoid timezone shift from toISOString()
                        const yyyy = parseInt(year);
                        const mm = (monthNum + 1).toString().padStart(2, '0');
                        const dd = parseInt(day).toString().padStart(2, '0');
                        
                        return {
                            date: `${yyyy}-${mm}-${dd}`, // e.g., "2025-10-06"
                            time: `${hour.padStart(2, '0')}:${minute}`
                        };
                    }
                }
                
                // Fallback: try to parse as standard date
                const date = new Date(dateTimeStr);
                if (!isNaN(date.getTime())) {
                    // FIX: Get local date parts, not UTC from toISOString()
                    const yyyy = date.getFullYear();
                    const mm = (date.getMonth() + 1).toString().padStart(2, '0');
                    const dd = date.getDate().toString().padStart(2, '0');

                    return {
                        date: `${yyyy}-${mm}-${dd}`,
                        time: date.toTimeString().substring(0, 5)
                    };
                }
            } catch (error) {
                console.warn('Date parsing error:', error, dateTimeStr);
            }
            
            // Final fallback
            const now = new Date();
            // FIX: Format date parts directly
            const yyyy = now.getFullYear();
            const mm = (now.getMonth() + 1).toString().padStart(2, '0');
            const dd = now.getDate().toString().padStart(2, '0');
            return {
                date: `${yyyy}-${mm}-${dd}`,
                time: '12:00'
            };
        }

        function findColumnIndex(headers, possibleNames) {
            for (const name of possibleNames) {
                const index = headers.findIndex(h => h.includes(name));
                if (index !== -1) return index;
            }
            return -1;
        }

        function parseCSVLine(line) {
            const cells = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    cells.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            cells.push(current.trim());
            return cells.map(cell => cell.replace(/^"|"$/g, ''));
        }

        // Trade Management Functions
        function toggleTradeDetails(tradeIndex) {
            const detailsRow = document.querySelector(`#details_${tradeIndex}`).parentElement.parentElement;
            const isVisible = detailsRow.style.display !== 'none';

            if (isVisible) {
                detailsRow.style.display = 'none';
                appState.activeTradeIndex = null;
            } else {
                detailsRow.style.display = 'table-row';
                renderTradeDetails(tradeIndex);
                appState.activeTradeIndex = tradeIndex;
            }
        }
        
        function renderTradeDetails(tradeIndex) {
            const trade = appState.trades[tradeIndex];
            const container = document.getElementById(`details_${tradeIndex}`);

            // Log for debugging
            console.log('renderTradeDetails - Rendering:', {
                tradeIndex,
                tradeId: trade.id,
                rulesFollowed: trade.rulesFollowed
            });

            container.innerHTML = `
                <div class="form-grid">
                    <div class="form-group">
                        <label>Setup Type</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'setupType', this.value)">
                            <option value="">Select setup...</option>
                            ${setupTypes.map(type => `<option value="${type}" ${trade.setupType === type ? 'selected' : ''}>${type}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Market Condition</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'marketCondition', this.value)">
                            <option value="">Select condition...</option>
                            ${marketConditions.map(condition => `<option value="${condition}" ${trade.marketCondition === condition ? 'selected' : ''}>${condition}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Emotional State</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'emotionalState', this.value)">
                            <option value="">Select state...</option>
                            ${emotionalStates.map(state => `<option value="${state}" ${trade.emotionalState === state ? 'selected' : ''}>${state}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Rule Adherence</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'ruleAdherence', this.value)">
                            <option value="">Select...</option>
                            <option value="Perfect" ${trade.ruleAdherence === 'Perfect' ? 'selected' : ''}>Perfect</option>
                            <option value="Custom" ${trade.ruleAdherence === 'Custom' ? 'selected' : ''}>Custom</option>
                            <option value="Partial" ${trade.ruleAdherence === 'Partial' ? 'selected' : ''}>Partial</option>
                            <option value="None" ${trade.ruleAdherence === 'None' ? 'selected' : ''}>None</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Trading Notes</label>
                    <textarea class="form-control" rows="3" placeholder="Add your trading notes..." onchange="updateTradeField(${tradeIndex}, 'notes', this.value)">${trade.notes || ''}</textarea>
                </div>

                <!-- Enhanced TradingView Links Section -->
                <div class="form-grid">
                    <div class="form-group">
                        <label>TradingView Entry Link</label>
                        <div style="display: flex; gap: var(--space-8); align-items: center;">
                            <input type="url" class="form-control" style="flex: 1;" placeholder="https://tradingview.com/x/ABC123/" value="${trade.tradingViewEntry || ''}" onchange="updateTradeField(${tradeIndex}, 'tradingViewEntry', this.value)" id="tvEntry_${tradeIndex}">
                            <button class="btn btn-tradingview" onclick="openTradingViewLink(${tradeIndex}, 'entry')" ${!trade.tradingViewEntry ? 'disabled' : ''} title="Open TradingView Entry Link">
                                üîó Open
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>TradingView Exit Link</label>
                        <div style="display: flex; gap: var(--space-8); align-items: center;">
                            <input type="url" class="form-control" style="flex: 1;" placeholder="https://tradingview.com/x/ABC123/" value="${trade.tradingViewExit || ''}" onchange="updateTradeField(${tradeIndex}, 'tradingViewExit', this.value)" id="tvExit_${tradeIndex}">
                            <button class="btn btn-tradingview" onclick="openTradingViewLink(${tradeIndex}, 'exit')" ${!trade.tradingViewExit ? 'disabled' : ''} title="Open TradingView Exit Link">
                                üîó Open
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Enhanced Screenshots Section -->
                <div class="form-grid">
                    <div class="form-group" onclick="appState.activePasteTarget = 'entry'">
                        <label>Entry Screenshot</label>
                        <div style="display: flex; gap: var(--space-8); margin-bottom: var(--space-8);">
                            <button class="btn btn-screenshot" onclick="appState.activePasteTarget = 'entry'; document.getElementById('entryScreenshot_${tradeIndex}').click()" style="flex: 1;">
                                üì∑ Upload Entry Screenshot
                            </button>
                            ${trade.entryScreenshot ? `<button class="btn btn-secondary" class="btn btn-clear" onclick="clearScreenshot(${tradeIndex}, 'entry')" title="Remove Screenshot">üóëÔ∏è</button>` : ''}
                        </div>
                        <input type="file" id="entryScreenshot_${tradeIndex}" class="form-control" accept="image/*" onchange="handleScreenshotUpload(${tradeIndex}, 'entry', this)" style="display: none;">
                        <small style="color: var(--color-text-secondary);">Or paste with Ctrl+V (active target: entry)</small>
                        ${trade.entryScreenshot && typeof trade.entryScreenshot === 'string' ? `
                            <div class="screenshot-container" style="margin-top: var(--space-8);">
                                <img src="${getScreenshotSrc(trade.entryScreenshot)}" class="screenshot" onclick="openLightbox('${getScreenshotSrc(trade.entryScreenshot)}')" onerror="console.error('Failed to load entry screenshot'); this.style.display='none';" style="max-width: 200px; max-height: 150px; cursor: pointer; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">Click to view full size</div>
                            </div>
                        ` : ''}
                    </div>

                    <div class="form-group" onclick="appState.activePasteTarget = 'exit'">
                        <label>Exit Screenshot</label>
                        <div style="display: flex; gap: var(--space-8); margin-bottom: var(--space-8);">
                            <button class="btn btn-screenshot" onclick="appState.activePasteTarget = 'exit'; document.getElementById('exitScreenshot_${tradeIndex}').click()" style="flex: 1;">
                                üì∑ Upload Exit Screenshot
                            </button>
                            ${trade.exitScreenshot ? `<button class="btn btn-secondary" class="btn btn-clear" onclick="clearScreenshot(${tradeIndex}, 'exit')" title="Remove Screenshot">üóëÔ∏è</button>` : ''}
                        </div>
                        <input type="file" id="exitScreenshot_${tradeIndex}" class="form-control" accept="image/*" onchange="handleScreenshotUpload(${tradeIndex}, 'exit', this)" style="display: none;">
                        <small style="color: var(--color-text-secondary);">Or paste with Ctrl+V (active target: exit)</small>
                        ${trade.exitScreenshot && typeof trade.exitScreenshot === 'string' ? `
                            <div class="screenshot-container" style="margin-top: var(--space-8);">
                                <img src="${getScreenshotSrc(trade.exitScreenshot)}" class="screenshot" onclick="openLightbox('${getScreenshotSrc(trade.exitScreenshot)}')" onerror="console.error('Failed to load exit screenshot'); this.style.display='none';" style="max-width: 200px; max-height: 150px; cursor: pointer; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">Click to view full size</div>
                            </div>
                        ` : ''}
                    </div>
                </div>

                <div class="form-group">
                    <label>Custom Rules Followed</label>
                    <div id="rulesChecklist_${tradeIndex}">
                        ${generateRulesChecklist(tradeIndex, trade.rulesFollowed || [])}
                    </div>
                </div>

                <div style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="printTrade(${tradeIndex})">üñ®Ô∏è Print This Trade</button>
                </div>
            `;
        }

        function calculateStatistics() {
            if (appState.trades.length === 0) {
                appState.statistics = {};
                return;
            }

            // Apply setup filter if selected
            let trades = appState.trades;
            if (appState.selectedSetup !== 'all') {
                trades = trades.filter(t => t.setupType === appState.selectedSetup);
            }
            // CORRECTED: Use netPL consistently for calculations
            const wins = trades.filter(t => (t.netPL || t.profit) > 0);
            const losses = trades.filter(t => (t.netPL || t.profit) < 0);
            const totalProfit = wins.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalLoss = Math.abs(losses.reduce((sum, t) => sum + (t.netPL || t.profit), 0));
            const netPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalFees = trades.reduce((sum, t) => sum + t.commission + t.swap, 0);

            // Rule adherence statistics
            const tradesWithRules = trades.filter(t => t.rulesFollowed && t.rulesFollowed.length > 0);
            const rulesWins = tradesWithRules.filter(t => (t.netPL || t.profit) > 0);
            const rulesWinRate = tradesWithRules.length > 0 ? (rulesWins.length / tradesWithRules.length * 100) : 0;

            const currentBalance = appState.startingBalance + netPL;
            const accountGrowth = ((currentBalance - appState.startingBalance) / appState.startingBalance * 100);
            const expectancy = trades.length > 0 ? netPL / trades.length : 0;

            // PHASE 1 STATS: Calculate Max Drawdown and Recovery Factor
            // Sort trades chronologically for equity curve calculation
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateA - dateB;
            });

            // Build equity curve and calculate max drawdown
            let runningBalance = appState.startingBalance;
            let peak = appState.startingBalance;
            let maxDrawdown = 0;
            let maxDrawdownPercent = 0;

            sortedTrades.forEach(trade => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                runningBalance += tradePL;

                // Update peak if we've reached a new high
                if (runningBalance > peak) {
                    peak = runningBalance;
                }

                // Calculate current drawdown
                const drawdown = peak - runningBalance;
                const drawdownPercent = peak > 0 ? (drawdown / peak * 100) : 0;

                // Update max drawdown
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                    maxDrawdownPercent = drawdownPercent;
                }
            });

            // Recovery Factor = Net P/L / Max Drawdown
            const recoveryFactor = maxDrawdown > 0 ? (netPL / maxDrawdown) : 0;

            // PHASE 1 STATS: Calculate Consecutive Win/Loss Streaks
            let currentStreak = 0;
            let longestWinStreak = 0;
            let longestLossStreak = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;

            sortedTrades.forEach((trade, index) => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                const isWin = tradePL > 0;

                if (isWin) {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > longestWinStreak) {
                        longestWinStreak = currentWinStreak;
                    }
                } else if (tradePL < 0) {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > longestLossStreak) {
                        longestLossStreak = currentLossStreak;
                    }
                } else {
                    // Break-even trade resets both streaks
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }

                // Current streak is determined by the last trade
                if (index === sortedTrades.length - 1) {
                    currentStreak = isWin ? currentWinStreak : (tradePL < 0 ? -currentLossStreak : 0);
                }
            });

            // PHASE 1 STATS: Risk-Reward Ratio
            const avgWin = wins.length > 0 ? (totalProfit / wins.length) : 0;
            const avgLoss = losses.length > 0 ? (totalLoss / losses.length) : 0;
            const riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;

            // PHASE 1 STATS: Average Trade Duration
            let totalDuration = 0;
            let tradesWithDuration = 0;

            trades.forEach(trade => {
                // Check if we have both open and close times
                if (trade.openDate && trade.date) {
                    const openDateTime = new Date(`${trade.openDate}T${trade.openTime || '00:00:00'}`);
                    const closeDateTime = new Date(`${trade.date}T${trade.time || '00:00:00'}`);

                    if (!isNaN(openDateTime.getTime()) && !isNaN(closeDateTime.getTime())) {
                        const durationMs = closeDateTime - openDateTime;
                        if (durationMs >= 0) {
                            totalDuration += durationMs;
                            tradesWithDuration++;
                        }
                    }
                }
            });

            const avgTradeDuration = tradesWithDuration > 0 ? (totalDuration / tradesWithDuration) : 0;

            appState.statistics = {
                totalTrades: trades.length,
                winningTrades: wins.length,
                losingTrades: losses.length,
                winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                rulesWinRate: rulesWinRate,
                netPL: netPL,
                totalFees: Math.abs(totalFees),
                totalProfit: totalProfit,
                totalLoss: totalLoss,
                profitFactor: totalLoss > 0 ? (totalProfit / totalLoss) : 0,
                avgWin: avgWin,
                avgLoss: avgLoss,
                largestWin: wins.length > 0 ? Math.max(...wins.map(t => t.profit)) : 0,
                largestLoss: losses.length > 0 ? Math.min(...losses.map(t => t.profit)) : 0,
                expectancy: expectancy,
                accountGrowth: accountGrowth,
                currentBalance: currentBalance,
                startingBalance: appState.startingBalance,
                // Phase 1 New Stats
                maxDrawdown: maxDrawdown,
                maxDrawdownPercent: maxDrawdownPercent,
                recoveryFactor: recoveryFactor,
                currentStreak: currentStreak,
                longestWinStreak: longestWinStreak,
                longestLossStreak: longestLossStreak,
                riskRewardRatio: riskRewardRatio,
                avgTradeDuration: avgTradeDuration
            };

            appState.currentBalance = currentBalance;

            // Update Monte Carlo baseline data if section is visible
            if (appState.showMonteCarlo) {
                displayMonteCarloBaselineData();
            }
        }

        // Calculate statistics for a specific month
        function calculateStatisticsForMonth(year, month) {
            // Filter trades for the selected month
            const selectedMonthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
            let monthTrades = appState.trades.filter(trade => {
                const tradeDate = new Date(trade.date);
                const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                return tradeMonthKey === selectedMonthKey;
            });

            // Apply setup filter if selected
            if (appState.selectedSetup !== 'all') {
                monthTrades = monthTrades.filter(t => t.setupType === appState.selectedSetup);
            }

            if (monthTrades.length === 0) {
                return {
                    totalTrades: 0,
                    winningTrades: 0,
                    losingTrades: 0,
                    winRate: 0,
                    rulesWinRate: 0,
                    netPL: 0,
                    totalFees: 0,
                    totalProfit: 0,
                    totalLoss: 0,
                    profitFactor: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    largestWin: 0,
                    largestLoss: 0,
                    expectancy: 0,
                    accountGrowth: 0,
                    currentBalance: appState.startingBalance,
                    startingBalance: appState.startingBalance,
                    maxDrawdown: 0,
                    maxDrawdownPercent: 0,
                    recoveryFactor: 0,
                    currentStreak: 0,
                    longestWinStreak: 0,
                    longestLossStreak: 0,
                    riskRewardRatio: 0,
                    avgTradeDuration: 0
                };
            }

            // Use same calculation logic as calculateStatistics but with filtered trades
            const trades = monthTrades;
            const wins = trades.filter(t => (t.netPL || t.profit) > 0);
            const losses = trades.filter(t => (t.netPL || t.profit) < 0);
            const totalProfit = wins.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalLoss = Math.abs(losses.reduce((sum, t) => sum + (t.netPL || t.profit), 0));
            const netPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalFees = trades.reduce((sum, t) => sum + t.commission + t.swap, 0);

            // Rule adherence statistics
            const tradesWithRules = trades.filter(t => t.rulesFollowed && t.rulesFollowed.length > 0);
            const rulesWins = tradesWithRules.filter(t => (t.netPL || t.profit) > 0);
            const rulesWinRate = tradesWithRules.length > 0 ? (rulesWins.length / tradesWithRules.length * 100) : 0;

            const currentBalance = appState.startingBalance + netPL;
            const accountGrowth = ((currentBalance - appState.startingBalance) / appState.startingBalance * 100);
            const expectancy = trades.length > 0 ? netPL / trades.length : 0;

            // Calculate Max Drawdown and Recovery Factor
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateA - dateB;
            });

            let runningBalance = appState.startingBalance;
            let peak = appState.startingBalance;
            let maxDrawdown = 0;
            let maxDrawdownPercent = 0;

            sortedTrades.forEach(trade => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                runningBalance += tradePL;

                if (runningBalance > peak) {
                    peak = runningBalance;
                }

                const drawdown = peak - runningBalance;
                const drawdownPercent = peak > 0 ? (drawdown / peak * 100) : 0;

                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                    maxDrawdownPercent = drawdownPercent;
                }
            });

            const recoveryFactor = maxDrawdown > 0 ? (netPL / maxDrawdown) : 0;

            // Calculate Consecutive Win/Loss Streaks
            let currentStreak = 0;
            let longestWinStreak = 0;
            let longestLossStreak = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;

            sortedTrades.forEach((trade, index) => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                const isWin = tradePL > 0;

                if (isWin) {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > longestWinStreak) {
                        longestWinStreak = currentWinStreak;
                    }
                } else if (tradePL < 0) {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > longestLossStreak) {
                        longestLossStreak = currentLossStreak;
                    }
                } else {
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }

                if (index === sortedTrades.length - 1) {
                    currentStreak = isWin ? currentWinStreak : (tradePL < 0 ? -currentLossStreak : 0);
                }
            });

            // Risk-Reward Ratio
            const avgWin = wins.length > 0 ? (totalProfit / wins.length) : 0;
            const avgLoss = losses.length > 0 ? (totalLoss / losses.length) : 0;
            const riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;

            // Average Trade Duration
            let totalDuration = 0;
            let tradesWithDuration = 0;

            trades.forEach(trade => {
                if (trade.openDate && trade.date) {
                    const openDateTime = new Date(`${trade.openDate}T${trade.openTime || '00:00:00'}`);
                    const closeDateTime = new Date(`${trade.date}T${trade.time || '00:00:00'}`);

                    if (!isNaN(openDateTime.getTime()) && !isNaN(closeDateTime.getTime())) {
                        const durationMs = closeDateTime - openDateTime;
                        if (durationMs >= 0) {
                            totalDuration += durationMs;
                            tradesWithDuration++;
                        }
                    }
                }
            });

            const avgTradeDuration = tradesWithDuration > 0 ? (totalDuration / tradesWithDuration) : 0;

            return {
                totalTrades: trades.length,
                winningTrades: wins.length,
                losingTrades: losses.length,
                winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                rulesWinRate: rulesWinRate,
                netPL: netPL,
                totalFees: Math.abs(totalFees),
                totalProfit: totalProfit,
                totalLoss: totalLoss,
                profitFactor: totalLoss > 0 ? (totalProfit / totalLoss) : 0,
                avgWin: avgWin,
                avgLoss: avgLoss,
                largestWin: wins.length > 0 ? Math.max(...wins.map(t => t.profit)) : 0,
                largestLoss: losses.length > 0 ? Math.min(...losses.map(t => t.profit)) : 0,
                expectancy: expectancy,
                accountGrowth: accountGrowth,
                currentBalance: currentBalance,
                startingBalance: appState.startingBalance,
                maxDrawdown: maxDrawdown,
                maxDrawdownPercent: maxDrawdownPercent,
                recoveryFactor: recoveryFactor,
                currentStreak: currentStreak,
                longestWinStreak: longestWinStreak,
                longestLossStreak: longestLossStreak,
                riskRewardRatio: riskRewardRatio,
                avgTradeDuration: avgTradeDuration
            };
        }

        function updateStatisticsDisplay() {
            if (appState.trades.length === 0) return;

            const statsGrid = document.getElementById('statsGrid');
            const statsConfig = appState.visibleStats;

            // Get stats based on selected view: TOTAL (-1) or specific month
            const stats = appState.analyticsCurrentMonth === -1
                ? appState.statistics
                : calculateStatisticsForMonth(appState.analyticsCurrentYear, appState.analyticsCurrentMonth);

            // Helper function to format a stat value
            const formatStatValue = (value, format) => {
                switch (format) {
                    case 'currency': return formatCurrency(value);
                    case 'percentage': return formatPercentage(value);
                    case 'decimal': return value.toFixed(2);
                    case 'duration': return formatDuration(value);
                    case 'streak':
                        return value === 0 ? '0' : (value > 0 ? `+${value}` : value.toString());
                    default: return value.toString();
                }
            };

            // Helper function to get class for a stat
            const getStatClass = (key, value, format) => {
                if (format === 'streak') {
                    return value > 0 ? 'positive' : (value < 0 ? 'negative' : '');
                }
                switch (key) {
                    case 'winningTrades':
                    case 'avgWin':
                    case 'largestWin':
                    case 'longestWinStreak':
                        return 'positive';
                    case 'losingTrades':
                    case 'avgLoss':
                    case 'largestLoss':
                    case 'totalFees':
                    case 'maxDrawdown':
                    case 'maxDrawdownPercent':
                    case 'longestLossStreak':
                        return 'negative';
                    case 'netPL':
                    case 'expectancy':
                    case 'accountGrowth':
                        return value >= 0 ? 'positive' : 'negative';
                    case 'recoveryFactor':
                    case 'riskRewardRatio':
                        return value >= 1 ? 'positive' : 'negative';
                    default:
                        return '';
                }
            };

            const statsDefinitions = [
                { key: 'totalTrades', label: 'Total Trades', format: 'number' },
                { key: 'winningTrades', label: 'Winning Trades', format: 'number' },
                { key: 'losingTrades', label: 'Losing Trades', format: 'number' },
                { key: 'winRate', label: 'Win Rate', format: 'percentage' },
                { key: 'rulesWinRate', label: 'Rules Win Rate', format: 'percentage' },
                { key: 'netPL', label: 'Net P&L', format: 'currency' },
                { key: 'totalFees', label: 'Total Fees', format: 'currency' },
                { key: 'profitFactor', label: 'Profit Factor', format: 'decimal' },
                { key: 'avgWin', label: 'Average Win', format: 'currency' },
                { key: 'avgLoss', label: 'Average Loss', format: 'currency' },
                { key: 'largestWin', label: 'Largest Win', format: 'currency' },
                { key: 'largestLoss', label: 'Largest Loss', format: 'currency' },
                { key: 'expectancy', label: 'Expectancy', format: 'currency' },
                { key: 'accountGrowth', label: 'Account Growth', format: 'percentage' },
                { key: 'currentBalance', label: 'Current Balance', format: 'currency' },
                { key: 'startingBalance', label: 'Starting Balance', format: 'currency' },
                { key: 'maxDrawdown', label: 'Max Drawdown', format: 'currency' },
                { key: 'maxDrawdownPercent', label: 'Max Drawdown %', format: 'percentage' },
                { key: 'recoveryFactor', label: 'Recovery Factor', format: 'decimal' },
                { key: 'currentStreak', label: 'Current Streak', format: 'streak' },
                { key: 'longestWinStreak', label: 'Longest Win Streak', format: 'number' },
                { key: 'longestLossStreak', label: 'Longest Loss Streak', format: 'number' },
                { key: 'riskRewardRatio', label: 'Risk/Reward Ratio', format: 'decimal' },
                { key: 'avgTradeDuration', label: 'Avg Trade Duration', format: 'duration' }
            ];

            let html = '';

            // Generate cards for each visible stat showing only one value
            statsDefinitions.filter(stat => statsConfig[stat.key]).forEach(stat => {
                const value = stats[stat.key];

                // Adjust values that need absolute formatting
                const displayValue = (stat.key === 'avgLoss' || stat.key === 'largestLoss') ? Math.abs(value) : value;

                const formattedValue = formatStatValue(displayValue, stat.format);
                const valueClass = getStatClass(stat.key, displayValue, stat.format);

                html += `
                    <div class="stat-card">
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value ${valueClass}">${formattedValue}</div>
                    </div>
                `;
            });

            statsGrid.innerHTML = html;
        }

        function updateChartsDisplay() {
            if (appState.trades.length === 0) return;
            
            // Clear existing charts
            Object.values(appState.chartInstances).forEach(chart => {
                if (chart) chart.destroy();
            });
            
            // Show/hide chart containers based on settings
            document.getElementById('equityContainer').style.display = appState.visibleCharts.equityCurve ? 'block' : 'none';
            document.getElementById('dailyPLContainer').style.display = appState.visibleCharts.dailyPL ? 'block' : 'none';
            document.getElementById('winLossContainer').style.display = appState.visibleCharts.winLoss ? 'block' : 'none';
            
            if (appState.visibleCharts.equityCurve) drawEquityCurve();
            if (appState.visibleCharts.dailyPL) drawDailyPLChart();
            if (appState.visibleCharts.winLoss) drawWinLossChart();
        }

        function drawEquityCurve() {
            const ctx = document.getElementById('equityChart').getContext('2d');
            const trades = [...appState.trades]; // Create copy to avoid mutation
            
            // CORRECTED: Sort trades by date/time for proper equity curve
            trades.sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateA - dateB;
            });
            
            // CORRECTED: Calculate cumulative balance properly using netPL
            let cumulative = 0;
            const cumulativeData = [];
            
            // Add starting point at trade 0
            cumulativeData.push({ x: 0, y: appState.startingBalance });
            
            trades.forEach((trade, index) => {
                // Use netPL consistently for P/L calculations
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                cumulative += tradePL;
                const balance = appState.startingBalance + cumulative;
                cumulativeData.push({
                    x: index + 1, // Trade number 1, 2, 3, ...
                    y: parseFloat(balance.toFixed(2)) // Cumulative balance
                });
            });
            
            appState.chartInstances.equity = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Account Balance',
                        data: cumulativeData,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 1,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#f8fafc'
                            }
                        },
                        tooltip: {
                            backgroundColor: '#1e293b',
                            borderColor: '#475569',
                            titleColor: '#e2e8f0',
                            bodyColor: '#60a5fa',
                            callbacks: {
                                title: function(context) {
                                    return context[0].parsed.x === 0 ? 'Starting Balance' : `Trade ${context[0].parsed.x}`;
                                },
                                label: function(context) {
                                    return 'Account Balance: $' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Trade Number',
                                color: '#94a3b8'
                            },
                            ticks: {
                                color: '#94a3b8',
                                stepSize: 1,
                                callback: function(value) {
                                    return Number.isInteger(value) ? value : '';
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.2)',
                                drawOnChartArea: true
                            },
                            min: 0
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Account Balance ($)',
                                color: '#94a3b8'
                            },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.2)',
                                drawOnChartArea: true
                            }
                        }
                    }
                }
            });
        }

        function drawDailyPLChart() {
            const ctx = document.getElementById('dailyPLChart').getContext('2d');
            const trades = appState.trades;
            
            // Group trades by date using correct P/L field
            const dailyPL = {};
            trades.forEach(trade => {
                if (!dailyPL[trade.date]) {
                    dailyPL[trade.date] = 0;
                }
                dailyPL[trade.date] += (trade.netPL || trade.profit);
            });
            
            const dates = Object.keys(dailyPL).sort();
            const values = dates.map(date => dailyPL[date]);
            
            appState.chartInstances.dailyPL = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Daily P&L',
                        data: values,
                        backgroundColor: values.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderColor: values.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#f8fafc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Profit/Loss ($)',
                                color: '#94a3b8'
                            },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            }
                        }
                    }
                }
            });
        }

        function drawWinLossChart() {
            const ctx = document.getElementById('winLossChart').getContext('2d');
            const stats = appState.statistics;
            
            appState.chartInstances.winLoss = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: ['Wins', 'Losses'],
                    datasets: [{
                        data: [stats.winningTrades, stats.losingTrades],
                        backgroundColor: ['#10b981', '#ef4444'],
                        borderColor: ['#059669', '#dc2626'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#f8fafc',
                                padding: 20
                            }
                        }
                    }
                }
            });
        }

        function updateTradesTable() {
            // Save the currently open trade details index
            const activeIndex = appState.activeTradeIndex;

            updateTableHeader();
            updateTableBody();

            // Restore the open trade details if there was one
            if (activeIndex !== null && activeIndex < appState.trades.length) {
                const detailsRow = document.querySelector(`#details_${activeIndex}`).parentElement.parentElement;
                detailsRow.style.display = 'table-row';
                renderTradeDetails(activeIndex);
            }

            // Update collapse state display after table updates
            if (appState.trades && appState.trades.length > 0) {
                updateTradeHistoryCollapseState();
            }
        }
        
        function updateTableHeader() {
            const header = document.getElementById('tableHeader');
            const columns = appState.visibleColumns;

            let html = '';
            if (columns.openDate) html += '<th>Open Date</th>';
            if (columns.openTime) html += '<th>Open Time</th>';
            if (columns.date) html += '<th>Close Date</th>';
            if (columns.time) html += '<th>Close Time</th>';
            if (columns.symbol) html += '<th>Symbol</th>';
            if (columns.direction) html += '<th>Direction</th>';
            if (columns.entry) html += '<th>Entry</th>';
            if (columns.exit) html += '<th>Exit</th>';
            if (columns.pips) html += '<th>Pips</th>';
            if (columns.pl) html += '<th>P&L</th>';
            if (columns.setup) html += '<th>Setup</th>';
            html += '<th>Actions</th>';

            header.innerHTML = html;
        }
        
        function updateTableBody() {
            const tbody = document.getElementById('tradesTableBody');
            tbody.innerHTML = '';

            appState.trades.forEach((trade, index) => {
                const row = tbody.insertRow();
                row.className = 'trade-row';

                const columns = appState.visibleColumns;
                let html = '';

                if (columns.openDate) html += `<td>${trade.openDate || '-'}</td>`;
                if (columns.openTime) html += `<td>${trade.openTime || '-'}</td>`;
                if (columns.date) html += `<td>${trade.date}</td>`;
                if (columns.time) html += `<td>${trade.time}</td>`;
                if (columns.symbol) html += `<td>${trade.symbol}</td>`;
                if (columns.direction) html += `<td>${trade.direction}</td>`;
                if (columns.entry) html += `<td>${trade.entryPrice.toFixed(5)}</td>`;
                if (columns.exit) html += `<td>${trade.exitPrice.toFixed(5)}</td>`;
                if (columns.pips) html += `<td class="${trade.pips >= 0 ? 'positive' : 'negative'}">${trade.pips.toFixed(1)}</td>`;
                if (columns.pl) html += `<td class="${(trade.netPL || trade.profit) >= 0 ? 'positive' : 'negative'}">$${(trade.netPL || trade.profit).toFixed(2)}</td>`;
                if (columns.setup) html += `<td>${trade.setupType || '-'}</td>`;

                html += `<td><button class="btn btn-secondary" onclick="toggleTradeDetails(${index})">Details</button></td>`;

                row.innerHTML = html;

                // Add expandable details row
                const detailRow = tbody.insertRow();
                detailRow.style.display = 'none';
                detailRow.innerHTML = `
                    <td colspan="${Object.values(columns).filter(Boolean).length + 1}">
                        <div class="trade-details" id="details_${index}"></div>
                    </td>
                `;
            });
        }

        // Export Menu Functions
        function toggleExportMenu() {
            setShowExportMenu(!appState.showExportMenu);
            if (appState.showExportMenu) {
                updateSizeEstimates();
            }
        }

        function setShowExportMenu(show) {
            appState.showExportMenu = show;
            const dropdown = document.getElementById('exportDropdown');
            dropdown.style.display = show ? 'block' : 'none';
        }

        // Info Tooltip Functions
        function toggleInfoTooltip(event, tooltipElement) {
            event.stopPropagation();

            // Close all other tooltips first
            document.querySelectorAll('.section-info-tooltip.show').forEach(tooltip => {
                if (tooltip !== tooltipElement) {
                    tooltip.classList.remove('show');
                }
            });

            // Toggle the current tooltip
            const isShowing = tooltipElement.classList.contains('show');
            tooltipElement.classList.toggle('show');

            // Position the tooltip near the icon
            if (!isShowing) {
                const icon = event.currentTarget;
                const rect = icon.getBoundingClientRect();

                // Position below the icon
                tooltipElement.style.top = (rect.bottom + 8) + 'px';
                tooltipElement.style.left = (rect.left - 130) + 'px'; // Center it roughly
            }
        }

        function closeAllInfoTooltips() {
            document.querySelectorAll('.section-info-tooltip.show').forEach(tooltip => {
                tooltip.classList.remove('show');
            });
        }
        
        function handleExportData(exportType = 'full') {
            if (appState.trades.length === 0) {
                showMessage('No data to export', 'error');
                return;
            }
            
            const timestamp = new Date().toISOString().split('T')[0];
            let exportData = {};
            let filename = '';
            
            switch(exportType) {
                case 'full':
                    // Complete export with everything
                    exportData = {
                        trades: appState.trades,
                        screenshots: getScreenshotsObject(),
                        startingBalance: appState.startingBalance,
                        finalBalance: appState.currentBalance,
                        customRules: appState.customRules,
                        strategyContext: appState.strategyContext,
                        visibleStats: appState.visibleStats,
                        statsOrder: appState.statsOrder,
                        visibleCharts: appState.visibleCharts,
                        chartOrder: appState.chartOrder,
                        visibleColumns: appState.visibleColumns,
                        visiblePerformanceSections: appState.visiblePerformanceSections,
                        visibleTimeStats: appState.visibleTimeStats,
                        chartZoom: appState.chartZoom,
                        showCalendar: appState.showCalendar,
                        importMode: document.getElementById('importMode').value,
                        uiPreferences: {
                            showTradeHistory: appState.showTradeHistory,
                            showAccountSettings: appState.showAccountSettings
                        },
                        appVersion: '1.7',
                        exportDate: new Date().toISOString(),
                        exportType: 'full'
                    };
                    filename = `trading-journal-full-${timestamp}.json`;
                    break;
                
                case 'trades-only':
                    // Just trades, no settings or screenshots
                    exportData = {
                        trades: appState.trades.map(trade => ({
                            ...trade,
                            entryScreenshot: null,
                            exitScreenshot: null
                        })),
                        startingBalance: appState.startingBalance,
                        finalBalance: appState.currentBalance,
                        appVersion: '1.7',
                        exportDate: new Date().toISOString(),
                        exportType: 'trades-only'
                    };
                    filename = `trading-journal-trades-${timestamp}.json`;
                    break;
                
                case 'no-screenshots':
                    // Everything except screenshots (much smaller file)
                    exportData = {
                        trades: appState.trades.map(trade => ({
                            ...trade,
                            entryScreenshot: null,
                            exitScreenshot: null
                        })),
                        startingBalance: appState.startingBalance,
                        finalBalance: appState.currentBalance,
                        customRules: appState.customRules,
                        strategyContext: appState.strategyContext,
                        visibleStats: appState.visibleStats,
                        statsOrder: appState.statsOrder,
                        visibleCharts: appState.visibleCharts,
                        chartOrder: appState.chartOrder,
                        visibleColumns: appState.visibleColumns,
                        visiblePerformanceSections: appState.visiblePerformanceSections,
                        visibleTimeStats: appState.visibleTimeStats,
                        chartZoom: appState.chartZoom,
                        showCalendar: appState.showCalendar,
                        importMode: document.getElementById('importMode').value,
                        uiPreferences: {
                            showTradeHistory: appState.showTradeHistory,
                            showAccountSettings: appState.showAccountSettings
                        },
                        appVersion: '1.7',
                        exportDate: new Date().toISOString(),
                        exportType: 'no-screenshots',
                        note: 'Screenshots excluded to reduce file size'
                    };
                    filename = `trading-journal-no-screenshots-${timestamp}.json`;
                    break;
                
                case 'screenshots-only':
                    // Export only screenshots data
                    const screenshotTrades = appState.trades.filter(t => t.entryScreenshot || t.exitScreenshot);
                    const screenshotCount = screenshotTrades.length;
                    
                    if (screenshotCount === 0) {
                        showMessage('‚ö†Ô∏è No screenshots to export', 'error');
                        return;
                    }
                    
                    const screenshots = getScreenshotsObject();
                    exportData = {
                        screenshots: screenshots,
                        tradeIds: Object.keys(screenshots),
                        screenshotCount: screenshotCount,
                        exportDate: new Date().toISOString(),
                        exportType: 'screenshots-only',
                        appVersion: '1.8',
                        note: 'Import this file to restore screenshots. Trade data not included.'
                    };
                    
                    // Calculate approximate size
                    const dataSize = JSON.stringify(screenshots).length;
                    const sizeMB = (dataSize / (1024 * 1024)).toFixed(2);
                    
                    filename = `trading-journal-screenshots-${timestamp}.json`;
                    
                    if (parseFloat(sizeMB) > 1) {
                        if (!window.confirm(`üì∏ Exporting ${screenshotCount} screenshot(s)\nApproximate size: ${sizeMB} MB\n\nThis may take a moment to download. Continue?`)) {
                            return;
                        }
                    } else {
                        showMessage(`üì∏ Exporting ${screenshotCount} screenshot(s)\nApproximate size: ${sizeMB} MB`);
                    }
                    break;
                
                case 'csv':
                    // Export as CSV for Excel
                    return handleExportCSV();
                
                default:
                    exportData = { trades: appState.trades };
                    filename = `trading-journal-${timestamp}.json`;
            }
            
            try {
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                    type: 'application/json' 
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show download notification
                showDownloadNotification({
                    filename: filename,
                    type: exportType,
                    timestamp: new Date().toLocaleTimeString()
                });

                // Mark export timestamp
                markExportTimestamp();

                showMessage(`‚úÖ Exported successfully!\nFile: ${filename}\nType: ${exportType}`);
            } catch (error) {
                console.error('Export error:', error);
                showMessage('‚ùå Error exporting data: ' + error.message, 'error');
            }
        }
        
        function handleExportCSV() {
            if (!appState.trades.length) {
                showMessage('‚ö†Ô∏è No trades to export', 'error');
                return;
            }
            
            const timestamp = new Date().toISOString().split('T')[0];
            
            // CSV Headers
            const headers = [
                'Open Date', 'Open Time', 'Close Date', 'Close Time', 'Symbol', 'Direction', 'Entry Price', 'Exit Price',
                'Volume', 'Pips', 'Gross P/L', 'Net P/L', 'Commission', 'Swap',
                'Setup Type', 'Market Condition', 'Emotional State', 'Rule Adherence', 'Notes'
            ];

            // CSV Rows
            const rows = appState.trades.map(trade => [
                trade.openDate || '',
                trade.openTime || '',
                formatDate(trade.closeTime || trade.date),
                formatTime(trade.closeTime || trade.time),
                trade.symbol,
                trade.direction,
                trade.entryPrice,
                trade.exitPrice || trade.closePrice,
                trade.volume || trade.quantity,
                trade.pips,
                trade.grossProfit || trade.grossPL || 0,
                trade.netPL || trade.profit,
                trade.commission,
                trade.swap,
                trade.setupType || '',
                trade.marketCondition || '',
                trade.emotionalState || '',
                trade.ruleAdherence || '',
                (trade.notes || '').replace(/"/g, '""') // Escape quotes
            ]);
            
            // Build CSV content
            let csvContent = headers.join(',') + '\n';
            rows.forEach(row => {
                csvContent += row.map(cell => {
                    // Quote cells that contain commas or quotes
                    const str = String(cell);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str}"`;
                    }
                    return str;
                }).join(',') + '\n';
            });
            
            // Download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trading-journal-${timestamp}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show CSV download notification
            showDownloadNotification({
                filename: `trading-journal-${timestamp}.csv`,
                type: 'csv',
                timestamp: new Date().toLocaleTimeString()
            });
            
            showMessage(`‚úÖ Exported ${appState.trades.length} trades as CSV!\nFile: trading-journal-${timestamp}.csv`);
        }
        
        // Size estimation functions
        function estimateFullSize() {
            const fullData = {
                trades: appState.trades,
                screenshots: getScreenshotsObject(),
                startingBalance: appState.startingBalance,
                customRules: appState.customRules,
                strategyContext: appState.strategyContext,
                visibleStats: appState.visibleStats,
                visibleCharts: appState.visibleCharts,
                visibleColumns: appState.visibleColumns
            };
            const size = JSON.stringify(fullData).length;
            return formatBytes(size);
        }
        
        function estimateScreenshotsSize() {
            const screenshots = getScreenshotsObject();
            const size = JSON.stringify(screenshots).length;
            return formatBytes(size);
        }
        
        function estimateNoScreenshotsSize() {
            const dataWithoutScreenshots = {
                trades: appState.trades.map(trade => ({ ...trade, entryScreenshot: null, exitScreenshot: null })),
                startingBalance: appState.startingBalance,
                customRules: appState.customRules,
                strategyContext: appState.strategyContext,
                visibleStats: appState.visibleStats,
                visibleCharts: appState.visibleCharts,
                visibleColumns: appState.visibleColumns
            };
            const size = JSON.stringify(dataWithoutScreenshots).length;
            return formatBytes(size);
        }
        
        function estimateTradesSize() {
            const tradesData = {
                trades: appState.trades.map(trade => ({ ...trade, entryScreenshot: null, exitScreenshot: null })),
                startingBalance: appState.startingBalance,
                finalBalance: appState.currentBalance
            };
            const size = JSON.stringify(tradesData).length;
            return formatBytes(size);
        }
        
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        function updateSizeEstimates() {
            if (appState.trades.length === 0) {
                document.getElementById('fullSizeEstimate').textContent = '~0 B';
                document.getElementById('noScreenshotsSizeEstimate').textContent = '~0 B';
                document.getElementById('screenshotsSizeEstimate').textContent = '~0 B';
                document.getElementById('tradesSizeEstimate').textContent = '~0 B';
                return;
            }
            
            try {
                document.getElementById('fullSizeEstimate').textContent = '~' + estimateFullSize();
                document.getElementById('noScreenshotsSizeEstimate').textContent = '~' + estimateNoScreenshotsSize();
                document.getElementById('screenshotsSizeEstimate').textContent = '~' + estimateScreenshotsSize();
                document.getElementById('tradesSizeEstimate').textContent = '~' + estimateTradesSize();
            } catch (error) {
                console.error('Error updating size estimates:', error);
            }
        }
        
        function showDownloadLocationInfo() {
            const message = 'üíæ DOWNLOAD LOCATION\n\n' +
                'Files are saved to your browser\'s default download folder.\n\n' +
                'üìÇ Common locations:\n' +
                '‚Ä¢ Windows: C:\\Users\\YourName\\Downloads\n' +
                '‚Ä¢ Mac: /Users/YourName/Downloads\n' +
                '‚Ä¢ Linux: ~/Downloads\n\n' +
                '‚öôÔ∏è To change location:\n' +
                'Check your browser\'s download settings (usually in Settings > Downloads)';
            
            alert(message);
        }
        
        // Helper function to get screenshots object
        function getScreenshotsObject() {
            const screenshots = {};
            appState.trades.forEach(trade => {
                if (trade.entryScreenshot || trade.exitScreenshot) {
                    screenshots[trade.id] = {
                        entry: trade.entryScreenshot ? [trade.entryScreenshot] : [],
                        exit: trade.exitScreenshot ? [trade.exitScreenshot] : []
                    };
                }
            });
            return screenshots;
        }
        
        // Helper functions for CSV export
        function formatDate(dateTime) {
            if (!dateTime) return '';
            if (dateTime.includes(' ')) {
                return dateTime.split(' ')[0];
            }
            return dateTime;
        }
        
        function formatTime(dateTime) {
            if (!dateTime) return '';
            if (dateTime.includes(' ')) {
                const timePart = dateTime.split(' ')[1];
                return timePart ? timePart.substring(0, 5) : '';
            }
            return dateTime.substring(0, 5);
        }

        // CRITICAL FIX: Helper function to get screenshot source with proper data URI prefix
        function getScreenshotSrc(base64Data) {
            // Check if data exists and is a string
            if (!base64Data || typeof base64Data !== 'string') {
                return null;
            }

            // If already has data URI prefix, return as-is
            if (base64Data.startsWith('data:image/')) {
                return base64Data;
            }

            // If it's a URL (TradingView link or other), return as-is
            if (base64Data.startsWith('http://') || base64Data.startsWith('https://')) {
                return base64Data;
            }

            // If it's raw Base64, add the prefix
            return `data:image/png;base64,${base64Data}`;
        }

        function handleJSONImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Security: File size validation
            if (file.size > MAX_FILE_SIZE) {
                showMessage(`File too large. Maximum size: ${MAX_FILE_SIZE / (1024 * 1024)}MB`, 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.json')) {
                showMessage('Please select a JSON file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid JSON format');
                    }
                    
                    // Check if it's a screenshots-only export
                    if (data.exportType === 'screenshots-only') {
                        if (!data.screenshots) {
                            showMessage('‚ùå No screenshots found in file', 'error');
                            return;
                        }
                        
                        // Merge with existing screenshots
                        let importedCount = 0;
                        Object.entries(data.screenshots).forEach(([tradeId, screenshots]) => {
                            const trade = appState.trades.find(t => t.id === tradeId);
                            if (trade) {
                                if (screenshots.entry && screenshots.entry.length > 0) {
                                    trade.entryScreenshot = getScreenshotSrc(screenshots.entry[0]);
                                }
                                if (screenshots.exit && screenshots.exit.length > 0) {
                                    trade.exitScreenshot = getScreenshotSrc(screenshots.exit[0]);
                                }
                                importedCount++;
                            }
                        });

                        updateUI();
                        saveToLocalStorage();
                        showMessage(`‚úÖ Imported screenshots for ${importedCount} trades\n\nScreenshots have been added to your existing trades.`);
                        return;
                    }
                    
                    // Check if it's a comprehensive journal export format
                    if (data.trades && Array.isArray(data.trades) && data.version) {
                        // Filter out trades with invalid symbols before processing
                        const validTrades = data.trades.filter(trade => {
                            const symbol = trade.symbol || '';
                            // Security: Validate symbol and basic trade structure
                            if (!isValidSymbol(symbol)) return false;
                            try {
                                // Basic validation - will be more thorough in mapping
                                if (!trade.entryPrice || !trade.exitPrice) return false;
                                return true;
                            } catch (e) {
                                return false;
                            }
                        });
                        const skippedCount = data.trades.length - validTrades.length;
                        
                        // Full journal restore
                        appState.trades = validTrades.map(trade => {
                            // Parse date/time from closeTime if available
                            let parsedDate, parsedTime;
                            if (trade.closeTime) {
                                const parsed = parsecTraderDateTime(trade.closeTime);
                                parsedDate = parsed.date;
                                parsedTime = parsed.time;
                            } else {
                                parsedDate = trade.date || new Date().toISOString().split('T')[0];
                                parsedTime = trade.time || '12:00';
                            }
                            
                            // CRITICAL FIX: Handle Base64 screenshots with proper validation
                            let entryScreenshot = null;
                            let exitScreenshot = null;
                            
                            // Check all possible screenshot field names with validation
                            const entryScreenshotData = 
                                trade.entryScreenshot || 
                                trade.screenshotEntry || 
                                trade.screenshot_entry ||
                                null;
                            
                            const exitScreenshotData = 
                                trade.exitScreenshot || 
                                trade.screenshotExit || 
                                trade.screenshot_exit ||
                                null;
                            
                            // Only process if we have valid string data
                            if (entryScreenshotData && typeof entryScreenshotData === 'string') {
                                entryScreenshot = getScreenshotSrc(entryScreenshotData);
                            }
                            
                            if (exitScreenshotData && typeof exitScreenshotData === 'string') {
                                exitScreenshot = getScreenshotSrc(exitScreenshotData);
                            }
                            
                            return {
                                ...trade,
                                // Ensure all required fields exist
                                id: trade.id || `${Date.now()}_${Math.random()}`,
                                rulesFollowed: trade.rulesFollowed || [],
                                setupType: trade.setupType || '',
                                marketCondition: trade.marketCondition || '',
                                emotionalState: trade.emotionalState || '',
                                ruleAdherence: trade.ruleAdherence || '',
                                notes: trade.notes || '',
                                tradingViewEntry: trade.tradingViewEntry || '',
                                tradingViewExit: trade.tradingViewExit || '',
                                entryScreenshot: entryScreenshot,
                                exitScreenshot: exitScreenshot,
                                // Map different field names for compatibility
                                netPL: trade.netPL || trade.profit || trade.netProfit || 0, // Primary field
                                profit: trade.netPL || trade.profit || trade.netProfit || 0, // For compatibility
                                netProfit: trade.netPL || trade.profit || trade.netProfit || 0,
                                date: parsedDate,
                                time: parsedTime,
                                closeTime: trade.closeTime || `${parsedDate} ${parsedTime}`,
                                entryPrice: trade.entryPrice || 0,
                                exitPrice: trade.closePrice || trade.exitPrice || 0,
                                volume: trade.quantity || trade.volume || 1,
                                pips: trade.pips || 0,
                                commission: trade.commission || 0,
                                swap: trade.swap || 0
                            };
                        });
                        
                        // CRITICAL FIX: Import screenshots with array format handling
                        if (data.screenshots && typeof data.screenshots === 'object' && !Array.isArray(data.screenshots)) {
                            const screenshotsObj = {};
                            
                            Object.entries(data.screenshots).forEach(([tradeId, images]) => {
                                if (images && typeof images === 'object') {
                                    const screenshotData = {};
                                    
                                    // Handle entry (array or string)
                                    if (Array.isArray(images.entry)) {
                                        if (images.entry.length > 0 && typeof images.entry[0] === 'string') {
                                            screenshotData.entry = images.entry[0];
                                        }
                                    } else if (typeof images.entry === 'string' && images.entry) {
                                        screenshotData.entry = images.entry;
                                    }
                                    
                                    // Handle exit (array or string)
                                    if (Array.isArray(images.exit)) {
                                        if (images.exit.length > 0 && typeof images.exit[0] === 'string') {
                                            screenshotData.exit = images.exit[0];
                                        }
                                    } else if (typeof images.exit === 'string' && images.exit) {
                                        screenshotData.exit = images.exit;
                                    }
                                    
                                    // Only add if we have at least one screenshot
                                    if (screenshotData.entry || screenshotData.exit) {
                                        screenshotsObj[tradeId] = screenshotData;
                                    }
                                }
                            });
                            
                            // Apply screenshots to matching trades
                            Object.entries(screenshotsObj).forEach(([tradeId, screenshots]) => {
                                const trade = appState.trades.find(t => t.id === tradeId);
                                if (trade) {
                                    if (screenshots.entry && !trade.entryScreenshot) {
                                        const entryScreenshotSrc = getScreenshotSrc(screenshots.entry);
                                        if (entryScreenshotSrc) {
                                            trade.entryScreenshot = entryScreenshotSrc;
                                        }
                                    }
                                    
                                    if (screenshots.exit && !trade.exitScreenshot) {
                                        const exitScreenshotSrc = getScreenshotSrc(screenshots.exit);
                                        if (exitScreenshotSrc) {
                                            trade.exitScreenshot = exitScreenshotSrc;
                                        }
                                    }
                                }
                            });
                            
                            console.log('‚úÖ Processed screenshots for', Object.keys(screenshotsObj).length, 'trades');
                        }
                        
                        appState.startingBalance = data.startingBalance || data.finalBalance - appState.trades.reduce((sum, t) => sum + t.profit, 0) || 10000;
                        appState.customRules = data.customRules || [];
                        
                        // Import strategy context
                        if (data.strategyContext) {
                            appState.strategyContext = data.strategyContext;
                            document.getElementById('strategyContextTextarea').value = data.strategyContext;
                            updateStrategyContextCounter();
                        }
                        
                        // Restore view settings
                        if (data.visibleStats) appState.visibleStats = { ...appState.visibleStats, ...data.visibleStats };
                        if (data.visibleColumns) appState.visibleColumns = { ...appState.visibleColumns, ...data.visibleColumns };
                        if (data.visibleCharts) appState.visibleCharts = { ...appState.visibleCharts, ...data.visibleCharts };
                        if (data.chartZoom) appState.chartZoom = data.chartZoom;
                        
                        // Restore UI preferences
                        if (data.uiPreferences) {
                            if (data.uiPreferences.showTradeHistory !== undefined) {
                                appState.showTradeHistory = data.uiPreferences.showTradeHistory;
                            }
                            if (data.uiPreferences.showAccountSettings !== undefined) {
                                appState.showAccountSettings = data.uiPreferences.showAccountSettings;
                            }
                        }
                        
                        updateUI();
                        
                        // Show import message with filtering info
                        const screenshotCount = appState.trades.filter(t => t.entryScreenshot || t.exitScreenshot).length;
                        const screenshotMsg = screenshotCount > 0 ? ` (${screenshotCount} trades with screenshots)` : '';
                        if (skippedCount > 0) {
                            showMessage(`‚úÖ Imported ${validTrades.length} trades (${skippedCount} skipped - invalid symbols) with all journal data${screenshotMsg}`);
                        } else {
                            showMessage(`‚úÖ Imported ${validTrades.length} trades with all journal data successfully${screenshotMsg}`);
                        }
                        
                        // Auto-expand trade history after successful import
                        if (validTrades.length > 0) {
                            appState.showTradeHistory = true;
                            updateTradeHistoryCollapseState();
                        }

                        // Save to localStorage after successful import
                        saveToLocalStorage();
                    } else if (data.trades && Array.isArray(data.trades)) {
                        // Filter out trades with invalid symbols
                        const validTrades = data.trades.filter(trade => {
                            const symbol = trade.symbol || '';
                            return isValidSymbol(symbol);
                        });
                        const skippedCount = data.trades.length - validTrades.length;
                        
                        // Simple trades array format
                        appState.trades = validTrades.map(trade => {
                            // Parse date/time from closeTime if available
                            let parsedDate, parsedTime;
                            if (trade.closeTime) {
                                const parsed = parsecTraderDateTime(trade.closeTime);
                                parsedDate = parsed.date;
                                parsedTime = parsed.time;
                            } else {
                                parsedDate = trade.date || new Date().toISOString().split('T')[0];
                                parsedTime = trade.time || '12:00';
                            }
                            
                            // CRITICAL FIX: Handle Base64 screenshots with proper validation for simple format
                            let entryScreenshot = null;
                            let exitScreenshot = null;
                            
                            // Check all possible screenshot field names with validation
                            const entryScreenshotData = 
                                trade.entryScreenshot || 
                                trade.screenshotEntry || 
                                trade.screenshot_entry ||
                                null;
                            
                            const exitScreenshotData = 
                                trade.exitScreenshot || 
                                trade.screenshotExit || 
                                trade.screenshot_exit ||
                                null;
                            
                            // Only process if we have valid string data
                            if (entryScreenshotData && typeof entryScreenshotData === 'string') {
                                entryScreenshot = getScreenshotSrc(entryScreenshotData);
                            }
                            
                            if (exitScreenshotData && typeof exitScreenshotData === 'string') {
                                exitScreenshot = getScreenshotSrc(exitScreenshotData);
                            }
                            
                            return {
                                ...trade,
                                id: trade.id || `${Date.now()}_${Math.random()}`,
                                netPL: trade.netPL || trade.profit || 0,
                                profit: trade.netPL || trade.profit || 0,
                                date: parsedDate,
                                time: parsedTime,
                                closeTime: trade.closeTime || `${parsedDate} ${parsedTime}`,
                                rulesFollowed: trade.rulesFollowed || [],
                                setupType: trade.setupType || '',
                                marketCondition: trade.marketCondition || '',
                                emotionalState: trade.emotionalState || '',
                                ruleAdherence: trade.ruleAdherence || '',
                                notes: trade.notes || '',
                                entryScreenshot: entryScreenshot,
                                exitScreenshot: exitScreenshot
                            };
                        });
                        
                        // CRITICAL FIX: Import screenshots with array format handling (simple format)
                        if (data.screenshots && typeof data.screenshots === 'object' && !Array.isArray(data.screenshots)) {
                            const screenshotsObj = {};
                            
                            Object.entries(data.screenshots).forEach(([tradeId, images]) => {
                                if (images && typeof images === 'object') {
                                    const screenshotData = {};
                                    
                                    // Handle entry (array or string)
                                    if (Array.isArray(images.entry)) {
                                        if (images.entry.length > 0 && typeof images.entry[0] === 'string') {
                                            screenshotData.entry = images.entry[0];
                                        }
                                    } else if (typeof images.entry === 'string' && images.entry) {
                                        screenshotData.entry = images.entry;
                                    }
                                    
                                    // Handle exit (array or string)
                                    if (Array.isArray(images.exit)) {
                                        if (images.exit.length > 0 && typeof images.exit[0] === 'string') {
                                            screenshotData.exit = images.exit[0];
                                        }
                                    } else if (typeof images.exit === 'string' && images.exit) {
                                        screenshotData.exit = images.exit;
                                    }
                                    
                                    // Only add if we have at least one screenshot
                                    if (screenshotData.entry || screenshotData.exit) {
                                        screenshotsObj[tradeId] = screenshotData;
                                    }
                                }
                            });
                            
                            // Apply screenshots to matching trades
                            Object.entries(screenshotsObj).forEach(([tradeId, screenshots]) => {
                                const trade = appState.trades.find(t => t.id === tradeId);
                                if (trade) {
                                    if (screenshots.entry && !trade.entryScreenshot) {
                                        const entryScreenshotSrc = getScreenshotSrc(screenshots.entry);
                                        if (entryScreenshotSrc) {
                                            trade.entryScreenshot = entryScreenshotSrc;
                                        }
                                    }
                                    
                                    if (screenshots.exit && !trade.exitScreenshot) {
                                        const exitScreenshotSrc = getScreenshotSrc(screenshots.exit);
                                        if (exitScreenshotSrc) {
                                            trade.exitScreenshot = exitScreenshotSrc;
                                        }
                                    }
                                }
                            });
                            
                            console.log('‚úÖ Processed screenshots for', Object.keys(screenshotsObj).length, 'trades');
                        }
                        
                        appState.startingBalance = data.startingBalance || 10000;
                        if (data.customRules) appState.customRules = data.customRules;
                        
                        // Import strategy context for simple format
                        if (data.strategyContext) {
                            appState.strategyContext = data.strategyContext;
                            document.getElementById('strategyContextTextarea').value = data.strategyContext;
                            updateStrategyContextCounter();
                        }
                        
                        // Restore UI preferences for simple format
                        if (data.uiPreferences) {
                            if (data.uiPreferences.showTradeHistory !== undefined) {
                                appState.showTradeHistory = data.uiPreferences.showTradeHistory;
                            }
                            if (data.uiPreferences.showAccountSettings !== undefined) {
                                appState.showAccountSettings = data.uiPreferences.showAccountSettings;
                            }
                        }
                        
                        updateUI();
                        
                        // Show import message with filtering info
                        const screenshotCount = appState.trades.filter(t => t.entryScreenshot || t.exitScreenshot).length;
                        const screenshotMsg = screenshotCount > 0 ? ` (${screenshotCount} trades with screenshots)` : '';
                        if (skippedCount > 0) {
                            showMessage(`‚úÖ Imported ${validTrades.length} trades (${skippedCount} skipped - invalid symbols)${screenshotMsg}`);
                        } else {
                            showMessage(`‚úÖ Imported ${validTrades.length} trades successfully${screenshotMsg}`);
                        }
                        
                        // Auto-expand trade history after successful import
                        if (validTrades.length > 0) {
                            appState.showTradeHistory = true;
                            updateTradeHistoryCollapseState();
                        }

                        // Save to localStorage after successful import
                        saveToLocalStorage();
                    } else {
                        throw new Error('Invalid file format - expected trades array or journal export');
                    }
                } catch (error) {
                    console.error('JSON import error:', error);
                    showMessage(`‚ùå Error importing data: ${error.message}\n\nPlease check that your file is a valid Trading Journal export.`, 'error');
                }
            };
            reader.readAsText(file);
        }
        

        // Helper function to open TradingView links
        function openTradingViewLink(tradeIndex, type) {
            const trade = appState.trades[tradeIndex];
            const url = type === 'entry' ? trade.tradingViewEntry : trade.tradingViewExit;


            // Security: Use safe URL opener with validation
            if (url && url.trim()) {
                safeOpenURL(url);
            } else {
                showMessage('Please enter a TradingView URL first', 'error');
            }
        }

        // Helper function to clear screenshots
        function clearScreenshot(tradeIndex, type) {
            const field = type === 'entry' ? 'entryScreenshot' : 'exitScreenshot';
            appState.trades[tradeIndex][field] = null;
            renderTradeDetails(tradeIndex); // Refresh the details view
            showMessage(`${type.charAt(0).toUpperCase() + type.slice(1)} screenshot removed`, 'success');
        }

        // Enhanced updateTradeField to handle button state updates
        function updateTradeField(tradeIndex, field, value) {
            appState.trades[tradeIndex][field] = value;
            calculateStatistics();
            updateUI();

            // Update TradingView button states if it's a TradingView field
            if (field === 'tradingViewEntry') {
                const button = document.querySelector(`button[onclick="openTradingViewLink(${tradeIndex}, 'entry')"]`);
                if (button) {
                    button.disabled = !value || !value.trim();
                }
            } else if (field === 'tradingViewExit') {
                const button = document.querySelector(`button[onclick="openTradingViewLink(${tradeIndex}, 'exit')"]`);
                if (button) {
                    button.disabled = !value || !value.trim();
                }
            }
        }
        
        function handleScreenshotUpload(tradeIndex, type, input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const field = type === 'entry' ? 'entryScreenshot' : 'exitScreenshot';
                appState.trades[tradeIndex][field] = e.target.result;
                renderTradeDetails(tradeIndex); // Refresh to show image
            };
            reader.readAsDataURL(file);
        }
        
        function handlePaste(event) {
            const items = event.clipboardData?.items;
            if (!items) return;

            // Check if we have an active trade details section open
            if (appState.activeTradeIndex === null) {
                return; // No trade details open, ignore paste
            }

            for (let item of items) {
                if (item.type.startsWith('image/')) {
                    event.preventDefault(); // Prevent default paste behavior

                    const file = item.getAsFile();
                    if (!file) continue;

                    // Read the file and save it to the appropriate screenshot field
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const tradeIndex = appState.activeTradeIndex;
                        const field = appState.activePasteTarget === 'entry' ? 'entryScreenshot' : 'exitScreenshot';
                        const type = appState.activePasteTarget;

                        // Save the screenshot to the trade
                        appState.trades[tradeIndex][field] = e.target.result;

                        // Refresh the trade details to show the new screenshot
                        renderTradeDetails(tradeIndex);

                        // Show success message
                        showMessage(`${type.charAt(0).toUpperCase() + type.slice(1)} screenshot pasted successfully`, 'success');
                    };
                    reader.readAsDataURL(file);

                    break; // Only handle the first image
                }
            }
        }
        
        function generateRulesChecklist(tradeIndex, followedRules) {
            return appState.customRules.map(rule => {
                const isChecked = followedRules.includes(rule.id);
                return `
                    <label style="display: block; margin-bottom: 0.5rem;">
                        <input type="checkbox" ${isChecked ? 'checked' : ''} 
                               onchange="toggleTradeRule(${tradeIndex}, ${rule.id}, this.checked)">
                        ${rule.text}
                    </label>
                `;
            }).join('');
        }
        
        function toggleTradeRule(tradeIndex, ruleId, checked) {
            const trade = appState.trades[tradeIndex];
            if (!trade.rulesFollowed) trade.rulesFollowed = [];

            // Update the data model immediately
            if (checked) {
                if (!trade.rulesFollowed.includes(ruleId)) {
                    trade.rulesFollowed.push(ruleId);
                }
            } else {
                trade.rulesFollowed = trade.rulesFollowed.filter(id => id !== ruleId);
            }

            // Log for debugging
            console.log('toggleTradeRule - Updated:', {
                tradeIndex,
                ruleId,
                checked,
                rulesFollowed: [...trade.rulesFollowed],
                tradeId: trade.id
            });

            // Defer updates slightly to let checkbox state settle
            setTimeout(() => {
                // Only recalculate statistics, don't update any displays
                // This prevents any potential interference with the checkbox DOM
                calculateStatistics();

                // Update displays after a delay to ensure checkbox is stable
                setTimeout(() => {
                    updateStatisticsDisplay();
                    updateCustomRulesDisplay();
                    updateRuleCombinationsAnalysis();
                }, 100);
            }, 0);
        }
        
        // Lightbox Functions
        function openLightbox(imageSrc) {
            document.getElementById('lightboxImage').src = imageSrc;
            document.getElementById('lightbox').style.display = 'flex';
        }
        
        function closeLightbox() {
            document.getElementById('lightbox').style.display = 'none';
        }
        
        // Custom Rules Management
        function updateRuleCombinationsAnalysis() {
            const resultsDiv = document.getElementById('ruleCombinationsResults');

            // Get combinations based on selected view: TOTAL (-1) or specific month
            const combinations = appState.ruleCombinationsCurrentMonth === -1
                ? calculateRuleCombinations()
                : calculateRuleCombinations(appState.ruleCombinationsCurrentYear, appState.ruleCombinationsCurrentMonth);
            
            if (combinations.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="padding: 2rem; text-center; color: var(--color-text-secondary);">
                        <p>No trades with Custom rule adherence found.</p>
                        <p style="font-size: var(--font-size-xs); margin-top: var(--space-8);">
                            Mark trades as "Custom" and check which rules you followed to see analysis.
                        </p>
                    </div>
                `;
                return;
            }
            
            const bestCombination = combinations[0];
            const mostProfitableCombination = combinations.sort((a, b) => b.totalPL - a.totalPL)[0];
            const worstCombination = combinations[combinations.length - 1];
            
            // Re-sort for display
            combinations.sort((a, b) => {
                if (Math.abs(b.winRate - a.winRate) > 1) {
                    return b.winRate - a.winRate;
                }
                return b.totalPL - a.totalPL;
            });
            
            resultsDiv.innerHTML = `
                <!-- Summary Stats -->
                <div style="margin-bottom: 1rem; padding: var(--space-12); background: var(--color-bg-1); border-radius: var(--radius-base);">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Total Combinations</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold);">${combinations.length}</div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Best Win Rate</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: var(--color-success);">
                                ${bestCombination.winRate.toFixed(1)}%
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Best Combination</div>
                            <div style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); max-width: 150px; margin: 0 auto; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${bestCombination.ruleNames.length} ${bestCombination.ruleNames.length === 1 ? 'rule' : 'rules'}
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Combinations Table -->
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: var(--font-size-sm);">
                        <thead style="background: var(--color-bg-2);">
                            <tr>
                                <th style="padding: var(--space-8); text-align: left;">Rank</th>
                                <th style="padding: var(--space-8); text-align: left;">Rule Combination</th>
                                <th style="padding: var(--space-8); text-align: center;">Trades</th>
                                <th style="padding: var(--space-8); text-align: center;">W/L</th>
                                <th style="padding: var(--space-8); text-align: center;">Win Rate</th>
                                <th style="padding: var(--space-8); text-align: right;">Total P&L</th>
                                <th style="padding: var(--space-8); text-align: center;">PF</th>
                                <th style="padding: var(--space-8); text-align: right;">Expectancy</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${combinations.map((combo, index) => `
                                <tr style="border-top: 1px solid var(--color-border); ${
                                    index === 0 ? 'background: rgba(var(--color-success-rgb), 0.1);' :
                                    index === combinations.length - 1 ? 'background: rgba(var(--color-error-rgb), 0.1);' :
                                    ''
                                } transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='${index === 0 ? 'rgba(var(--color-success-rgb), 0.1)' : index === combinations.length - 1 ? 'rgba(var(--color-error-rgb), 0.1)' : 'transparent'}'">
                                    <td style="padding: var(--space-8);">
                                        ${index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`}
                                    </td>
                                    <td style="padding: var(--space-8);">
                                        <div style="display: flex; flex-wrap: wrap; gap: var(--space-4);">
                                            ${combo.ruleNames.map((name, i) => `
                                                <span style="padding: var(--space-2) var(--space-6); background: var(--color-bg-3); color: var(--color-primary); border-radius: var(--radius-sm); font-size: var(--font-size-xs);">
                                                    ${name}
                                                </span>
                                            `).join('')}
                                        </div>
                                    </td>
                                    <td style="padding: var(--space-8); text-align: center;">${combo.totalTrades}</td>
                                    <td style="padding: var(--space-8); text-align: center;">
                                        <span style="color: var(--color-success);">${combo.wins}</span>/
                                        <span style="color: var(--color-error);">${combo.losses}</span>
                                    </td>
                                    <td style="padding: var(--space-8); text-align: center;">
                                        <span style="color: ${
                                            combo.winRate >= 60 ? 'var(--color-success)' :
                                            combo.winRate >= 50 ? 'var(--color-warning)' :
                                            'var(--color-error)'
                                        }; font-weight: ${combo.winRate >= 60 ? 'var(--font-weight-bold)' : 'normal'};">
                                            ${combo.winRate.toFixed(1)}%
                                        </span>
                                    </td>
                                    <td style="padding: var(--space-8); text-align: right; font-family: var(--font-family-mono); color: ${combo.totalPL >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">
                                        $${combo.totalPL.toFixed(2)}
                                    </td>
                                    <td style="padding: var(--space-8); text-align: center;">
                                        ${combo.profitFactor > 0 ? combo.profitFactor.toFixed(2) : '‚Äî'}
                                    </td>
                                    <td style="padding: var(--space-8); text-align: right; font-family: var(--font-family-mono); color: ${combo.expectancy >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">
                                        $${combo.expectancy.toFixed(2)}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                
                <!-- Insights -->
                <div style="margin-top: 1rem; padding: var(--space-12); background: var(--color-bg-3); border: 1px solid rgba(var(--color-primary-rgb), 0.3); border-radius: var(--radius-base);">
                    <h4 style="font-weight: var(--font-weight-semibold); color: var(--color-primary); margin-bottom: var(--space-8); font-size: var(--font-size-sm);">üí° Key Insights:</h4>
                    <ul style="font-size: var(--font-size-sm); color: var(--color-text); margin: 0; padding-left: var(--space-16); line-height: 1.6;">
                        <li style="margin-bottom: var(--space-4);">ü•á <strong>Best combination:</strong> ${bestCombination.displayName} with ${bestCombination.winRate.toFixed(1)}% win rate (${bestCombination.totalTrades} trades)</li>
                        <li style="margin-bottom: var(--space-4);">üìä <strong>Most profitable:</strong> ${mostProfitableCombination.displayName} with $${mostProfitableCombination.totalPL.toFixed(2)} total P&L</li>
                        <li style="margin-bottom: 0;">‚ö†Ô∏è <strong>Least effective:</strong> ${worstCombination.displayName} with ${worstCombination.winRate.toFixed(1)}% win rate</li>
                    </ul>
                </div>
            `;
        }
        
        function updateCustomRulesDisplay() {
            const rulesGrid = document.getElementById('rulesGrid');
            const ruleStats = document.getElementById('ruleStats');
            
            rulesGrid.innerHTML = appState.customRules.map((rule, index) => `
                <div class="rule-card">
                    <input type="text" class="form-control" value="${rule.text}" 
                           onchange="updateCustomRule(${rule.id}, this.value)" 
                           placeholder="Rule description...">
                    <button class="btn btn-secondary" onclick="removeCustomRule(${rule.id})">Remove</button>
                    <div class="rule-stats">
                        <span>Followed: ${getRuleFollowedCount(rule.id)}</span>
                        <span>Win Rate: ${getRuleWinRate(rule.id).toFixed(1)}%</span>
                    </div>
                </div>
            `).join('');
            
            // Overall rule statistics
            const totalRulesTrades = appState.trades.filter(t => t.rulesFollowed?.length > 0).length;
            const rulesWins = appState.trades.filter(t => t.rulesFollowed?.length > 0 && (t.netPL || t.profit) > 0).length;
            const rulesWinRate = totalRulesTrades > 0 ? (rulesWins / totalRulesTrades * 100) : 0;
            
            const noRulesTrades = appState.trades.filter(t => !t.rulesFollowed || t.rulesFollowed.length === 0).length;
            const noRulesWins = appState.trades.filter(t => (!t.rulesFollowed || t.rulesFollowed.length === 0) && (t.netPL || t.profit) > 0).length;
            const noRulesWinRate = noRulesTrades > 0 ? (noRulesWins / noRulesTrades * 100) : 0;
            
            ruleStats.innerHTML = `
                <div class="breakdown-grid">
                    <div class="breakdown-item">
                        <div class="breakdown-header">With Rules</div>
                        <div class="breakdown-stats">
                            Trades: ${totalRulesTrades}<br>
                            Win Rate: <span class="${rulesWinRate >= 50 ? 'positive' : 'negative'}">${rulesWinRate.toFixed(1)}%</span>
                        </div>
                    </div>
                    <div class="breakdown-item">
                        <div class="breakdown-header">Without Rules</div>
                        <div class="breakdown-stats">
                            Trades: ${noRulesTrades}<br>
                            Win Rate: <span class="${noRulesWinRate >= 50 ? 'positive' : 'negative'}">${noRulesWinRate.toFixed(1)}%</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function addCustomRule() {
            if (appState.customRules.length >= 10) {
                showMessage('Maximum 10 custom rules allowed', 'error');
                return;
            }

            const newId = Math.max(...appState.customRules.map(r => r.id), 0) + 1;
            appState.customRules.push({
                id: newId,
                text: 'New Rule',
                enabled: true
            });

            updateCustomRulesDisplay();
            saveToLocalStorage();
        }
        
        function updateCustomRule(ruleId, newText) {
            const rule = appState.customRules.find(r => r.id === ruleId);
            if (rule) {
                rule.text = newText;
                saveToLocalStorage();
            }
        }
        
        function removeCustomRule(ruleId) {
            appState.customRules = appState.customRules.filter(r => r.id !== ruleId);

            // Remove rule from all trades
            appState.trades.forEach(trade => {
                if (trade.rulesFollowed) {
                    trade.rulesFollowed = trade.rulesFollowed.filter(id => id !== ruleId);
                }
            });

            updateCustomRulesDisplay();
            saveToLocalStorage();
        }
        
        function getRuleFollowedCount(ruleId) {
            return appState.trades.filter(t => t.rulesFollowed?.includes(ruleId)).length;
        }
        
        function getRuleWinRate(ruleId) {
            const trades = appState.trades.filter(t => t.rulesFollowed?.includes(ruleId));
            const wins = trades.filter(t => (t.netPL || t.profit) > 0);
            return trades.length > 0 ? (wins.length / trades.length * 100) : 0;
        }
        
        // RULE COMBINATIONS ANALYSIS - NEW FEATURE
        function calculateRuleCombinations(year = null, month = null) {
            if (!appState.trades.length || !appState.customRules.length) return [];

            // Get all trades with Custom rule adherence and rules followed
            let customTrades = appState.trades.filter(t =>
                t.ruleAdherence === 'Custom' &&
                Array.isArray(t.rulesFollowed) &&
                t.rulesFollowed.length > 0
            );

            // Filter by month if specified (month !== null and month !== -1)
            if (month !== null && month !== -1 && year !== null) {
                customTrades = customTrades.filter(t => {
                    const tradeDate = new Date(t.date);
                    return tradeDate.getMonth() === month && tradeDate.getFullYear() === year;
                });
            }
            
            if (customTrades.length === 0) return [];
            
            // Generate all possible combinations
            const combinations = [];
            const ruleIds = appState.customRules.map(r => r.id);
            
            // Single rules
            ruleIds.forEach(ruleId => {
                combinations.push([ruleId]);
            });
            
            // Pairs (2 rules)
            for (let i = 0; i < ruleIds.length; i++) {
                for (let j = i + 1; j < ruleIds.length; j++) {
                    combinations.push([ruleIds[i], ruleIds[j]]);
                }
            }
            
            // Triplets (3 rules)
            for (let i = 0; i < ruleIds.length; i++) {
                for (let j = i + 1; j < ruleIds.length; j++) {
                    for (let k = j + 1; k < ruleIds.length; k++) {
                        combinations.push([ruleIds[i], ruleIds[j], ruleIds[k]]);
                    }
                }
            }
            
            // Quads (4 rules) - if applicable
            if (ruleIds.length >= 4) {
                for (let i = 0; i < ruleIds.length; i++) {
                    for (let j = i + 1; j < ruleIds.length; j++) {
                        for (let k = j + 1; k < ruleIds.length; k++) {
                            for (let l = k + 1; l < ruleIds.length; l++) {
                                combinations.push([ruleIds[i], ruleIds[j], ruleIds[k], ruleIds[l]]);
                            }
                        }
                    }
                }
            }
            
            // All rules together
            if (ruleIds.length > 1) {
                combinations.push(ruleIds);
            }
            
            // Calculate stats for each combination
            const results = combinations.map(combo => {
                // Find trades that have ALL rules in this combination
                const matchingTrades = customTrades.filter(trade => {
                    return combo.every(ruleId => trade.rulesFollowed.includes(ruleId));
                });
                
                if (matchingTrades.length === 0) {
                    return null; // Skip combinations with no trades
                }
                
                const wins = matchingTrades.filter(t => parseFloat(t.netPL || 0) > 0).length;
                const losses = matchingTrades.filter(t => parseFloat(t.netPL || 0) < 0).length;
                const totalPL = matchingTrades.reduce((sum, t) => sum + (parseFloat(t.netPL) || 0), 0);
                const winRate = matchingTrades.length > 0 ? (wins / matchingTrades.length) * 100 : 0;
                
                const avgWin = wins > 0 ? matchingTrades
                    .filter(t => parseFloat(t.netPL || 0) > 0)
                    .reduce((sum, t) => sum + parseFloat(t.netPL), 0) / wins : 0;
                
                const avgLoss = losses > 0 ? matchingTrades
                    .filter(t => parseFloat(t.netPL || 0) < 0)
                    .reduce((sum, t) => sum + parseFloat(t.netPL), 0) / losses : 0;
                
                const profitFactor = losses > 0 && avgLoss < 0 ? 
                    (wins * avgWin) / (losses * Math.abs(avgLoss)) : 0;
                
                // Get rule names
                const ruleNames = combo.map(ruleId => {
                    const rule = appState.customRules.find(r => r.id === ruleId);
                    return rule ? rule.text : 'Unknown';
                });
                
                return {
                    combo: combo,
                    ruleNames: ruleNames,
                    displayName: ruleNames.join(' + '),
                    totalTrades: matchingTrades.length,
                    wins: wins,
                    losses: losses,
                    winRate: winRate,
                    totalPL: totalPL,
                    avgWin: avgWin,
                    avgLoss: avgLoss,
                    profitFactor: profitFactor,
                    expectancy: (winRate / 100 * avgWin) + ((1 - winRate / 100) * avgLoss)
                };
            }).filter(r => r !== null); // Remove null results
            
            // Sort by win rate (descending), then by total P/L
            return results.sort((a, b) => {
                if (Math.abs(b.winRate - a.winRate) > 1) {
                    return b.winRate - a.winRate;
                }
                return b.totalPL - a.totalPL;
            });
        }
        
        function toggleRuleCombinations() {
            appState.showRuleCombinations = !appState.showRuleCombinations;
            updateRuleCombinationsDisplay();
            saveToLocalStorage();
        }
        
        function updateRuleCombinationsDisplay() {
            const content = document.getElementById('ruleCombinationsContent');
            const toggleButton = document.getElementById('ruleCombinationsToggle');

            if (appState.showRuleCombinations) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
        }

        // Toggle functions for collapsible sections
        function toggleStatistics() {
            appState.showStatistics = !appState.showStatistics;
            const content = document.querySelector('#statisticsSection .section-content');
            const toggleButton = document.getElementById('statisticsToggle');
            if (appState.showStatistics) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function toggleCharts() {
            appState.showCharts = !appState.showCharts;
            const content = document.querySelector('#chartsSection .section-content');
            const toggleButton = document.getElementById('chartsToggle');
            if (appState.showCharts) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function toggleRules() {
            appState.showRules = !appState.showRules;
            const content = document.querySelector('#rulesSection .section-content');
            const toggleButton = document.getElementById('rulesToggle');
            if (appState.showRules) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function toggleBreakdowns() {
            appState.showBreakdowns = !appState.showBreakdowns;
            const content = document.querySelector('#breakdownsSection .section-content');
            const toggleButton = document.getElementById('breakdownsToggle');
            if (appState.showBreakdowns) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function toggleTimeAnalytics() {
            appState.showTimeAnalytics = !appState.showTimeAnalytics;
            const content = document.querySelector('#timeAnalyticsSection .section-content');
            const toggleButton = document.getElementById('timeAnalyticsToggle');
            if (appState.showTimeAnalytics) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function toggleCalendar() {
            appState.showCalendar = !appState.showCalendar;
            const content = document.querySelector('#calendarSection .section-content');
            const toggleButton = document.getElementById('calendarToggle');
            if (appState.showCalendar) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function toggleAI() {
            appState.showAI = !appState.showAI;
            const content = document.querySelector('#aiSection .section-content');
            const toggleButton = document.getElementById('aiToggle');
            if (appState.showAI) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        function displayMonteCarloBaselineData() {
            const baselineContent = document.getElementById('monteCarloBaselineContent');

            if (appState.trades.length === 0) {
                baselineContent.innerHTML = '<p style="margin: 0; font-style: italic;">No trades imported yet. Import trades to see baseline statistics.</p>';
                return;
            }

            const trades = appState.trades;
            const startingBalance = appState.startingBalance;

            // Calculate basic trade statistics
            const totalTrades = trades.length;
            const winningTrades = trades.filter(t => (t.netPL || t.profit || 0) > 0);
            const losingTrades = trades.filter(t => (t.netPL || t.profit || 0) < 0);
            const winRate = totalTrades > 0 ? ((winningTrades.length / totalTrades) * 100).toFixed(1) : 0;

            // Calculate average win/loss
            const avgWin = winningTrades.length > 0
                ? winningTrades.reduce((sum, t) => sum + (t.netPL || t.profit || 0), 0) / winningTrades.length
                : 0;
            const avgLoss = losingTrades.length > 0
                ? losingTrades.reduce((sum, t) => sum + (t.netPL || t.profit || 0), 0) / losingTrades.length
                : 0;

            // Calculate total P&L
            const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit || 0), 0);

            // Calculate returns (as percentage of starting balance)
            const returns = trades.map(t => {
                const pl = t.netPL || t.profit || 0;
                return (pl / startingBalance) * 100; // Convert to percentage
            });

            // Calculate average and median return
            const avgReturn = returns.length > 0
                ? returns.reduce((sum, r) => sum + r, 0) / returns.length
                : 0;
            const sortedReturns = [...returns].sort((a, b) => a - b);
            const medianReturn = returns.length > 0
                ? sortedReturns[Math.floor(sortedReturns.length / 2)]
                : 0;

            // Calculate standard deviation of returns
            const variance = returns.length > 0
                ? returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length
                : 0;
            const stdDev = Math.sqrt(variance);

            // Calculate historical max drawdown
            let balance = startingBalance;
            let peak = balance;
            let maxDrawdown = 0;

            trades.forEach(trade => {
                balance += (trade.netPL || trade.profit || 0);
                if (balance > peak) {
                    peak = balance;
                }
                const drawdown = peak > 0 ? ((peak - balance) / peak) * 100 : 0;
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                }
            });

            // Calculate win/loss ratio
            const winLossRatio = avgLoss !== 0 ? (avgWin / Math.abs(avgLoss)).toFixed(2) : 'N/A';

            // Get date range
            const dates = trades.map(t => new Date(t.entryTime || t.timestamp)).filter(d => !isNaN(d));
            const minDate = dates.length > 0 ? new Date(Math.min(...dates)) : null;
            const maxDate = dates.length > 0 ? new Date(Math.max(...dates)) : null;
            const dateRange = minDate && maxDate
                ? `${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`
                : 'N/A';

            // Build HTML
            baselineContent.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-4);">Account Information</div>
                        <div style="margin-bottom: var(--space-4);">Starting Balance: <strong style="color: var(--color-text);">$${startingBalance.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</strong></div>
                        <div style="margin-bottom: var(--space-4);">Total Historical P&L: <strong style="color: ${totalPL >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">${totalPL >= 0 ? '+' : ''}$${totalPL.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</strong></div>
                        <div>Date Range: <strong style="color: var(--color-text);">${dateRange}</strong></div>
                    </div>
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-4);">Trade Statistics</div>
                        <div style="margin-bottom: var(--space-4);">Total Trades: <strong style="color: var(--color-text);">${totalTrades}</strong></div>
                        <div style="margin-bottom: var(--space-4);">Win Rate: <strong style="color: ${parseFloat(winRate) >= 50 ? 'var(--color-success)' : 'var(--color-text)'};">${winRate}%</strong></div>
                        <div>Win/Loss Ratio: <strong style="color: var(--color-text);">${winLossRatio}</strong></div>
                    </div>
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-4);">Average Outcomes</div>
                        <div style="margin-bottom: var(--space-4);">Avg Win: <strong style="color: var(--color-success);">+$${avgWin.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</strong></div>
                        <div style="margin-bottom: var(--space-4);">Avg Loss: <strong style="color: var(--color-error);">${avgLoss >= 0 ? '' : ''}$${avgLoss.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</strong></div>
                    </div>
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-4);">Return Metrics</div>
                        <div style="margin-bottom: var(--space-4);">Avg Return/Trade: <strong style="color: ${avgReturn >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">${avgReturn >= 0 ? '+' : ''}${avgReturn.toFixed(3)}%</strong></div>
                        <div style="margin-bottom: var(--space-4);">Median Return: <strong style="color: ${medianReturn >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">${medianReturn >= 0 ? '+' : ''}${medianReturn.toFixed(3)}%</strong></div>
                        <div>Return Std Dev: <strong style="color: var(--color-text);">${stdDev.toFixed(3)}%</strong></div>
                    </div>
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-4);">Risk Metrics</div>
                        <div>Max Drawdown: <strong style="color: var(--color-error);">${maxDrawdown.toFixed(2)}%</strong></div>
                    </div>
                </div>
                <div style="margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border); font-style: italic; font-size: var(--font-size-xs);">
                    The simulation will randomly resample from these ${totalTrades} historical trades to generate possible future outcomes.
                </div>
            `;
        }

        function toggleMonteCarlo() {
            appState.showMonteCarlo = !appState.showMonteCarlo;
            const content = document.querySelector('#monteCarloSection .section-content');
            const toggleButton = document.getElementById('monteCarloToggle');
            if (appState.showMonteCarlo) {
                content.style.display = 'block';
                toggleButton.textContent = '‚ñº';
                displayMonteCarloBaselineData(); // Update baseline data when section is opened
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '‚ñ∂';
            }
            saveToLocalStorage();
        }

        // Apply all section collapse states to the UI
        function applySectionCollapseStates() {
            // Statistics Section
            const statisticsContent = document.querySelector('#statisticsSection .section-content');
            const statisticsToggle = document.getElementById('statisticsToggle');
            if (statisticsContent && statisticsToggle) {
                statisticsContent.style.display = appState.showStatistics ? 'block' : 'none';
                statisticsToggle.textContent = appState.showStatistics ? '‚ñº' : '‚ñ∂';
            }

            // Charts Section
            const chartsContent = document.querySelector('#chartsSection .section-content');
            const chartsToggle = document.getElementById('chartsToggle');
            if (chartsContent && chartsToggle) {
                chartsContent.style.display = appState.showCharts ? 'block' : 'none';
                chartsToggle.textContent = appState.showCharts ? '‚ñº' : '‚ñ∂';
            }

            // Rules Section
            const rulesContent = document.querySelector('#rulesSection .section-content');
            const rulesToggle = document.getElementById('rulesToggle');
            if (rulesContent && rulesToggle) {
                rulesContent.style.display = appState.showRules ? 'block' : 'none';
                rulesToggle.textContent = appState.showRules ? '‚ñº' : '‚ñ∂';
            }

            // Breakdowns Section
            const breakdownsContent = document.querySelector('#breakdownsSection .section-content');
            const breakdownsToggle = document.getElementById('breakdownsToggle');
            if (breakdownsContent && breakdownsToggle) {
                breakdownsContent.style.display = appState.showBreakdowns ? 'block' : 'none';
                breakdownsToggle.textContent = appState.showBreakdowns ? '‚ñº' : '‚ñ∂';
            }

            // Time Analytics Section
            const timeAnalyticsContent = document.querySelector('#timeAnalyticsSection .section-content');
            const timeAnalyticsToggle = document.getElementById('timeAnalyticsToggle');
            if (timeAnalyticsContent && timeAnalyticsToggle) {
                timeAnalyticsContent.style.display = appState.showTimeAnalytics ? 'block' : 'none';
                timeAnalyticsToggle.textContent = appState.showTimeAnalytics ? '‚ñº' : '‚ñ∂';
            }

            // Calendar Section
            const calendarContent = document.querySelector('#calendarSection .section-content');
            const calendarToggle = document.getElementById('calendarToggle');
            if (calendarContent && calendarToggle) {
                calendarContent.style.display = appState.showCalendar ? 'block' : 'none';
                calendarToggle.textContent = appState.showCalendar ? '‚ñº' : '‚ñ∂';
            }

            // AI Section
            const aiContent = document.querySelector('#aiSection .section-content');
            const aiToggle = document.getElementById('aiToggle');
            if (aiContent && aiToggle) {
                aiContent.style.display = appState.showAI ? 'block' : 'none';
                aiToggle.textContent = appState.showAI ? '‚ñº' : '‚ñ∂';
            }

            // Monte Carlo Section
            const monteCarloContent = document.querySelector('#monteCarloSection .section-content');
            const monteCarloToggle = document.getElementById('monteCarloToggle');
            if (monteCarloContent && monteCarloToggle) {
                monteCarloContent.style.display = appState.showMonteCarlo ? 'block' : 'none';
                monteCarloToggle.textContent = appState.showMonteCarlo ? '‚ñº' : '‚ñ∂';
            }

            // Rule Combinations Section
            const ruleCombinationsContent = document.querySelector('#ruleCombinationsSection .section-content');
            const ruleCombinationsToggle = document.getElementById('ruleCombinationsToggle');
            if (ruleCombinationsContent && ruleCombinationsToggle) {
                ruleCombinationsContent.style.display = appState.showRuleCombinations ? 'block' : 'none';
                ruleCombinationsToggle.textContent = appState.showRuleCombinations ? '‚ñº' : '‚ñ∂';
            }
        }

        // Monte Carlo Simulation Functions
        let monteCarloMode = 'standard'; // 'standard' or 'propfirm'

        function switchMCMode(mode) {
            monteCarloMode = mode;

            // Update button styles
            const standardBtn = document.getElementById('mcModeStandard');
            const propFirmBtn = document.getElementById('mcModePropFirm');

            if (mode === 'standard') {
                standardBtn.style.background = 'var(--color-primary)';
                standardBtn.style.borderColor = 'var(--color-primary)';
                propFirmBtn.style.background = '';
                propFirmBtn.style.borderColor = '';

                document.getElementById('mcStandardConfig').style.display = 'block';
                document.getElementById('mcPropFirmConfig').style.display = 'none';
            } else {
                propFirmBtn.style.background = 'var(--color-primary)';
                propFirmBtn.style.borderColor = 'var(--color-primary)';
                standardBtn.style.background = '';
                standardBtn.style.borderColor = '';

                document.getElementById('mcStandardConfig').style.display = 'none';
                document.getElementById('mcPropFirmConfig').style.display = 'block';
            }

            // Hide all result sections, show placeholder
            document.getElementById('monteCarloResults').style.display = 'none';
            document.getElementById('propFirmResults').style.display = 'none';
            document.getElementById('monteCarloLoading').style.display = 'none';
            document.getElementById('monteCarloPlaceholder').style.display = 'block';
        }

        function runMonteCarloSimulation() {
            if (appState.trades.length === 0) {
                showMessage('Please import some trades first.', 'error');
                return;
            }

            if (monteCarloMode === 'standard') {
                runStandardMonteCarloSimulation();
            } else {
                runPropFirmSimulation();
            }
        }

        function runStandardMonteCarloSimulation() {
            // Get simulation parameters
            const numSimulations = parseInt(document.getElementById('mcNumSimulations').value);
            const numTrades = parseInt(document.getElementById('mcNumTrades').value);
            const positionSize = parseFloat(document.getElementById('mcPositionSize').value) / 100;

            // Validate parameters
            if (numSimulations < 100 || numSimulations > 10000) {
                showMessage('Number of simulations must be between 100 and 10000.', 'error');
                return;
            }
            if (numTrades < 10 || numTrades > 1000) {
                showMessage('Number of trades must be between 10 and 1000.', 'error');
                return;
            }
            if (positionSize <= 0 || positionSize > 1) {
                showMessage('Position size must be between 0.1% and 100%.', 'error');
                return;
            }

            // Show loading indicator, hide results and placeholder
            document.getElementById('monteCarloLoading').style.display = 'block';
            document.getElementById('monteCarloResults').style.display = 'none';
            document.getElementById('propFirmResults').style.display = 'none';
            document.getElementById('monteCarloPlaceholder').style.display = 'none';

            // Run simulation with a slight delay to allow UI update
            setTimeout(() => {
                try {
                    const results = calculateMonteCarloSimulation(numSimulations, numTrades, positionSize);
                    displayMonteCarloResults(results);
                    drawMonteCarloCharts(results);
                    showMessage('Simulation completed successfully!', 'success');
                } catch (error) {
                    console.error('Simulation error:', error);
                    showMessage('Error running simulation. Please try again.', 'error');
                    document.getElementById('monteCarloPlaceholder').style.display = 'block';
                } finally {
                    // Hide loading indicator
                    document.getElementById('monteCarloLoading').style.display = 'none';
                }
            }, 100);
        }

        function runPropFirmSimulation() {
            // Check if trades exist
            if (appState.trades.length === 0) {
                showMessage('Please import some trades first.', 'error');
                return;
            }

            // Get simulation parameters
            const numSimulations = parseInt(document.getElementById('pfNumSimulations').value);
            const challengeBalance = parseFloat(document.getElementById('pfChallengeBalance').value);
            const profitTarget = parseFloat(document.getElementById('pfProfitTarget').value) / 100;
            const maxDrawdown = parseFloat(document.getElementById('pfMaxDrawdown').value) / 100;
            const dailyLossLimit = parseFloat(document.getElementById('pfDailyLossLimit').value) / 100;
            const minTradingDays = parseInt(document.getElementById('pfMinTradingDays').value);
            const positionSize = parseFloat(document.getElementById('pfPositionSize').value) / 100;

            // Get new parameters
            const minTradesPerDay = parseInt(document.getElementById('pfMinTradesPerDay').value);
            const maxTradesPerDay = parseInt(document.getElementById('pfMaxTradesPerDay').value);
            const customAvgWinInput = document.getElementById('pfCustomAvgWin').value;
            const customAvgLossInput = document.getElementById('pfCustomAvgLoss').value;
            const customAvgWin = customAvgWinInput ? parseFloat(customAvgWinInput) : null;
            const customAvgLoss = customAvgLossInput ? parseFloat(customAvgLossInput) : null;

            // Validate parameters
            if (numSimulations < 100 || numSimulations > 10000) {
                showMessage('Number of simulations must be between 100 and 10000.', 'error');
                return;
            }
            if (challengeBalance < 1000 || challengeBalance > 1000000) {
                showMessage('Challenge balance must be between $1,000 and $1,000,000.', 'error');
                return;
            }
            if (profitTarget <= 0 || profitTarget > 1) {
                showMessage('Profit target must be between 1% and 100%.', 'error');
                return;
            }
            if (maxDrawdown <= 0 || maxDrawdown > 0.5) {
                showMessage('Max drawdown must be between 1% and 50%.', 'error');
                return;
            }
            if (dailyLossLimit <= 0 || dailyLossLimit > 0.5) {
                showMessage('Daily loss limit must be between 1% and 50%.', 'error');
                return;
            }
            if (minTradingDays < 1 || minTradingDays > 100) {
                showMessage('Minimum trading days must be between 1 and 100.', 'error');
                return;
            }
            if (positionSize <= 0 || positionSize > 1) {
                showMessage('Position size must be between 0.1% and 100%.', 'error');
                return;
            }
            if (minTradesPerDay < 1 || minTradesPerDay > 50) {
                showMessage('Min trades per day must be between 1 and 50.', 'error');
                return;
            }
            if (maxTradesPerDay < 1 || maxTradesPerDay > 50) {
                showMessage('Max trades per day must be between 1 and 50.', 'error');
                return;
            }
            if (minTradesPerDay > maxTradesPerDay) {
                showMessage('Min trades per day cannot exceed max trades per day.', 'error');
                return;
            }
            if (customAvgWin !== null && customAvgWin <= 0) {
                showMessage('Custom avg win must be positive.', 'error');
                return;
            }
            if (customAvgLoss !== null && customAvgLoss >= 0) {
                showMessage('Custom avg loss must be negative.', 'error');
                return;
            }

            // Show loading indicator, hide results and placeholder
            document.getElementById('monteCarloLoading').style.display = 'block';
            document.getElementById('monteCarloResults').style.display = 'none';
            document.getElementById('propFirmResults').style.display = 'none';
            document.getElementById('monteCarloPlaceholder').style.display = 'none';

            // Run simulation with a slight delay to allow UI update
            setTimeout(() => {
                try {
                    const results = calculatePropFirmSimulation(
                        numSimulations,
                        challengeBalance,
                        profitTarget,
                        maxDrawdown,
                        dailyLossLimit,
                        minTradingDays,
                        positionSize,
                        minTradesPerDay,
                        maxTradesPerDay,
                        customAvgWin,
                        customAvgLoss
                    );
                    displayPropFirmResults(results);
                    drawPropFirmCharts(results);
                    showMessage('Prop Firm Challenge simulation completed successfully!', 'success');
                } catch (error) {
                    console.error('Simulation error:', error);
                    showMessage('Error running simulation. Please try again.', 'error');
                    document.getElementById('monteCarloPlaceholder').style.display = 'block';
                } finally {
                    // Hide loading indicator
                    document.getElementById('monteCarloLoading').style.display = 'none';
                }
            }, 100);
        }

        function calculateMonteCarloSimulation(numSimulations, numTrades, positionSize) {
            const trades = appState.trades;
            const startingBalance = appState.startingBalance;

            // Extract returns from historical trades (as percentage of account)
            const returns = trades.map(trade => {
                const pl = trade.netPL || trade.profit || 0;
                return pl / startingBalance;
            });

            // Run simulations
            const finalBalances = [];
            const maxDrawdowns = [];
            const equityCurves = []; // Store first 100 for visualization

            for (let sim = 0; sim < numSimulations; sim++) {
                let balance = startingBalance;
                let peak = balance;
                let maxDrawdown = 0;
                const equityCurve = [balance];

                // Randomly sample from historical returns with replacement (bootstrap)
                for (let i = 0; i < numTrades; i++) {
                    const randomIndex = Math.floor(Math.random() * returns.length);
                    const returnPct = returns[randomIndex];

                    // Apply position sizing
                    const tradeReturn = returnPct * positionSize * balance;
                    balance += tradeReturn;

                    // Track peak and drawdown
                    if (balance > peak) {
                        peak = balance;
                    }
                    const drawdown = (peak - balance) / peak;
                    if (drawdown > maxDrawdown) {
                        maxDrawdown = drawdown;
                    }

                    equityCurve.push(balance);
                }

                finalBalances.push(balance);
                maxDrawdowns.push(maxDrawdown);

                // Store first 100 equity curves for visualization
                if (sim < 100) {
                    equityCurves.push(equityCurve);
                }
            }

            // Sort final balances for percentile calculations
            const sortedBalances = [...finalBalances].sort((a, b) => a - b);

            // Calculate statistics
            const mean = finalBalances.reduce((a, b) => a + b, 0) / finalBalances.length;
            const median = sortedBalances[Math.floor(sortedBalances.length / 2)];
            const percentile5 = sortedBalances[Math.floor(sortedBalances.length * 0.05)];
            const percentile95 = sortedBalances[Math.floor(sortedBalances.length * 0.95)];
            const percentile2_5 = sortedBalances[Math.floor(sortedBalances.length * 0.025)];
            const percentile97_5 = sortedBalances[Math.floor(sortedBalances.length * 0.975)];

            // Calculate probabilities
            const profitableSimulations = finalBalances.filter(b => b > startingBalance).length;
            const probabilityOfProfit = (profitableSimulations / numSimulations) * 100;

            const ruinedSimulations = finalBalances.filter(b => b <= startingBalance * 0.5).length;
            const riskOfRuin = (ruinedSimulations / numSimulations) * 100;

            // Create distribution histogram
            const numBins = 50;
            const minBalance = Math.min(...sortedBalances);
            const maxBalance = Math.max(...sortedBalances);
            const binSize = (maxBalance - minBalance) / numBins;

            const histogram = new Array(numBins).fill(0);
            const binLabels = [];

            for (let i = 0; i < numBins; i++) {
                binLabels.push(minBalance + (i + 0.5) * binSize);
            }

            for (const balance of finalBalances) {
                const binIndex = Math.min(Math.floor((balance - minBalance) / binSize), numBins - 1);
                histogram[binIndex]++;
            }

            // Create drawdown histogram
            const sortedDrawdowns = [...maxDrawdowns].sort((a, b) => a - b);
            const ddNumBins = 30;
            const ddHistogram = new Array(ddNumBins).fill(0);
            const ddBinLabels = [];
            const maxDD = Math.max(...sortedDrawdowns);
            const ddBinSize = maxDD / ddNumBins;

            for (let i = 0; i < ddNumBins; i++) {
                ddBinLabels.push((i + 0.5) * ddBinSize * 100); // Convert to percentage
            }

            for (const dd of maxDrawdowns) {
                const binIndex = Math.min(Math.floor(dd / ddBinSize), ddNumBins - 1);
                ddHistogram[binIndex]++;
            }

            return {
                finalBalances,
                maxDrawdowns,
                equityCurves,
                mean,
                median,
                percentile5,
                percentile95,
                percentile2_5,
                percentile97_5,
                probabilityOfProfit,
                riskOfRuin,
                histogram,
                binLabels,
                ddHistogram,
                ddBinLabels,
                startingBalance
            };
        }

        function calculatePropFirmSimulation(numSimulations, challengeBalance, profitTarget, maxDrawdown, dailyLossLimit, minTradingDays, positionSize, minTradesPerDay, maxTradesPerDay, customAvgWin, customAvgLoss) {
            const trades = appState.trades;
            const startingBalance = appState.startingBalance;

            // Determine if we use custom or historical data
            let returns;
            let actualAvgWin, actualAvgLoss;

            if (customAvgWin !== null && customAvgLoss !== null) {
                // Use custom avg win/loss to generate synthetic returns
                // Calculate win rate from historical data
                const winningTrades = trades.filter(t => (t.netPL || t.profit || 0) > 0);
                const historicalWinRate = winningTrades.length / trades.length;

                // Generate synthetic returns based on custom values
                returns = [];
                const numSyntheticTrades = Math.max(trades.length, 100); // At least 100 trades
                for (let i = 0; i < numSyntheticTrades; i++) {
                    const isWin = Math.random() < historicalWinRate;
                    const pl = isWin ? customAvgWin : customAvgLoss;
                    returns.push(pl / startingBalance); // Convert to percentage
                }
                actualAvgWin = customAvgWin;
                actualAvgLoss = customAvgLoss;
            } else {
                // Extract returns from historical trades
                returns = trades.map(trade => {
                    const pl = trade.netPL || trade.profit || 0;
                    return pl / startingBalance; // Return as percentage of starting balance
                });

                // Calculate actual avg win/loss from historical data
                const winningTrades = trades.filter(t => (t.netPL || t.profit || 0) > 0);
                const losingTrades = trades.filter(t => (t.netPL || t.profit || 0) < 0);
                actualAvgWin = winningTrades.length > 0
                    ? winningTrades.reduce((sum, t) => sum + (t.netPL || t.profit || 0), 0) / winningTrades.length
                    : 0;
                actualAvgLoss = losingTrades.length > 0
                    ? losingTrades.reduce((sum, t) => sum + (t.netPL || t.profit || 0), 0) / losingTrades.length
                    : 0;
            }

            // Track outcomes
            const outcomes = []; // 'passed', 'maxDD', 'dailyLoss'
            const daysToComplete = [];
            const finalBalances = [];
            const equityCurves = []; // Store first 50 passed and first 50 failed

            let passedCount = 0;
            let maxDDViolations = 0;
            let dailyLossViolations = 0;
            let totalDaysToPass = 0;
            let totalDaysToFail = 0;
            let totalFinalBalancePassed = 0;

            const targetBalance = challengeBalance * (1 + profitTarget);
            const maxDDThreshold = challengeBalance * maxDrawdown;

            for (let sim = 0; sim < numSimulations; sim++) {
                let balance = challengeBalance;
                let peak = challengeBalance;
                let tradingDays = 0;
                let dailyStartBalance = challengeBalance;
                let tradesInDay = 0;
                const equityCurve = [balance];

                let outcome = null;
                let reachedTarget = false;

                // Simulate until pass or fail
                let maxIterations = 1000; // Safety limit
                let iteration = 0;

                while (outcome === null && iteration < maxIterations) {
                    iteration++;

                    // Randomly select a trade
                    const randomIndex = Math.floor(Math.random() * returns.length);
                    const returnPct = returns[randomIndex];

                    // Apply position sizing
                    const tradeReturn = returnPct * positionSize * balance;
                    balance += tradeReturn;

                    // Track peak for max drawdown calculation
                    if (balance > peak) {
                        peak = balance;
                    }

                    equityCurve.push(balance);
                    tradesInDay++;

                    // Check if reached profit target
                    if (balance >= targetBalance) {
                        reachedTarget = true;
                    }

                    // Check max drawdown from initial balance (not peak)
                    const drawdownFromInitial = challengeBalance - balance;
                    if (drawdownFromInitial > maxDDThreshold) {
                        outcome = 'maxDD';
                        maxDDViolations++;
                        totalDaysToFail += tradingDays;
                        break;
                    }

                    // Simulate end of day (random number of trades between min and max)
                    const tradesPerDay = minTradesPerDay + Math.floor(Math.random() * (maxTradesPerDay - minTradesPerDay + 1));
                    if (tradesInDay >= tradesPerDay) {
                        tradingDays++;

                        // Check daily loss limit from previous day's close
                        const dailyLoss = dailyStartBalance - balance;
                        const dailyLossThreshold = dailyStartBalance * dailyLossLimit;

                        if (dailyLoss > dailyLossThreshold) {
                            outcome = 'dailyLoss';
                            dailyLossViolations++;
                            totalDaysToFail += tradingDays;
                            break;
                        }

                        // Check if passed (reached target and met min days)
                        if (reachedTarget && tradingDays >= minTradingDays) {
                            outcome = 'passed';
                            passedCount++;
                            totalDaysToPass += tradingDays;
                            totalFinalBalancePassed += balance;
                            break;
                        }

                        // Reset for next day
                        dailyStartBalance = balance;
                        tradesInDay = 0;
                    }
                }

                // If max iterations reached without outcome, consider it a fail (max DD)
                if (outcome === null) {
                    outcome = 'maxDD';
                    maxDDViolations++;
                    totalDaysToFail += tradingDays;
                }

                outcomes.push(outcome);
                daysToComplete.push(tradingDays);
                finalBalances.push(balance);

                // Store equity curves for visualization (first 25 passed, first 25 failed)
                if (outcome === 'passed' && equityCurves.filter(ec => ec.outcome === 'passed').length < 25) {
                    equityCurves.push({ curve: equityCurve, outcome: 'passed' });
                } else if (outcome !== 'passed' && equityCurves.filter(ec => ec.outcome === 'failed').length < 25) {
                    equityCurves.push({ curve: equityCurve, outcome: 'failed' });
                }
            }

            // Calculate statistics
            const successRate = (passedCount / numSimulations) * 100;
            const maxDDRate = (maxDDViolations / numSimulations) * 100;
            const dailyLossRate = (dailyLossViolations / numSimulations) * 100;
            const avgDaysToPass = passedCount > 0 ? totalDaysToPass / passedCount : 0;
            const avgDaysToFail = (maxDDViolations + dailyLossViolations) > 0 ? totalDaysToFail / (maxDDViolations + dailyLossViolations) : 0;
            const avgFinalBalancePassed = passedCount > 0 ? totalFinalBalancePassed / passedCount : 0;

            // avgTradeProfit and avgTradeLoss are already calculated as actualAvgWin and actualAvgLoss above
            // (either from custom values or historical data)

            // Create days distribution
            const maxDays = Math.max(...daysToComplete);
            const daysHistogram = new Array(Math.min(maxDays + 1, 50)).fill(0);
            const daysBinLabels = Array.from({ length: daysHistogram.length }, (_, i) => i);

            for (const days of daysToComplete) {
                const binIndex = Math.min(days, daysHistogram.length - 1);
                daysHistogram[binIndex]++;
            }

            return {
                successRate,
                maxDDRate,
                dailyLossRate,
                avgDaysToPass,
                avgDaysToFail,
                avgFinalBalancePassed,
                avgTradeProfit: actualAvgWin,
                avgTradeLoss: actualAvgLoss,
                outcomes,
                daysToComplete,
                finalBalances,
                equityCurves,
                daysHistogram,
                daysBinLabels,
                challengeBalance,
                targetBalance,
                passedCount,
                maxDDViolations,
                dailyLossViolations
            };
        }

        function displayMonteCarloResults(results) {
            // Show results section, hide others
            document.getElementById('monteCarloResults').style.display = 'block';
            document.getElementById('propFirmResults').style.display = 'none';
            document.getElementById('monteCarloPlaceholder').style.display = 'none';
            document.getElementById('monteCarloLoading').style.display = 'none';

            // Format currency
            const fmt = (val) => `$${val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

            // Update statistics
            document.getElementById('mcExpectedBalance').textContent = fmt(results.mean);
            document.getElementById('mcConfidenceInterval').textContent =
                `${fmt(results.percentile2_5)} - ${fmt(results.percentile97_5)}`;
            document.getElementById('mcProfitProb').textContent =
                `${results.probabilityOfProfit.toFixed(1)}%`;
            document.getElementById('mcRiskOfRuin').textContent =
                `${results.riskOfRuin.toFixed(1)}%`;
            document.getElementById('mcBestCase').textContent = fmt(results.percentile95);
            document.getElementById('mcWorstCase').textContent = fmt(results.percentile5);

            // Color code based on profitability
            const expectedBalanceEl = document.getElementById('mcExpectedBalance');
            if (results.mean > results.startingBalance) {
                expectedBalanceEl.style.color = 'var(--color-positive)';
            } else {
                expectedBalanceEl.style.color = 'var(--color-negative)';
            }

            const profitProbEl = document.getElementById('mcProfitProb');
            if (results.probabilityOfProfit > 50) {
                profitProbEl.style.color = 'var(--color-positive)';
            } else {
                profitProbEl.style.color = 'var(--color-negative)';
            }

            const riskEl = document.getElementById('mcRiskOfRuin');
            if (results.riskOfRuin > 10) {
                riskEl.style.color = 'var(--color-negative)';
            } else if (results.riskOfRuin > 5) {
                riskEl.style.color = 'var(--color-orange-400)';
            } else {
                riskEl.style.color = 'var(--color-positive)';
            }
        }

        function drawMonteCarloCharts(results) {
            // Destroy existing charts
            if (appState.chartInstances.mcDistribution) {
                appState.chartInstances.mcDistribution.destroy();
            }
            if (appState.chartInstances.mcEquity) {
                appState.chartInstances.mcEquity.destroy();
            }
            if (appState.chartInstances.mcDrawdown) {
                appState.chartInstances.mcDrawdown.destroy();
            }

            const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const textColor = isDarkMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

            // 1. Distribution Chart
            const ctxDist = document.getElementById('mcDistributionChart').getContext('2d');
            appState.chartInstances.mcDistribution = new Chart(ctxDist, {
                type: 'bar',
                data: {
                    labels: results.binLabels.map(val => `$${Math.round(val).toLocaleString()}`),
                    datasets: [{
                        label: 'Frequency',
                        data: results.histogram,
                        backgroundColor: 'rgba(33, 128, 141, 0.6)',
                        borderColor: 'rgba(33, 128, 141, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Balance: ${items[0].label}`,
                                label: (item) => `Simulations: ${item.parsed.y}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            },
                            grid: {
                                color: gridColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Number of Simulations',
                                color: textColor
                            }
                        }
                    }
                }
            });

            // 2. Equity Curves Chart
            const ctxEquity = document.getElementById('mcEquityChart').getContext('2d');
            const datasets = results.equityCurves.map((curve, index) => ({
                label: `Simulation ${index + 1}`,
                data: curve,
                borderColor: `rgba(33, 128, 141, ${0.05 + (0.15 * Math.random())})`,
                borderWidth: 1,
                fill: false,
                pointRadius: 0,
                tension: 0.1
            }));

            // Add starting balance line
            datasets.push({
                label: 'Starting Balance',
                data: new Array(results.equityCurves[0].length).fill(results.startingBalance),
                borderColor: 'rgba(255, 255, 255, 0.5)',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
            });

            appState.chartInstances.mcEquity = new Chart(ctxEquity, {
                type: 'line',
                data: {
                    labels: Array.from({ length: results.equityCurves[0].length }, (_, i) => i),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Trade Number',
                                color: textColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Account Balance',
                                color: textColor
                            }
                        }
                    }
                }
            });

            // 3. Drawdown Distribution Chart
            const ctxDD = document.getElementById('mcDrawdownChart').getContext('2d');
            appState.chartInstances.mcDrawdown = new Chart(ctxDD, {
                type: 'bar',
                data: {
                    labels: results.ddBinLabels.map(val => `${val.toFixed(1)}%`),
                    datasets: [{
                        label: 'Frequency',
                        data: results.ddHistogram,
                        backgroundColor: 'rgba(192, 21, 47, 0.6)',
                        borderColor: 'rgba(192, 21, 47, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Max Drawdown: ${items[0].label}`,
                                label: (item) => `Simulations: ${item.parsed.y}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor,
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 10
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Maximum Drawdown (%)',
                                color: textColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Number of Simulations',
                                color: textColor
                            }
                        }
                    }
                }
            });
        }

        function displayPropFirmResults(results) {
            // Show results section, hide others
            document.getElementById('propFirmResults').style.display = 'block';
            document.getElementById('monteCarloResults').style.display = 'none';
            document.getElementById('monteCarloPlaceholder').style.display = 'none';
            document.getElementById('monteCarloLoading').style.display = 'none';

            // Format currency
            const fmt = (val) => `$${val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

            // Update statistics
            document.getElementById('pfSuccessRate').textContent = `${results.successRate.toFixed(1)}%`;
            document.getElementById('pfAvgDaysPass').textContent = results.avgDaysToPass > 0 ? results.avgDaysToPass.toFixed(1) : 'N/A';
            document.getElementById('pfAvgDaysFail').textContent = results.avgDaysToFail > 0 ? results.avgDaysToFail.toFixed(1) : 'N/A';
            document.getElementById('pfMaxDDViolations').textContent = `${results.maxDDRate.toFixed(1)}%`;
            document.getElementById('pfDailyLossViolations').textContent = `${results.dailyLossRate.toFixed(1)}%`;
            document.getElementById('pfAvgFinalBalance').textContent = results.avgFinalBalancePassed > 0 ? fmt(results.avgFinalBalancePassed) : 'N/A';
            document.getElementById('pfAvgTradeProfit').textContent = fmt(results.avgTradeProfit);
            document.getElementById('pfAvgTradeLoss').textContent = fmt(results.avgTradeLoss);

            // Color code success rate
            const successRateEl = document.getElementById('pfSuccessRate');
            if (results.successRate >= 50) {
                successRateEl.style.color = 'var(--color-positive)';
            } else if (results.successRate >= 25) {
                successRateEl.style.color = 'var(--color-orange-400)';
            } else {
                successRateEl.style.color = 'var(--color-negative)';
            }

            // Color code average profit/loss
            const avgProfitEl = document.getElementById('pfAvgTradeProfit');
            avgProfitEl.style.color = results.avgTradeProfit > 0 ? 'var(--color-positive)' : 'var(--color-text)';

            const avgLossEl = document.getElementById('pfAvgTradeLoss');
            avgLossEl.style.color = results.avgTradeLoss < 0 ? 'var(--color-negative)' : 'var(--color-text)';

            // Display outcome breakdown
            const breakdownEl = document.getElementById('pfOutcomeBreakdown');
            breakdownEl.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-8);">‚úÖ Passed Challenges</div>
                        <div style="font-size: var(--font-size-lg); color: var(--color-success); margin-bottom: var(--space-4);">${results.passedCount} / ${results.outcomes.length}</div>
                        <div style="font-size: var(--font-size-xs);">Success rate: ${results.successRate.toFixed(1)}%</div>
                    </div>
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-8);">‚ùå Max Drawdown Violations</div>
                        <div style="font-size: var(--font-size-lg); color: var(--color-error); margin-bottom: var(--space-4);">${results.maxDDViolations} / ${results.outcomes.length}</div>
                        <div style="font-size: var(--font-size-xs);">Violation rate: ${results.maxDDRate.toFixed(1)}%</div>
                    </div>
                    <div>
                        <div style="font-weight: var(--font-weight-semibold); color: var(--color-text); margin-bottom: var(--space-8);">‚ö†Ô∏è Daily Loss Violations</div>
                        <div style="font-size: var(--font-size-lg); color: var(--color-error); margin-bottom: var(--space-4);">${results.dailyLossViolations} / ${results.outcomes.length}</div>
                        <div style="font-size: var(--font-size-xs);">Violation rate: ${results.dailyLossRate.toFixed(1)}%</div>
                    </div>
                </div>
                <div style="margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border); font-style: italic; font-size: var(--font-size-xs);">
                    Based on ${results.outcomes.length} simulations using your historical trading statistics.
                </div>
            `;
        }

        function drawPropFirmCharts(results) {
            // Destroy existing charts
            if (appState.chartInstances.pfOutcome) {
                appState.chartInstances.pfOutcome.destroy();
            }
            if (appState.chartInstances.pfEquity) {
                appState.chartInstances.pfEquity.destroy();
            }
            if (appState.chartInstances.pfDays) {
                appState.chartInstances.pfDays.destroy();
            }

            const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const textColor = isDarkMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
            const gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';

            // 1. Outcome Distribution Chart (Pie Chart)
            const ctxOutcome = document.getElementById('pfOutcomeChart').getContext('2d');
            appState.chartInstances.pfOutcome = new Chart(ctxOutcome, {
                type: 'pie',
                data: {
                    labels: ['Passed', 'Max DD Violation', 'Daily Loss Violation'],
                    datasets: [{
                        data: [results.passedCount, results.maxDDViolations, results.dailyLossViolations],
                        backgroundColor: [
                            'rgba(34, 197, 94, 0.8)',
                            'rgba(239, 68, 68, 0.8)',
                            'rgba(251, 146, 60, 0.8)'
                        ],
                        borderColor: [
                            'rgba(34, 197, 94, 1)',
                            'rgba(239, 68, 68, 1)',
                            'rgba(251, 146, 60, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: textColor,
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (item) => {
                                    const total = results.outcomes.length;
                                    const value = item.parsed;
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${item.label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });

            // 2. Equity Curves Chart
            const ctxEquity = document.getElementById('pfEquityChart').getContext('2d');
            const datasets = [];

            // Add passed equity curves in green
            results.equityCurves.filter(ec => ec.outcome === 'passed').forEach((ec, index) => {
                datasets.push({
                    label: `Passed ${index + 1}`,
                    data: ec.curve,
                    borderColor: `rgba(34, 197, 94, ${0.2 + (0.3 * Math.random())})`,
                    borderWidth: 1.5,
                    fill: false,
                    pointRadius: 0,
                    tension: 0.1
                });
            });

            // Add failed equity curves in red
            results.equityCurves.filter(ec => ec.outcome === 'failed').forEach((ec, index) => {
                datasets.push({
                    label: `Failed ${index + 1}`,
                    data: ec.curve,
                    borderColor: `rgba(239, 68, 68, ${0.2 + (0.3 * Math.random())})`,
                    borderWidth: 1.5,
                    fill: false,
                    pointRadius: 0,
                    tension: 0.1
                });
            });

            // Add target line
            const maxLength = Math.max(...results.equityCurves.map(ec => ec.curve.length));
            datasets.push({
                label: 'Profit Target',
                data: new Array(maxLength).fill(results.targetBalance),
                borderColor: 'rgba(74, 222, 128, 0.8)',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
            });

            // Add starting balance line
            datasets.push({
                label: 'Starting Balance',
                data: new Array(maxLength).fill(results.challengeBalance),
                borderColor: 'rgba(255, 255, 255, 0.5)',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0
            });

            appState.chartInstances.pfEquity = new Chart(ctxEquity, {
                type: 'line',
                data: {
                    labels: Array.from({ length: maxLength }, (_, i) => i),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Trade Number',
                                color: textColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor,
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Account Balance',
                                color: textColor
                            }
                        }
                    }
                }
            });

            // 3. Days to Complete Distribution
            const ctxDays = document.getElementById('pfDaysChart').getContext('2d');
            appState.chartInstances.pfDays = new Chart(ctxDays, {
                type: 'bar',
                data: {
                    labels: results.daysBinLabels,
                    datasets: [{
                        label: 'Frequency',
                        data: results.daysHistogram,
                        backgroundColor: 'rgba(33, 128, 141, 0.6)',
                        borderColor: 'rgba(33, 128, 141, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => `Days: ${items[0].label}`,
                                label: (item) => `Simulations: ${item.parsed.y}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: textColor,
                                autoSkip: true,
                                maxTicksLimit: 20
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Trading Days',
                                color: textColor
                            }
                        },
                        y: {
                            ticks: {
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            title: {
                                display: true,
                                text: 'Number of Simulations',
                                color: textColor
                            }
                        }
                    }
                }
            });
        }

        // Performance Breakdowns
        function updatePerformanceBreakdowns() {
            updateBreakdownMonthDisplay();
            updateSetupBreakdown();
            updateMarketBreakdown();
            updateEmotionalBreakdown();
            updateRuleBreakdown();
        }
        
        function updateSetupBreakdown() {
            const container = document.getElementById('setupBreakdown');

            // Calculate TOTAL (all trades) breakdowns
            const totalBreakdowns = {};
            setupTypes.forEach(setup => {
                const trades = appState.trades.filter(t => t.setupType === setup);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                totalBreakdowns[setup] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            // Calculate selected month breakdowns
            let monthBreakdowns = null;
            let hasMonthData = false;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                const filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });

                monthBreakdowns = {};
                setupTypes.forEach(setup => {
                    const trades = filteredTrades.filter(t => t.setupType === setup);
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                    monthBreakdowns[setup] = {
                        trades: trades.length,
                        winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                        totalPL: totalPL
                    };
                });

                hasMonthData = Object.values(monthBreakdowns).some(d => d.trades > 0);
            }

            const renderBreakdownCards = (breakdowns, isTotal = false) => Object.entries(breakdowns).map(([setup, data]) => `
                <div class="breakdown-item" style="${isTotal ? 'border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header">${setup}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${renderBreakdownCards(totalBreakdowns, true)}
                    </div>
                </div>
                ${hasMonthData ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${renderBreakdownCards(monthBreakdowns, false)}
                        </div>
                    </div>
                ` : (appState.breakdownCurrentMonth !== -1 ? '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>' : '')}
            `;
        }
        
        function updateMarketBreakdown() {
            const container = document.getElementById('marketBreakdown');

            // Calculate TOTAL (all trades) breakdowns
            const totalBreakdowns = {};
            marketConditions.forEach(condition => {
                const trades = appState.trades.filter(t => t.marketCondition === condition);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                totalBreakdowns[condition] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            // Calculate selected month breakdowns
            let monthBreakdowns = null;
            let hasMonthData = false;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                const filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });

                monthBreakdowns = {};
                marketConditions.forEach(condition => {
                    const trades = filteredTrades.filter(t => t.marketCondition === condition);
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                    monthBreakdowns[condition] = {
                        trades: trades.length,
                        winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                        totalPL: totalPL
                    };
                });

                hasMonthData = Object.values(monthBreakdowns).some(d => d.trades > 0);
            }

            const renderBreakdownCards = (breakdowns, isTotal = false) => Object.entries(breakdowns).map(([condition, data]) => `
                <div class="breakdown-item" style="${isTotal ? 'border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header">${condition}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${renderBreakdownCards(totalBreakdowns, true)}
                    </div>
                </div>
                ${hasMonthData ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${renderBreakdownCards(monthBreakdowns, false)}
                        </div>
                    </div>
                ` : (appState.breakdownCurrentMonth !== -1 ? '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>' : '')}
            `;
        }

        function updateEmotionalBreakdown() {
            const container = document.getElementById('emotionalBreakdown');

            // Calculate TOTAL (all trades) breakdowns
            const totalBreakdowns = {};
            emotionalStates.forEach(state => {
                const trades = appState.trades.filter(t => t.emotionalState === state);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                totalBreakdowns[state] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            // Calculate selected month breakdowns
            let monthBreakdowns = null;
            let hasMonthData = false;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                const filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });

                monthBreakdowns = {};
                emotionalStates.forEach(state => {
                    const trades = filteredTrades.filter(t => t.emotionalState === state);
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                    monthBreakdowns[state] = {
                        trades: trades.length,
                        winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                        totalPL: totalPL
                    };
                });

                hasMonthData = Object.values(monthBreakdowns).some(d => d.trades > 0);
            }

            const renderBreakdownCards = (breakdowns, isTotal = false) => Object.entries(breakdowns).map(([state, data]) => `
                <div class="breakdown-item" style="${isTotal ? 'border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header">${state}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${renderBreakdownCards(totalBreakdowns, true)}
                    </div>
                </div>
                ${hasMonthData ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${renderBreakdownCards(monthBreakdowns, false)}
                        </div>
                    </div>
                ` : (appState.breakdownCurrentMonth !== -1 ? '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>' : '')}
            `;
        }

        function updateRuleBreakdown() {
            const container = document.getElementById('ruleBreakdown');

            // Calculate TOTAL (all trades) breakdowns
            const totalBreakdowns = {};
            ruleAdherence.forEach(adherence => {
                const trades = appState.trades.filter(t => t.ruleAdherence === adherence);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                totalBreakdowns[adherence] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            // Calculate selected month breakdowns
            let monthBreakdowns = null;
            let hasMonthData = false;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                const filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });

                monthBreakdowns = {};
                ruleAdherence.forEach(adherence => {
                    const trades = filteredTrades.filter(t => t.ruleAdherence === adherence);
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                    monthBreakdowns[adherence] = {
                        trades: trades.length,
                        winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                        totalPL: totalPL
                    };
                });

                hasMonthData = Object.values(monthBreakdowns).some(d => d.trades > 0);
            }

            const renderBreakdownCards = (breakdowns, isTotal = false) => Object.entries(breakdowns).map(([adherence, data]) => `
                <div class="breakdown-item" style="${isTotal ? 'border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header">${adherence}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${renderBreakdownCards(totalBreakdowns, true)}
                    </div>
                </div>
                ${hasMonthData ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${renderBreakdownCards(monthBreakdowns, false)}
                        </div>
                    </div>
                ` : (appState.breakdownCurrentMonth !== -1 ? '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>' : '')}
            `;
        }

        // Time Analytics
        function updateTimeAnalytics() {
            updateMonthlyStats();
            updateDailyStats();
            updateOpenHourlyStats();
            updateHourlyStats();
        }
        
        function updateMonthlyStats() {
            const container = document.getElementById('monthlyStats');
            const monthlyData = {};

            // Aggregate trades by month
            appState.trades.forEach(trade => {
                const month = trade.date.substring(0, 7); // YYYY-MM
                if (!monthlyData[month]) {
                    monthlyData[month] = {
                        trades: [],
                        wins: [],
                        losses: []
                    };
                }

                const pl = (trade.netPL || trade.profit);
                monthlyData[month].trades.push(trade);

                if (pl > 0) {
                    monthlyData[month].wins.push(trade);
                } else if (pl < 0) {
                    monthlyData[month].losses.push(trade);
                }
            });

            // Calculate detailed statistics for each month
            const monthlyStats = Object.entries(monthlyData).map(([month, data]) => {
                const totalTrades = data.trades.length;
                const winCount = data.wins.length;
                const lossCount = data.losses.length;
                const winRate = totalTrades > 0 ? (winCount / totalTrades * 100) : 0;

                const totalProfit = data.wins.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                const totalLoss = Math.abs(data.losses.reduce((sum, t) => sum + (t.netPL || t.profit), 0));
                const netPL = data.trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                const avgWin = winCount > 0 ? (totalProfit / winCount) : 0;
                const avgLoss = lossCount > 0 ? (totalLoss / lossCount) : 0;
                const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss) : 0;
                const riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;

                // Calculate max drawdown for the month
                const sortedTrades = [...data.trades].sort((a, b) => {
                    const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                    const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                    return dateA - dateB;
                });

                let runningPL = 0;
                let peak = 0;
                let maxDrawdown = 0;

                sortedTrades.forEach(trade => {
                    const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                    runningPL += tradePL;

                    if (runningPL > peak) {
                        peak = runningPL;
                    }

                    const drawdown = peak - runningPL;
                    if (drawdown > maxDrawdown) {
                        maxDrawdown = drawdown;
                    }
                });

                return {
                    month,
                    totalTrades,
                    winCount,
                    lossCount,
                    winRate,
                    netPL,
                    totalProfit,
                    totalLoss,
                    avgWin,
                    avgLoss,
                    profitFactor,
                    riskRewardRatio,
                    maxDrawdown
                };
            });

            // Calculate TOTAL statistics
            const allTrades = appState.trades;
            const allWins = allTrades.filter(t => (t.netPL || t.profit) > 0);
            const allLosses = allTrades.filter(t => (t.netPL || t.profit) < 0);

            const totalStats = {
                month: 'TOTAL',
                totalTrades: allTrades.length,
                winCount: allWins.length,
                lossCount: allLosses.length,
                winRate: allTrades.length > 0 ? (allWins.length / allTrades.length * 100) : 0,
                netPL: allTrades.reduce((sum, t) => sum + (t.netPL || t.profit), 0),
                totalProfit: allWins.reduce((sum, t) => sum + (t.netPL || t.profit), 0),
                totalLoss: Math.abs(allLosses.reduce((sum, t) => sum + (t.netPL || t.profit), 0)),
                avgWin: allWins.length > 0 ? (allWins.reduce((sum, t) => sum + (t.netPL || t.profit), 0) / allWins.length) : 0,
                avgLoss: allLosses.length > 0 ? (Math.abs(allLosses.reduce((sum, t) => sum + (t.netPL || t.profit), 0)) / allLosses.length) : 0,
                profitFactor: 0,
                riskRewardRatio: 0,
                maxDrawdown: appState.statistics?.maxDrawdown || 0
            };

            totalStats.profitFactor = totalStats.totalLoss > 0 ? (totalStats.totalProfit / totalStats.totalLoss) : 0;
            totalStats.riskRewardRatio = totalStats.avgLoss > 0 ? (totalStats.avgWin / totalStats.avgLoss) : 0;

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Filter to show only the selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const selectedMonthStats = monthlyStats.find(stats => stats.month === selectedMonthKey);

            // Render the monthly stats with TOTAL at the top
            const renderMonthCard = (stats, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.2em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL (All Time)' : stats.month}</div>
                    <div class="breakdown-stats" style="font-size: 0.9em;">
                        <strong>Trades:</strong> ${stats.totalTrades} (${stats.winCount}W / ${stats.lossCount}L)<br>
                        <strong>Win Rate:</strong> ${stats.winRate.toFixed(1)}%<br>
                        <strong>Net P&L:</strong> <span class="${stats.netPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(stats.netPL)}</span><br>
                        <strong>Profit Factor:</strong> ${stats.profitFactor.toFixed(2)}<br>
                        <strong>Avg Win:</strong> <span class="positive">${formatCurrency(stats.avgWin)}</span><br>
                        <strong>Avg Loss:</strong> <span class="negative">${formatCurrency(stats.avgLoss)}</span><br>
                        <strong>R:R Ratio:</strong> ${stats.riskRewardRatio.toFixed(2)}<br>
                        <strong>Max DD:</strong> <span class="negative">${formatCurrency(stats.maxDrawdown)}</span>
                    </div>
                </div>
            `;

            container.innerHTML = `
                <div class="breakdown-grid">
                    ${renderMonthCard(totalStats, true)}
                    ${selectedMonthStats ? renderMonthCard(selectedMonthStats, false) : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
                </div>
            `;
        }
        
        function updateDailyStats() {
            const container = document.getElementById('dailyStats');
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Calculate TOTAL (all trades)
            const totalDailyData = {};
            daysOfWeek.forEach(day => {
                totalDailyData[day] = { trades: 0, profit: 0, wins: 0 };
            });

            appState.trades.forEach(trade => {
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const dayOfWeek = daysOfWeek[tradeDate.getDay()];
                totalDailyData[dayOfWeek].trades++;
                totalDailyData[dayOfWeek].profit += (trade.netPL || trade.profit);
                if ((trade.netPL || trade.profit) > 0) totalDailyData[dayOfWeek].wins++;
            });

            // Filter trades for selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const monthlyDailyData = {};
            daysOfWeek.forEach(day => {
                monthlyDailyData[day] = { trades: 0, profit: 0, wins: 0 };
            });

            appState.trades.forEach(trade => {
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const tradeMonth = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;

                if (tradeMonth === selectedMonthKey) {
                    const dayOfWeek = daysOfWeek[tradeDate.getDay()];
                    monthlyDailyData[dayOfWeek].trades++;
                    monthlyDailyData[dayOfWeek].profit += (trade.netPL || trade.profit);
                    if ((trade.netPL || trade.profit) > 0) monthlyDailyData[dayOfWeek].wins++;
                }
            });

            // Render function
            const renderDayCard = (day, data, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.1em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL - ' : ''}${day}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: ${data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(1) : '0.0'}%<br>
                        P&L: <span class="${data.profit >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.profit)}</span>
                    </div>
                </div>
            `;

            const hasMonthData = Object.values(monthlyDailyData).some(d => d.trades > 0);

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${daysOfWeek.map(day => renderDayCard(day, totalDailyData[day], true)).join('')}
                    </div>
                </div>
                ${hasMonthData ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${daysOfWeek.map(day => renderDayCard(day, monthlyDailyData[day], false)).join('')}
                        </div>
                    </div>
                ` : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
            `;
        }

        function updateOpenHourlyStats() {
            const container = document.getElementById('openHourlyStats');

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Calculate TOTAL (all trades)
            const totalHourlyData = {};
            for (let i = 0; i < 24; i++) {
                totalHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                if (trade.openTime) {
                    const hour = parseInt(trade.openTime.split(':')[0]);
                    totalHourlyData[hour].trades++;
                    totalHourlyData[hour].profit += (trade.netPL || trade.profit);
                    if ((trade.netPL || trade.profit) > 0) totalHourlyData[hour].wins++;
                }
            });

            // Filter trades for selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const monthlyHourlyData = {};
            for (let i = 0; i < 24; i++) {
                monthlyHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                if (trade.openTime) {
                    const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                    const tradeMonth = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;

                    if (tradeMonth === selectedMonthKey) {
                        const hour = parseInt(trade.openTime.split(':')[0]);
                        monthlyHourlyData[hour].trades++;
                        monthlyHourlyData[hour].profit += (trade.netPL || trade.profit);
                        if ((trade.netPL || trade.profit) > 0) monthlyHourlyData[hour].wins++;
                    }
                }
            });

            // Render function
            const renderHourCard = (hour, data, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.1em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL - ' : ''}${hour}:00</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: ${data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(1) : '0.0'}%<br>
                        P&L: <span class="${data.profit >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.profit)}</span>
                    </div>
                </div>
            `;

            // Only show hours with trades
            const activeTotalHours = Object.entries(totalHourlyData).filter(([hour, data]) => data.trades > 0);
            const activeMonthHours = Object.entries(monthlyHourlyData).filter(([hour, data]) => data.trades > 0);

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${activeTotalHours.map(([hour, data]) => renderHourCard(hour, data, true)).join('')}
                    </div>
                </div>
                ${activeMonthHours.length > 0 ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${activeMonthHours.map(([hour, data]) => renderHourCard(hour, data, false)).join('')}
                        </div>
                    </div>
                ` : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
            `;
        }

        function updateHourlyStats() {
            const container = document.getElementById('hourlyStats');

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Calculate TOTAL (all trades)
            const totalHourlyData = {};
            for (let i = 0; i < 24; i++) {
                totalHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                const hour = parseInt(trade.time.split(':')[0]);
                totalHourlyData[hour].trades++;
                totalHourlyData[hour].profit += (trade.netPL || trade.profit);
                if ((trade.netPL || trade.profit) > 0) totalHourlyData[hour].wins++;
            });

            // Filter trades for selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const monthlyHourlyData = {};
            for (let i = 0; i < 24; i++) {
                monthlyHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const tradeMonth = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;

                if (tradeMonth === selectedMonthKey) {
                    const hour = parseInt(trade.time.split(':')[0]);
                    monthlyHourlyData[hour].trades++;
                    monthlyHourlyData[hour].profit += (trade.netPL || trade.profit);
                    if ((trade.netPL || trade.profit) > 0) monthlyHourlyData[hour].wins++;
                }
            });

            // Render function
            const renderHourCard = (hour, data, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.1em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL - ' : ''}${hour}:00</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: ${data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(1) : '0.0'}%<br>
                        P&L: <span class="${data.profit >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.profit)}</span>
                    </div>
                </div>
            `;

            // Only show hours with trades
            const activeTotalHours = Object.entries(totalHourlyData).filter(([hour, data]) => data.trades > 0);
            const activeMonthHours = Object.entries(monthlyHourlyData).filter(([hour, data]) => data.trades > 0);

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${activeTotalHours.map(([hour, data]) => renderHourCard(hour, data, true)).join('')}
                    </div>
                </div>
                ${activeMonthHours.length > 0 ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${activeMonthHours.map(([hour, data]) => renderHourCard(hour, data, false)).join('')}
                        </div>
                    </div>
                ` : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
            `;
        }
        
        // Calendar View
        function updateCalendarView() {
            updateCalendarMonth();
            renderCalendar();
        }
        
        function updateCalendarMonth() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            document.getElementById('calendarMonth').textContent = 
                `${monthNames[appState.currentMonth]} ${appState.currentYear}`;
        }
        
        // CORRECTED: Calendar generation with proper date alignment
        function generateCalendar(year, month, trades) {
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            // Create array with empty cells for alignment
            const calendar = Array(firstDay).fill(null);
            
            // Add days with trade data
            for (let day = 1; day <= daysInMonth; day++) {
                const dayTrades = trades.filter(t => {
                    const tradeDate = new Date(t.closeTime || `${t.date}T${t.time}:00`);
                    return tradeDate.getDate() === day && 
                           tradeDate.getMonth() === month &&
                           tradeDate.getFullYear() === year;
                });
                
                const dayPL = dayTrades.reduce((sum, t) => sum + (parseFloat(t.netPL) || parseFloat(t.profit) || 0), 0);
                
                calendar.push({
                    day: day,
                    trades: dayTrades.length,
                    pl: dayPL,
                    color: dayPL > 0 ? 'profit' : dayPL < 0 ? 'loss' : 'neutral'
                });
            }
            
            return calendar;
        }
        
        function renderCalendar() {
            const calendar = document.getElementById('calendar');

            if (!calendar) {
                console.warn('Calendar element not found');
                return;
            }

            const firstDay = new Date(appState.currentYear, appState.currentMonth, 1).getDay();
            const daysInMonth = new Date(appState.currentYear, appState.currentMonth + 1, 0).getDate();

            // Initialize monthly totals
            let monthTotalWins = 0;
            let monthTotalLosses = 0;
            let monthTotalPL = 0;

            // Group trades by date
            const monthlyTrades = {};
            appState.trades.forEach(trade => {
                try {
                    const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                    if (tradeDate.getMonth() === appState.currentMonth && tradeDate.getFullYear() === appState.currentYear) {
                        const day = tradeDate.getDate();
                        const pl = (parseFloat(trade.netPL) || parseFloat(trade.profit) || 0);

                        if (!monthlyTrades[day]) {
                            monthlyTrades[day] = { count: 0, profit: 0, wins: 0, losses: 0 };
                        }
                        monthlyTrades[day].count++;
                        monthlyTrades[day].profit += pl;

                        if (pl > 0) {
                            monthlyTrades[day].wins++;
                            monthTotalWins++;
                        } else if (pl < 0) {
                            monthlyTrades[day].losses++;
                            monthTotalLosses++;
                        }

                        monthTotalPL += pl;
                    }
                } catch (error) {
                    console.warn('Error processing trade date for calendar:', error, trade);
                }
            });

            let html = '';

            // Add day headers with week stats header
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Week'];
            dayHeaders.forEach(day => {
                html += `<div style="text-align: center; font-weight: bold; padding: 0.5rem; color: #94a3b8;">${day}</div>`;
            });

            // Track current week stats
            let weekWins = 0;
            let weekLosses = 0;
            let weekPL = 0;

            // Add empty cells for days before month start
            for (let i = 0; i < firstDay; i++) {
                html += '<div class="calendar-day"></div>';
            }

            // Add days of month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayData = monthlyTrades[day];
                let className = 'calendar-day';
                let title = `${day}`;
                let content = day.toString();

                if (dayData) {
                    className += ' has-trades';
                    className += dayData.profit >= 0 ? ' profit' : ' loss';
                    title = `${day} - ${dayData.wins}W/${dayData.losses}L (${dayData.count} trade${dayData.count > 1 ? 's' : ''}), P&L: ${formatCurrency(dayData.profit)}`;
                    content += `<br><small style="font-size: 10px; line-height: 1.2;">${dayData.wins}W/${dayData.losses}L<br>${formatCurrency(dayData.profit)}</small>`;

                    // Add to week totals
                    weekWins += dayData.wins;
                    weekLosses += dayData.losses;
                    weekPL += dayData.profit;
                }

                html += `<div class="${className}" title="${title}">${content}</div>`;

                // Calculate current day of week (0=Sun, 6=Sat)
                const currentDayOfWeek = (firstDay + day - 1) % 7;

                // End of week (Saturday = 6) or end of month
                if (currentDayOfWeek === 6 || day === daysInMonth) {
                    // If it's end of month but not Saturday, fill remaining days
                    if (day === daysInMonth && currentDayOfWeek !== 6) {
                        const remainingInWeek = 6 - currentDayOfWeek;
                        for (let i = 0; i < remainingInWeek; i++) {
                            html += '<div class="calendar-day"></div>';
                        }
                    }

                    // Add weekly summary - CENTERED
                    const weekColor = weekPL >= 0 ? 'var(--color-success)' : 'var(--color-error)';
                    const weekBgColor = weekPL > 0 ? 'rgba(16, 185, 129, 0.2)' : weekPL < 0 ? 'rgba(239, 68, 68, 0.2)' : 'transparent';
                    const weekTextColor = weekPL > 0 ? '#10b981' : weekPL < 0 ? '#ef4444' : '#94a3b8';
                    html += `
                        <div style="aspect-ratio: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 4px; font-size: 0.75rem; position: relative; min-height: 40px; border: 1px solid transparent; background: ${weekBgColor}; color: ${weekTextColor}; text-align: center; padding: 0.5rem;">
                            <div style="font-weight: bold;">${weekWins}W/${weekLosses}L</div>
                            <div style="font-weight: bold; margin-top: 2px;">${formatCurrency(weekPL)}</div>
                        </div>
                    `;

                    // Reset week counters
                    weekWins = 0;
                    weekLosses = 0;
                    weekPL = 0;
                }
            }

            // Add monthly summary
            const monthTotalTrades = monthTotalWins + monthTotalLosses;
            const monthWinRate = monthTotalTrades > 0 ? ((monthTotalWins / monthTotalTrades) * 100).toFixed(1) : '0.0';

            html += `
                <div style="grid-column: 1 / -1; margin-top: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); text-align: center;">
                    <div style="font-weight: var(--font-weight-semibold); margin-bottom: 0.5rem; font-size: var(--font-size-md);">Month Total</div>
                    <div style="display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">W/L</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold);">
                                <span style="color: var(--color-success);">${monthTotalWins}W</span> / <span style="color: var(--color-error);">${monthTotalLosses}L</span>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">P&L</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: ${monthTotalPL >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">
                                ${formatCurrency(monthTotalPL)}
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Win Rate</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold);">
                                ${monthWinRate}%
                            </div>
                        </div>
                    </div>
                </div>
            `;

            calendar.innerHTML = html;
        }
        function changeMonth(direction) {
            appState.currentMonth += direction;
            if (appState.currentMonth < 0) {
                appState.currentMonth = 11;
                appState.currentYear--;
            } else if (appState.currentMonth > 11) {
                appState.currentMonth = 0;
                appState.currentYear++;
            }
            updateCalendarView();
        }

        // Monthly Analytics Navigation
        function changeAnalyticsMonth(direction) {
            // If currently at TOTAL (-1) and going forward, go to the first month with trades
            // If going backward from TOTAL, stay at TOTAL
            if (appState.analyticsCurrentMonth === -1) {
                if (direction > 0) {
                    // Find the first month with trades
                    const firstTradeDate = appState.trades.length > 0
                        ? new Date(appState.trades.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date)
                        : new Date();
                    appState.analyticsCurrentMonth = firstTradeDate.getMonth();
                    appState.analyticsCurrentYear = firstTradeDate.getFullYear();
                } else {
                    // Stay at TOTAL when going backward
                    return;
                }
            } else {
                appState.analyticsCurrentMonth += direction;
                if (appState.analyticsCurrentMonth < 0) {
                    appState.analyticsCurrentMonth = 11;
                    appState.analyticsCurrentYear--;
                } else if (appState.analyticsCurrentMonth > 11) {
                    appState.analyticsCurrentMonth = 0;
                    appState.analyticsCurrentYear++;
                }
            }
            updateAnalyticsMonthDisplay();
            updateMonthlyStats();
            updateDailyStats();
            updateOpenHourlyStats();
            updateHourlyStats();
            updateStatisticsDisplay();
        }

        function resetToTotalView() {
            appState.analyticsCurrentMonth = -1;
            appState.analyticsCurrentYear = new Date().getFullYear();
            updateAnalyticsMonthDisplay();
            updateMonthlyStats();
            updateDailyStats();
            updateOpenHourlyStats();
            updateHourlyStats();
            updateStatisticsDisplay();
        }

        function changeSetupFilter(setupType) {
            appState.selectedSetup = setupType;
            updateStatisticsDisplay();
        }

        function resetBreakdownToTotalView() {
            appState.breakdownCurrentMonth = -1;
            appState.breakdownCurrentYear = new Date().getFullYear();
            updateBreakdownDisplays();
        }

        function updateAnalyticsMonthDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const displayText = appState.analyticsCurrentMonth === -1
                ? 'TOTAL (All Time)'
                : `${monthNames[appState.analyticsCurrentMonth]} ${appState.analyticsCurrentYear}`;

            // Update all analytics month displays
            const displayElements = [
                'analyticsMonthDisplay',
                'analyticsDailyMonthDisplay',
                'analyticsOpenHourlyMonthDisplay',
                'analyticsCloseHourlyMonthDisplay',
                'analyticsStatsMonthDisplay'
            ];

            displayElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = displayText;
                }
            });
        }

        // Rule Combinations Navigation
        function changeRuleCombinationsMonth(direction) {
            // If currently at TOTAL (-1) and going forward, go to the first month with trades
            // If going backward from TOTAL, stay at TOTAL
            if (appState.ruleCombinationsCurrentMonth === -1) {
                if (direction > 0) {
                    // Find the first month with trades
                    const firstTradeDate = appState.trades.length > 0
                        ? new Date(appState.trades.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date)
                        : new Date();
                    appState.ruleCombinationsCurrentMonth = firstTradeDate.getMonth();
                    appState.ruleCombinationsCurrentYear = firstTradeDate.getFullYear();
                } else {
                    // Stay at TOTAL when going backward
                    return;
                }
            } else {
                appState.ruleCombinationsCurrentMonth += direction;
                if (appState.ruleCombinationsCurrentMonth < 0) {
                    appState.ruleCombinationsCurrentMonth = 11;
                    appState.ruleCombinationsCurrentYear--;
                } else if (appState.ruleCombinationsCurrentMonth > 11) {
                    appState.ruleCombinationsCurrentMonth = 0;
                    appState.ruleCombinationsCurrentYear++;
                }
            }
            updateRuleCombinationsMonthDisplay();
            updateRuleCombinationsAnalysis();
        }

        function resetRuleCombinationsToTotalView() {
            appState.ruleCombinationsCurrentMonth = -1;
            appState.ruleCombinationsCurrentYear = new Date().getFullYear();
            updateRuleCombinationsMonthDisplay();
            updateRuleCombinationsAnalysis();
        }

        function updateRuleCombinationsMonthDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const displayText = appState.ruleCombinationsCurrentMonth === -1
                ? 'TOTAL (All Time)'
                : `${monthNames[appState.ruleCombinationsCurrentMonth]} ${appState.ruleCombinationsCurrentYear}`;

            const element = document.getElementById('ruleCombinationsMonthDisplay');
            if (element) {
                element.textContent = displayText;
            }
        }

        // Performance Breakdowns Navigation
        function changeBreakdownMonth(direction) {
            // If currently at TOTAL (-1) and going forward, go to the first month with trades
            // If going backward from TOTAL, stay at TOTAL
            if (appState.breakdownCurrentMonth === -1) {
                if (direction > 0) {
                    // Find the first month with trades
                    const firstTradeDate = appState.trades.length > 0
                        ? new Date(appState.trades.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date)
                        : new Date();
                    appState.breakdownCurrentMonth = firstTradeDate.getMonth();
                    appState.breakdownCurrentYear = firstTradeDate.getFullYear();
                } else {
                    // Stay at TOTAL when going backward
                    return;
                }
            } else {
                appState.breakdownCurrentMonth += direction;
                if (appState.breakdownCurrentMonth < 0) {
                    appState.breakdownCurrentMonth = 11;
                    appState.breakdownCurrentYear--;
                } else if (appState.breakdownCurrentMonth > 11) {
                    appState.breakdownCurrentMonth = 0;
                    appState.breakdownCurrentYear++;
                }
            }
            updateBreakdownMonthDisplay();
            updateBreakdownDisplays();
        }

        function updateBreakdownMonthDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const displayText = appState.breakdownCurrentMonth === -1
                ? 'TOTAL (All Time)'
                : `${monthNames[appState.breakdownCurrentMonth]} ${appState.breakdownCurrentYear}`;

            // Update all breakdown month displays
            const displayElements = [
                'breakdownSetupMonthDisplay',
                'breakdownMarketMonthDisplay',
                'breakdownEmotionalMonthDisplay',
                'breakdownRuleMonthDisplay'
            ];

            displayElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = displayText;
                }
            });
        }

        function updateBreakdownDisplays() {
            updateBreakdownMonthDisplay();
            updateSetupBreakdown();
            updateMarketBreakdown();
            updateEmotionalBreakdown();
            updateRuleBreakdown();
        }

        // AI Analysis Functions
        function updateAiPromptInclusion(key, value) {
            appState.aiPromptInclusions[key] = value;
            if (key === 'tradesOption') {
                updateTradesOptionHelper();
            }
        }
        
        function updateTradesOptionHelper() {
            const option = appState.aiPromptInclusions.tradesOption;
            const helper = document.getElementById('tradesOptionHelper');
            
            // Safety check for trades array
            if (!appState.trades || !Array.isArray(appState.trades)) {
                if (helper) {
                    helper.textContent = '';
                }
                return;
            }
            
            const totalTrades = appState.trades.length;
            const winningTrades = appState.trades.filter(t => (t.netPL || t.profit) > 0).length;
            const losingTrades = appState.trades.filter(t => (t.netPL || t.profit) < 0).length;
            
            let text = '';
            switch(option) {
                case 'all':
                    text = `‚ö†Ô∏è Including all ${totalTrades} trades may create a very long prompt`;
                    break;
                case 'winning':
                    text = `Including ${winningTrades} winning trades`;
                    break;
                case 'losing':
                    text = `Including ${losingTrades} losing trades`;
                    break;
                case 'bestWorst':
                    text = `Including best 5 and worst 5 trades (10 total)`;
                    break;
                case 'recent10':
                case 'recent20':
                case 'recent50':
                    const count = parseInt(option.replace('recent', ''));
                    const actualCount = Math.min(count, totalTrades);
                    text = `Including ${actualCount} most recent trades`;
                    break;
                case 'none':
                default:
                    text = '';
            }
            
            if (helper) {
                helper.textContent = text;
            }
        }
        
        function generateAIAnalysisPrompt() {
            if (!appState.statistics || !appState.statistics.totalTrades) {
                showMessage('No trading data available for analysis', 'error');
                return;
            }
            
            const prompt = buildAnalysisPrompt();
            document.getElementById('promptText').value = prompt;
            document.getElementById('analysisPrompt').style.display = 'block';
            document.getElementById('copyPromptBtn').disabled = false;
        }
        
        function buildAnalysisPrompt() {
            const inclusions = appState.aiPromptInclusions;
            const format = appState.exportPromptFormat;
            const stats = appState.statistics;
            
            // Gather analysis data based on selections
            const analysisData = {};
            
            // Only include sections that are checked
            if (inclusions.overview) {
                analysisData.overview = {
                    totalTrades: stats.totalTrades,
                    winRate: stats.winRate,
                    profitFactor: stats.profitFactor,
                    netPL: stats.netPL,
                    expectancy: stats.expectancy,
                    avgWin: stats.avgWin,
                    avgLoss: stats.avgLoss,
                    accountGrowth: stats.accountGrowth,
                    startingBalance: stats.startingBalance,
                    currentBalance: stats.currentBalance
                };
            }
            
            if (inclusions.setupPerformance) {
                const setupPerf = calculateSetupPerformance();
                if (Object.keys(setupPerf).length > 0) {
                    analysisData.setupPerformance = setupPerf;
                }
            }
            
            if (inclusions.marketCondition) {
                const marketPerf = calculateMarketConditionPerformance();
                if (Object.keys(marketPerf).length > 0) {
                    analysisData.marketConditionPerformance = marketPerf;
                }
            }
            
            if (inclusions.emotionalState) {
                const emotionalPerf = calculateEmotionalStatePerformance();
                if (Object.keys(emotionalPerf).length > 0) {
                    analysisData.emotionalStatePerformance = emotionalPerf;
                }
            }
            
            if (inclusions.ruleAdherence) {
                const rulePerf = calculateRuleAdherencePerformance();
                if (Object.keys(rulePerf).length > 0) {
                    analysisData.ruleAdherencePerformance = rulePerf;
                }
            }
            
            // Calculate time-based stats if any of the time-based options are selected
            if (inclusions.monthlyPerformance || inclusions.dailyPerformance ||
                inclusions.openHourlyPerformance || inclusions.closeHourlyPerformance) {
                const timeStats = calculateTimeBasedStats();

                if (inclusions.monthlyPerformance) {
                    analysisData.monthlyPerformance = timeStats.monthly;
                }

                if (inclusions.dailyPerformance) {
                    analysisData.dailyPerformance = timeStats.daily;
                }

                if (inclusions.openHourlyPerformance) {
                    analysisData.openHourlyPerformance = timeStats.openHourly;
                }

                if (inclusions.closeHourlyPerformance) {
                    analysisData.closeHourlyPerformance = timeStats.closeHourly;
                }
            }

            // Calculate month-over-month analysis if selected
            if (inclusions.monthOverMonthAnalysis) {
                const momAnalysis = calculateMonthOverMonthAnalysis();
                if (momAnalysis.available) {
                    analysisData.monthOverMonthAnalysis = momAnalysis;
                }
            }

            if (inclusions.customRules && appState.customRules.length > 0) {
                analysisData.customRules = {
                    totalRules: appState.customRules.length,
                    rules: appState.customRules.map(r => r.text),
                    adherenceStats: calculateCustomRuleAdherence()
                };
            }
            
            // Include trades based on selection
            const tradesToInclude = getTradesForPrompt();
            if (tradesToInclude && tradesToInclude.length > 0) {
                analysisData.trades = {
                    count: tradesToInclude.length,
                    selection: inclusions.tradesOption,
                    data: tradesToInclude.map(t => ({
                        date: t.date,
                        time: t.time,
                        symbol: t.symbol,
                        direction: t.direction,
                        entryPrice: t.entryPrice,
                        exitPrice: t.exitPrice,
                        pips: t.pips,
                        grossPL: t.grossProfit || 0,
                        netPL: t.netPL || t.profit,
                        setupType: t.setupType || '‚Äî',
                        marketCondition: t.marketCondition || '‚Äî',
                        emotionalState: t.emotionalState || '‚Äî',
                        ruleAdherence: t.ruleAdherence || '‚Äî',
                        notes: t.notes || ''
                    }))
                };
            }
            
            // Generate prompt based on format and included sections
            if (format === 'readable') {
                return buildReadablePrompt(analysisData);
            } else {
                return buildJSONPrompt(analysisData);
            }
        }
        
        function buildReadablePrompt(data) {
            let prompt = "You are an expert trading coach. Please analyze my trading performance and provide actionable insights.\n\n";
            
            // Add Strategy Context if provided - FIRST
            if (appState.strategyContext && appState.strategyContext.trim()) {
                prompt += `üìñ MY TRADING STRATEGY:\n${appState.strategyContext.trim()}\n\n`;
                prompt += `Please keep this strategy context in mind when analyzing my performance.\n\n`;
                prompt += "=".repeat(60) + "\n\n";
            }
            
            if (data.overview) {
                prompt += `üìä PERFORMANCE OVERVIEW:\n`;
                prompt += `‚Ä¢ Total Trades: ${data.overview.totalTrades}\n`;
                prompt += `‚Ä¢ Win Rate: ${data.overview.winRate.toFixed(1)}%\n`;
                prompt += `‚Ä¢ Profit Factor: ${data.overview.profitFactor.toFixed(2)}\n`;
                prompt += `‚Ä¢ Net P&L: ${formatCurrency(data.overview.netPL)}\n`;
                prompt += `‚Ä¢ Expectancy: ${formatCurrency(data.overview.expectancy)}\n`;
                prompt += `‚Ä¢ Average Win: ${formatCurrency(data.overview.avgWin)}\n`;
                prompt += `‚Ä¢ Average Loss: ${formatCurrency(Math.abs(data.overview.avgLoss))}\n`;
                prompt += `‚Ä¢ Account Growth: ${data.overview.accountGrowth.toFixed(1)}%\n\n`;
            }
            
            if (data.setupPerformance) {
                prompt += `üéØ SETUP TYPE PERFORMANCE:\n`;
                Object.entries(data.setupPerformance).forEach(([setup, perf]) => {
                    prompt += `‚Ä¢ ${setup}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.marketConditionPerformance) {
                prompt += `üåä MARKET CONDITION PERFORMANCE:\n`;
                Object.entries(data.marketConditionPerformance).forEach(([condition, perf]) => {
                    prompt += `‚Ä¢ ${condition}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.emotionalStatePerformance) {
                prompt += `üß† EMOTIONAL STATE PERFORMANCE:\n`;
                Object.entries(data.emotionalStatePerformance).forEach(([state, perf]) => {
                    prompt += `‚Ä¢ ${state}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.ruleAdherencePerformance) {
                prompt += `üìã RULE ADHERENCE PERFORMANCE:\n`;
                Object.entries(data.ruleAdherencePerformance).forEach(([adherence, perf]) => {
                    prompt += `‚Ä¢ ${adherence}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.monthlyPerformance) {
                prompt += `üìÖ MONTHLY PERFORMANCE:\n`;
                Object.entries(data.monthlyPerformance).forEach(([month, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `‚Ä¢ ${month}: ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }

            if (data.monthOverMonthAnalysis) {
                const mom = data.monthOverMonthAnalysis;
                prompt += `üìà MONTH-OVER-MONTH EVOLUTION ANALYSIS:\n`;
                prompt += `‚Ä¢ Total Months Analyzed: ${mom.summary.totalMonths}\n`;
                prompt += `‚Ä¢ Monthly Comparisons: ${mom.summary.comparisons}\n`;
                prompt += `‚Ä¢ Recent Trend (Last 3 Months): Win Rate ${mom.summary.recentTrend.winRate.toUpperCase()}, Profitability ${mom.summary.recentTrend.profitability.toUpperCase()}\n\n`;

                prompt += `Monthly Comparisons:\n`;
                mom.monthlyComparisons.forEach((comparison, index) => {
                    const changeSymbol = (value) => value > 0 ? '‚Üë' : value < 0 ? '‚Üì' : '‚Üí';
                    const trendEmoji = (trend) => trend === 'improving' ? 'üìà' : trend === 'declining' ? 'üìâ' : '‚û°Ô∏è';

                    prompt += `\n${index + 1}. ${comparison.previousMonth} ‚Üí ${comparison.currentMonth}:\n`;
                    prompt += `   ‚Ä¢ Trades: ${comparison.previous.trades} ‚Üí ${comparison.current.trades} (${changeSymbol(comparison.changes.trades)} ${comparison.changes.trades >= 0 ? '+' : ''}${comparison.changes.trades}, ${comparison.changes.tradesPercent.toFixed(1)}%) ${trendEmoji(comparison.trends.activity)}\n`;
                    prompt += `   ‚Ä¢ Win Rate: ${comparison.previous.winRate.toFixed(1)}% ‚Üí ${comparison.current.winRate.toFixed(1)}% (${changeSymbol(comparison.changes.winRate)} ${comparison.changes.winRate >= 0 ? '+' : ''}${comparison.changes.winRate.toFixed(1)}%) ${trendEmoji(comparison.trends.winRate)}\n`;
                    prompt += `   ‚Ä¢ Total P&L: ${formatCurrency(comparison.previous.profit)} ‚Üí ${formatCurrency(comparison.current.profit)} (${changeSymbol(comparison.changes.profit)} ${formatCurrency(comparison.changes.profit)}, ${comparison.changes.profitPercent.toFixed(1)}%) ${trendEmoji(comparison.trends.profitability)}\n`;
                    prompt += `   ‚Ä¢ Avg P&L per Trade: ${formatCurrency(comparison.previous.avgProfit)} ‚Üí ${formatCurrency(comparison.current.avgProfit)} (${changeSymbol(comparison.changes.avgProfit)} ${formatCurrency(comparison.changes.avgProfit)})\n`;
                });
                prompt += `\n`;
            }

            if (data.dailyPerformance) {
                prompt += `üìÜ DAILY PERFORMANCE (Day of Week):\n`;
                Object.entries(data.dailyPerformance).forEach(([day, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `‚Ä¢ ${day}: ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }

            if (data.openHourlyPerformance) {
                prompt += `üïê OPEN HOURLY PERFORMANCE:\n`;
                const activeOpenHours = Object.entries(data.openHourlyPerformance)
                    .filter(([hour, perf]) => perf.trades > 0)
                    .sort((a, b) => b[1].profit - a[1].profit);
                activeOpenHours.forEach(([hour, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `‚Ä¢ ${hour}:00 - ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }

            if (data.closeHourlyPerformance) {
                prompt += `üïê CLOSE HOURLY PERFORMANCE:\n`;
                const activeCloseHours = Object.entries(data.closeHourlyPerformance)
                    .filter(([hour, perf]) => perf.trades > 0)
                    .sort((a, b) => b[1].profit - a[1].profit);
                activeCloseHours.forEach(([hour, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `‚Ä¢ ${hour}:00 - ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.customRules) {
                prompt += `üìè CUSTOM TRADING RULES:\n`;
                prompt += `‚Ä¢ Total Rules: ${data.customRules.totalRules}\n`;
                data.customRules.rules.forEach((rule, index) => {
                    prompt += `‚Ä¢ Rule ${index + 1}: ${rule}\n`;
                });
                prompt += `\n`;
            }
            
            if (data.trades) {
                const selectionText = {
                    'recent10': 'Recent 10',
                    'recent20': 'Recent 20', 
                    'recent50': 'Recent 50',
                    'all': 'All',
                    'winning': 'Winning',
                    'losing': 'Losing',
                    'bestWorst': 'Best &amp; Worst'
                }[data.trades.selection] || 'Selected';
                
                prompt += `üíº INDIVIDUAL TRADES (${selectionText} - ${data.trades.count} trades):\n`;
                data.trades.data.forEach((trade, index) => {
                    prompt += `‚Ä¢ ${trade.date} ${trade.time}: ${trade.symbol} ${trade.direction}, Entry: ${trade.entryPrice}, Exit: ${trade.exitPrice}, ${trade.pips} pips, ${formatCurrency(trade.netPL)} P&L`;
                    if (trade.setupType && trade.setupType !== '‚Äî') prompt += `, Setup: ${trade.setupType}`;
                    if (trade.emotionalState && trade.emotionalState !== '‚Äî') prompt += `, Emotion: ${trade.emotionalState}`;
                    if (trade.ruleAdherence && trade.ruleAdherence !== '‚Äî') prompt += `, Rules: ${trade.ruleAdherence}`;
                    if (trade.notes) prompt += `, Notes: ${trade.notes}`;
                    prompt += `\n`;
                });
                prompt += `\n`;
            }
            
            prompt += `PLEASE ANALYZE AND PROVIDE:\n`;
            prompt += `1. Overall performance assessment\n`;
            prompt += `2. Strengths and areas for improvement\n`;
            prompt += `3. Risk management evaluation\n`;
            prompt += `4. Specific recommendations for better results\n`;
            prompt += `5. Trading psychology insights\n`;
            
            return prompt;
        }
        
        function buildJSONPrompt(data) {
            const fullData = {
                strategyContext: appState.strategyContext || null,
                tradingData: data
            };
            
            let prompt = `Trading Strategy & Performance Data:\n\n`;
            prompt += JSON.stringify(fullData, null, 2);
            prompt += `\n\nPlease analyze this trading performance data`;
            if (appState.strategyContext) {
                prompt += ` in the context of the provided strategy`;
            }
            prompt += ` and provide insights.`;
            return prompt;
        }
        
        function copyAIPromptToClipboard() {
            const promptText = document.getElementById('promptText').value;
            if (!promptText.trim()) {
                showMessage('No prompt generated yet', 'error');
                return;
            }
            
            navigator.clipboard.writeText(promptText).then(() => {
                appState.showPromptCopied = true;
                document.getElementById('promptCopiedMessage').style.display = 'block';
                setTimeout(() => {
                    appState.showPromptCopied = false;
                    document.getElementById('promptCopiedMessage').style.display = 'none';
                }, 3000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.getElementById('promptText');
                textArea.select();
                textArea.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showMessage('Analysis prompt copied to clipboard');
            });
        }
        
        // Helper functions for performance calculations
        function calculateSetupPerformance() {
            const performance = {};
            setupTypes.forEach(setup => {
                const trades = appState.trades.filter(t => t.setupType === setup);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[setup] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function calculateMarketConditionPerformance() {
            const performance = {};
            marketConditions.forEach(condition => {
                const trades = appState.trades.filter(t => t.marketCondition === condition);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[condition] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function calculateEmotionalStatePerformance() {
            const performance = {};
            emotionalStates.forEach(state => {
                const trades = appState.trades.filter(t => t.emotionalState === state);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[state] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function calculateRuleAdherencePerformance() {
            const performance = {};
            ruleAdherence.forEach(adherence => {
                const trades = appState.trades.filter(t => t.ruleAdherence === adherence);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[adherence] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function getTradesForPrompt() {
            const option = appState.aiPromptInclusions.tradesOption;
            
            if (option === 'none') {
                return null;
            }
            
            // Sort trades by close time for recent selections
            const sortedTrades = [...appState.trades].sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateB - dateA; // Most recent first
            });
            
            switch(option) {
                case 'recent10':
                    return sortedTrades.slice(0, 10);
                
                case 'recent20':
                    return sortedTrades.slice(0, 20);
                
                case 'recent50':
                    return sortedTrades.slice(0, 50);
                
                case 'all':
                    return sortedTrades;
                
                case 'winning':
                    return sortedTrades.filter(t => (parseFloat(t.netPL) || parseFloat(t.profit) || 0) > 0);
                
                case 'losing':
                    return sortedTrades.filter(t => (parseFloat(t.netPL) || parseFloat(t.profit) || 0) < 0);
                
                case 'bestWorst':
                    const sortedByPL = [...sortedTrades].sort((a, b) => 
                        (parseFloat(b.netPL) || parseFloat(b.profit) || 0) - (parseFloat(a.netPL) || parseFloat(a.profit) || 0)
                    );
                    const best5 = sortedByPL.slice(0, 5);
                    const worst5 = sortedByPL.slice(-5);
                    return [...best5, ...worst5];
                
                default:
                    return null;
            }
        }
        
        function calculateTimeBasedStats() {
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            // Monthly stats
            const monthlyStats = {};
            // Daily (day of week) stats
            const dailyStats = {};
            daysOfWeek.forEach(day => {
                dailyStats[day] = { trades: 0, profit: 0, wins: 0 };
            });
            // Open hourly stats
            const openHourlyStats = {};
            // Close hourly stats
            const closeHourlyStats = {};

            // Initialize hourly stats
            for (let i = 0; i < 24; i++) {
                openHourlyStats[i] = { trades: 0, profit: 0, wins: 0 };
                closeHourlyStats[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                const pl = trade.netPL || trade.profit;
                const isWin = pl > 0;

                // Monthly stats
                const month = trade.date.substring(0, 7); // YYYY-MM
                if (!monthlyStats[month]) {
                    monthlyStats[month] = { trades: 0, profit: 0, wins: 0 };
                }
                monthlyStats[month].trades++;
                monthlyStats[month].profit += pl;
                if (isWin) monthlyStats[month].wins++;

                // Daily (day of week) stats
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const dayOfWeek = daysOfWeek[tradeDate.getDay()];
                dailyStats[dayOfWeek].trades++;
                dailyStats[dayOfWeek].profit += pl;
                if (isWin) dailyStats[dayOfWeek].wins++;

                // Open hourly stats
                if (trade.openTime) {
                    const openHour = parseInt(trade.openTime.split(':')[0]);
                    openHourlyStats[openHour].trades++;
                    openHourlyStats[openHour].profit += pl;
                    if (isWin) openHourlyStats[openHour].wins++;
                }

                // Close hourly stats
                const closeHour = parseInt(trade.time.split(':')[0]);
                closeHourlyStats[closeHour].trades++;
                closeHourlyStats[closeHour].profit += pl;
                if (isWin) closeHourlyStats[closeHour].wins++;
            });

            return {
                monthly: monthlyStats,
                daily: dailyStats,
                openHourly: openHourlyStats,
                closeHourly: closeHourlyStats
            };
        }

        function calculateMonthOverMonthAnalysis() {
            // Get monthly stats first
            const timeStats = calculateTimeBasedStats();
            const monthlyStats = timeStats.monthly;

            // Sort months chronologically
            const sortedMonths = Object.keys(monthlyStats).sort();

            if (sortedMonths.length < 2) {
                return {
                    available: false,
                    message: 'Not enough monthly data for comparison (need at least 2 months)'
                };
            }

            // Calculate month-over-month changes
            const momChanges = [];

            for (let i = 1; i < sortedMonths.length; i++) {
                const currentMonth = sortedMonths[i];
                const previousMonth = sortedMonths[i - 1];

                const currentStats = monthlyStats[currentMonth];
                const previousStats = monthlyStats[previousMonth];

                // Calculate metrics for both months
                const currentWinRate = currentStats.trades > 0 ? (currentStats.wins / currentStats.trades * 100) : 0;
                const previousWinRate = previousStats.trades > 0 ? (previousStats.wins / previousStats.trades * 100) : 0;

                // Calculate average win/loss for each month
                const currentAvgProfit = currentStats.trades > 0 ? currentStats.profit / currentStats.trades : 0;
                const previousAvgProfit = previousStats.trades > 0 ? previousStats.profit / previousStats.trades : 0;

                // Calculate changes
                const tradesChange = currentStats.trades - previousStats.trades;
                const tradesChangePercent = previousStats.trades > 0 ? ((tradesChange / previousStats.trades) * 100) : 0;

                const winRateChange = currentWinRate - previousWinRate;

                const profitChange = currentStats.profit - previousStats.profit;
                const profitChangePercent = previousStats.profit !== 0 ? ((profitChange / Math.abs(previousStats.profit)) * 100) : 0;

                const avgProfitChange = currentAvgProfit - previousAvgProfit;
                const avgProfitChangePercent = previousAvgProfit !== 0 ? ((avgProfitChange / Math.abs(previousAvgProfit)) * 100) : 0;

                // Determine trend indicators
                const determineTrend = (value) => {
                    if (Math.abs(value) < 5) return 'stable';
                    return value > 0 ? 'improving' : 'declining';
                };

                momChanges.push({
                    currentMonth,
                    previousMonth,
                    current: {
                        trades: currentStats.trades,
                        wins: currentStats.wins,
                        winRate: currentWinRate,
                        profit: currentStats.profit,
                        avgProfit: currentAvgProfit
                    },
                    previous: {
                        trades: previousStats.trades,
                        wins: previousStats.wins,
                        winRate: previousWinRate,
                        profit: previousStats.profit,
                        avgProfit: previousAvgProfit
                    },
                    changes: {
                        trades: tradesChange,
                        tradesPercent: tradesChangePercent,
                        winRate: winRateChange,
                        profit: profitChange,
                        profitPercent: profitChangePercent,
                        avgProfit: avgProfitChange,
                        avgProfitPercent: avgProfitChangePercent
                    },
                    trends: {
                        activity: determineTrend(tradesChangePercent),
                        winRate: determineTrend(winRateChange),
                        profitability: determineTrend(profitChangePercent)
                    }
                });
            }

            // Calculate overall trend (last 3 months if available)
            const recentMonths = momChanges.slice(-3);
            const avgWinRateChange = recentMonths.reduce((sum, m) => sum + m.changes.winRate, 0) / recentMonths.length;
            const avgProfitChange = recentMonths.reduce((sum, m) => sum + m.changes.profitPercent, 0) / recentMonths.length;

            return {
                available: true,
                monthlyComparisons: momChanges,
                summary: {
                    totalMonths: sortedMonths.length,
                    comparisons: momChanges.length,
                    recentTrend: {
                        winRate: avgWinRateChange > 5 ? 'improving' : avgWinRateChange < -5 ? 'declining' : 'stable',
                        profitability: avgProfitChange > 5 ? 'improving' : avgProfitChange < -5 ? 'declining' : 'stable'
                    }
                }
            };
        }

        function calculateCustomRuleAdherence() {
            const tradesWithRules = appState.trades.filter(t => t.rulesFollowed && t.rulesFollowed.length > 0);
            const rulesWins = tradesWithRules.filter(t => (t.netPL || t.profit) > 0);
            
            return {
                totalTradesWithRules: tradesWithRules.length,
                rulesWinRate: tradesWithRules.length > 0 ? (rulesWins.length / tradesWithRules.length * 100) : 0,
                averageRulesPerTrade: tradesWithRules.length > 0 ? tradesWithRules.reduce((sum, t) => sum + t.rulesFollowed.length, 0) / tradesWithRules.length : 0
            };
        }
        
        // Print Functions
        // Helper function to generate screenshot HTML with error handling
        function generateScreenshotHtml(label, screenshotData) {
            if (!screenshotData) return '';

            const src = getScreenshotSrc(screenshotData);
            const sanitizedUrl = sanitizeScreenshotUrl(src);

            if (!sanitizedUrl) return '';

            // Check if it's a TradingView URL
            const isTradingViewUrl = sanitizedUrl.includes('tradingview.com');

            if (isTradingViewUrl) {
                // Convert TradingView URL to snapshot image URL
                // Pattern: https://www.tradingview.com/x/ABC123/ -> https://s.tradingview.com/snapshots/x/ABC123.png
                let imageUrl = sanitizedUrl;
                const tvMatch = sanitizedUrl.match(/tradingview\.com\/x\/([^\/]+)/);

                if (tvMatch && tvMatch[1]) {
                    const snapshotId = tvMatch[1];
                    imageUrl = `https://s.tradingview.com/snapshots/x/${snapshotId}.png`;
                }

                const uniqueId = `tv-${Math.random().toString(36).substr(2, 9)}`;
                return `
                    <div style="margin: 10px 0;">
                        <strong>${escapeHtml(label)}:</strong><br>
                        <img id="${uniqueId}"
                             src="${imageUrl}"
                             alt="${escapeHtml(label)} TradingView Chart"
                             style="max-width: 800px; width: 100%; height: auto; margin: 10px 0; border: 1px solid #ccc; display: block;"
                             onerror="this.style.display='none'; document.getElementById('${uniqueId}-fallback').style.display='block';">
                        <div id="${uniqueId}-fallback" style="display: none; padding: 10px; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; margin: 10px 0;">
                            <p style="margin: 0 0 5px 0; color: #666; font-size: 14px;">üìä TradingView Chart</p>
                            <p style="margin: 5px 0; font-size: 12px; color: #888;">Image could not be loaded. Click link to view chart:</p>
                            <a href="${sanitizedUrl}" target="_blank" style="color: #2962ff; text-decoration: none; word-break: break-all;">${sanitizedUrl}</a>
                        </div>
                    </div>`;
            } else {
                // For data URIs and regular images
                return `<div><strong>${escapeHtml(label)}:</strong><br><img src="${sanitizedUrl}" alt="${escapeHtml(label)} Screenshot" style="max-width: 400px; margin: 10px 0; border: 1px solid #ccc;"></div>`;
            }
        }

        // Helper function to generate HTML for a single trade
        function generateTradeHtml(trade, isLast = false) {
            const pipClass = trade.pips >= 0 ? 'positive' : 'negative';
            const plClass = (trade.netPL || trade.profit) >= 0 ? 'positive' : 'negative';

            // Build screenshots HTML if they exist (includes TradingView URLs)
            let screenshotsHtml = '';
            if (trade.entryScreenshot || trade.exitScreenshot || trade.tradingViewEntry || trade.tradingViewExit) {
                screenshotsHtml = '<div class="section"><h3>Screenshots</h3>';

                // For entry: use screenshot if available, otherwise use TradingView URL
                const entryData = trade.entryScreenshot || trade.tradingViewEntry;
                if (entryData) {
                    screenshotsHtml += generateScreenshotHtml('Entry', entryData);
                }

                // For exit: use screenshot if available, otherwise use TradingView URL
                const exitData = trade.exitScreenshot || trade.tradingViewExit;
                if (exitData) {
                    screenshotsHtml += generateScreenshotHtml('Exit', exitData);
                }

                screenshotsHtml += '</div>';
            }

            // Build notes HTML if exists
            let notesHtml = '';
            if (trade.notes) {
                notesHtml = `<div class="section"><h3>Notes</h3><p>${escapeHtml(trade.notes)}</p></div>`;
            }

            // Add page break after each trade except the last one
            const pageBreakClass = !isLast ? ' page-break' : '';

            return `
    <div class="trade-page${pageBreakClass}">
        <div class="header">
            <h1>Trade Report</h1>
            <h2>${escapeHtml(trade.symbol)} - ${escapeHtml(trade.date)} ${escapeHtml(trade.time)}</h2>
        </div>

        <div class="trade-info">
            <div>
                <strong>Entry Price:</strong> ${escapeHtml(trade.entryPrice.toFixed(5))}<br>
                <strong>Exit Price:</strong> ${escapeHtml(trade.exitPrice.toFixed(5))}<br>
                <strong>Direction:</strong> ${escapeHtml(trade.direction)}<br>
                <strong>Volume:</strong> ${escapeHtml(String(trade.volume))}
            </div>
            <div>
                <strong>Pips:</strong> <span class="${pipClass}">${escapeHtml(trade.pips.toFixed(1))}</span><br>
                <strong>P&L:</strong> <span class="${plClass}">${escapeHtml(formatCurrency(trade.netPL || trade.profit))}</span><br>
                <strong>Commission:</strong> ${escapeHtml(formatCurrency(trade.commission))}<br>
                <strong>Swap:</strong> ${escapeHtml(formatCurrency(trade.swap))}
            </div>
        </div>

        <div class="section">
            <h3>Trade Analysis</h3>
            <strong>Setup Type:</strong> ${escapeHtml(trade.setupType || 'Not specified')}<br>
            <strong>Market Condition:</strong> ${escapeHtml(trade.marketCondition || 'Not specified')}<br>
            <strong>Emotional State:</strong> ${escapeHtml(trade.emotionalState || 'Not specified')}<br>
            <strong>Rule Adherence:</strong> ${escapeHtml(trade.ruleAdherence || 'Not specified')}
        </div>

        ${notesHtml}

        ${screenshotsHtml}
    </div>`;
        }

        // Preload TradingView images before printing
        async function preloadTradingViewImages(trades) {
            const imagesToPreload = [];

            // Collect all TradingView URLs that need preloading
            trades.forEach(trade => {
                // Check if TradingView URLs exist without screenshots
                if (trade.tradingViewEntry && !trade.entryScreenshot) {
                    const tvMatch = trade.tradingViewEntry.match(/tradingview\.com\/x\/([^\/]+)/);
                    if (tvMatch && tvMatch[1]) {
                        imagesToPreload.push(`https://s.tradingview.com/snapshots/x/${tvMatch[1]}.png`);
                    }
                }

                if (trade.tradingViewExit && !trade.exitScreenshot) {
                    const tvMatch = trade.tradingViewExit.match(/tradingview\.com\/x\/([^\/]+)/);
                    if (tvMatch && tvMatch[1]) {
                        imagesToPreload.push(`https://s.tradingview.com/snapshots/x/${tvMatch[1]}.png`);
                    }
                }
            });

            if (imagesToPreload.length === 0) {
                return; // No images to preload
            }

            // Show loading message
            showMessage(`Loading ${imagesToPreload.length} TradingView chart${imagesToPreload.length > 1 ? 's' : ''}...`, 'info');

            // Preload all images
            const preloadPromises = imagesToPreload.map(imageUrl => {
                return new Promise((resolve) => {
                    const img = new Image();

                    // Resolve on load or error (we don't want to block printing)
                    img.onload = () => resolve(true);
                    img.onerror = () => resolve(false);

                    // Set a timeout to prevent indefinite waiting
                    setTimeout(() => resolve(false), 5000);

                    img.src = imageUrl;
                });
            });

            // Wait for all images to load or timeout
            await Promise.all(preloadPromises);
        }

        // Print individual trade (for per-trade print buttons if needed)
        async function printTrade(tradeIndex) {
            const trade = appState.trades[tradeIndex];

            // Preload TradingView images first
            await preloadTradingViewImages([trade]);

            const printWindow = window.open('', '', 'width=1200,height=800');

            if (!printWindow) {
                showMessage('Unable to open print window. Please check pop-up blocker settings.', 'error');
                return;
            }

            const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Print Preview - ${escapeHtml(trade.symbol)} ${escapeHtml(trade.date)}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
        .trade-info { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .section { margin: 20px 0; }
        .positive { color: green; font-weight: bold; }
        .negative { color: red; font-weight: bold; }
        img { max-width: 100%; height: auto; margin: 10px 0; border: 1px solid #ccc; }

        /* Print Preview Controls */
        .print-preview-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .print-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 10px;
        }
        .print-btn:hover {
            background: #229954;
        }
        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 10px;
        }
        .close-btn:hover {
            background: #c0392b;
        }
        .print-content {
            margin-top: 90px;
        }

        @media print {
            .print-preview-controls { display: none; }
            .print-content { margin-top: 0; }
            @page { size: landscape; }
            body { margin: 15px; }
            img { page-break-inside: avoid; max-width: 100%; }
        }
    </style>
</head>
<body>
    <div class="print-preview-controls">
        <h2 style="margin: 0 0 10px 0;">Print Preview</h2>
        <p style="margin: 5px 0; font-size: 14px; color: #ecf0f1;">Review the content below. Wait for charts to load before printing.</p>
        <div>
            <button class="print-btn" onclick="window.print()">üñ®Ô∏è Print (Ctrl+P)</button>
            <button class="close-btn" onclick="window.close()">‚úï Close</button>
        </div>
    </div>
    <div class="print-content">
        ${generateTradeHtml(trade, true)}
    </div>
</body>
</html>`;

            printWindow.document.open();
            printWindow.document.write(htmlContent);
            printWindow.document.close();
        }

        // Print all trades - each trade on its own page
        async function printTrades() {
            if (!appState.trades || appState.trades.length === 0) {
                showMessage('No trades to print', 'error');
                return;
            }

            // Preload TradingView images first
            await preloadTradingViewImages(appState.trades);

            const printWindow = window.open('', '', 'width=1200,height=800');

            if (!printWindow) {
                showMessage('Unable to open print window. Please check pop-up blocker settings.', 'error');
                return;
            }

            // Generate HTML for all trades
            let tradesHtml = '';
            appState.trades.forEach((trade, index) => {
                const isLast = index === appState.trades.length - 1;
                tradesHtml += generateTradeHtml(trade, isLast);
            });

            const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Print Preview - All Trades (${appState.trades.length} trades)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .trade-page { margin-bottom: 20px; }
        .page-break { page-break-after: always; }
        .header { text-align: center; border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
        .trade-info { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .section { margin: 20px 0; }
        .positive { color: green; font-weight: bold; }
        .negative { color: red; font-weight: bold; }
        img { max-width: 100%; height: auto; margin: 10px 0; border: 1px solid #ccc; }

        /* Print Preview Controls */
        .print-preview-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .print-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 10px;
        }
        .print-btn:hover {
            background: #229954;
        }
        .close-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 10px;
        }
        .close-btn:hover {
            background: #c0392b;
        }
        .print-content {
            margin-top: 90px;
        }

        @media print {
            .print-preview-controls { display: none; }
            .print-content { margin-top: 0; }
            @page { size: landscape; }
            body { margin: 15px; }
            img { page-break-inside: avoid; max-width: 100%; }
        }
    </style>
</head>
<body>
    <div class="print-preview-controls">
        <h2 style="margin: 0 0 10px 0;">Print Preview - ${appState.trades.length} Trades</h2>
        <p style="margin: 5px 0; font-size: 14px; color: #ecf0f1;">Review the content below. Wait for charts to load before printing.</p>
        <div>
            <button class="print-btn" onclick="window.print()">üñ®Ô∏è Print (Ctrl+P)</button>
            <button class="close-btn" onclick="window.close()">‚úï Close</button>
        </div>
    </div>
    <div class="print-content">
        ${tradesHtml}
    </div>
</body>
</html>`;

            printWindow.document.open();
            printWindow.document.write(htmlContent);
            printWindow.document.close();
        }

        // Configuration Functions
        function getStatLabel(key) {
            const labels = {
                startingBalance: 'Starting Balance',
                currentBalance: 'Current Balance',
                accountGrowth: 'Account Growth',
                totalTrades: 'Total Trades',
                winningTrades: 'Winning Trades',
                losingTrades: 'Losing Trades',
                winRate: 'Win Rate',
                rulesWinRate: 'Rules Win Rate',
                profitFactor: 'Profit Factor',
                netPL: 'Net P/L',
                avgWin: 'Average Win',
                avgLoss: 'Average Loss',
                largestWin: 'Largest Win',
                largestLoss: 'Largest Loss',
                expectancy: 'Expectancy',
                totalFees: 'Total Fees',
                // Phase 1 New Stats
                maxDrawdown: 'Max Drawdown',
                maxDrawdownPercent: 'Max Drawdown %',
                recoveryFactor: 'Recovery Factor',
                currentStreak: 'Current Streak',
                longestWinStreak: 'Longest Win Streak',
                longestLossStreak: 'Longest Loss Streak',
                riskRewardRatio: 'Risk/Reward Ratio',
                avgTradeDuration: 'Avg Trade Duration'
            };
            return labels[key] || key;
        }
        
        function getColumnLabel(key) {
            const labels = {
                openDate: 'Open Date',
                openTime: 'Open Time',
                date: 'Close Date',
                time: 'Close Time',
                symbol: 'Symbol',
                direction: 'Direction',
                entry: 'Entry Price',
                exit: 'Exit Price',
                pips: 'Pips',
                pl: 'P&L',
                setup: 'Setup Type'
            };
            return labels[key] || key;
        }
        
        function toggleStatsConfig() {
            appState.showStatsConfig = !appState.showStatsConfig;
            const panel = document.getElementById('statsConfigPanel');
            panel.style.display = appState.showStatsConfig ? 'block' : 'none';
            
            if (appState.showStatsConfig) {
                renderStatsConfig();
            }
        }
        
        function renderStatsConfig() {
            const grid = document.getElementById('statsConfigGrid');
            let html = '';
            
            Object.keys(appState.visibleStats).forEach(statKey => {
                html += `
                    <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                        <input type="checkbox" ${appState.visibleStats[statKey] ? 'checked' : ''} onchange="toggleStat('${statKey}', this.checked)" style="border-radius: var(--radius-sm);">
                        <span>${getStatLabel(statKey)}</span>
                    </label>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        function toggleStat(statKey, checked) {
            appState.visibleStats[statKey] = checked;
            updateStatisticsDisplay();
        }
        
        function showAllStats() {
            Object.keys(appState.visibleStats).forEach(key => {
                appState.visibleStats[key] = true;
            });
            renderStatsConfig();
            updateStatisticsDisplay();
        }
        
        function toggleChartsConfig() {
            appState.showChartsConfig = !appState.showChartsConfig;
            const panel = document.getElementById('chartsConfigPanel');
            panel.style.display = appState.showChartsConfig ? 'block' : 'none';
            
            if (appState.showChartsConfig) {
                // Update checkbox states
                document.getElementById('showEquityCurve').checked = appState.visibleCharts.equityCurve;
                document.getElementById('showDailyPL').checked = appState.visibleCharts.dailyPL;
                document.getElementById('showWinLoss').checked = appState.visibleCharts.winLoss;
            }
        }
        
        function toggleChart(chartKey, checked) {
            appState.visibleCharts[chartKey] = checked;
            updateChartsDisplay();
        }
        
        function updateChartZoom(zoom) {
            appState.chartZoom = parseInt(zoom);
            // Apply zoom to chart containers
            const containers = document.querySelectorAll('.chart-container');
            containers.forEach(container => {
                container.style.transform = `scale(${appState.chartZoom / 100})`;
                container.style.transformOrigin = 'top left';
                if (appState.chartZoom > 100) {
                    container.style.marginBottom = `${(appState.chartZoom - 100) * 3}px`;
                } else {
                    container.style.marginBottom = '0';
                }
            });
        }
        
        function toggleColumnConfig() {
            appState.showColumnsConfig = !appState.showColumnsConfig;
            const panel = document.getElementById('columnsConfigPanel');
            panel.style.display = appState.showColumnsConfig ? 'block' : 'none';
            
            if (appState.showColumnsConfig) {
                renderColumnsConfig();
            }
        }
        
        function renderColumnsConfig() {
            const grid = document.getElementById('columnsConfigGrid');
            let html = '';
            
            Object.keys(appState.visibleColumns).forEach(colKey => {
                html += `
                    <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                        <input type="checkbox" ${appState.visibleColumns[colKey] ? 'checked' : ''} onchange="toggleColumn('${colKey}', this.checked)" style="border-radius: var(--radius-sm);">
                        <span>${getColumnLabel(colKey)}</span>
                    </label>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        function toggleColumn(colKey, checked) {
            appState.visibleColumns[colKey] = checked;
            updateTradesTable();
        }
        
        function showAllColumns() {
            Object.keys(appState.visibleColumns).forEach(key => {
                appState.visibleColumns[key] = true;
            });
            renderColumnsConfig();
            updateTradesTable();
        }
        
        // UI Helper Functions
        function toggleCollapsible(element) {
            element.classList.toggle('open');
            const arrow = element.querySelector('.collapsible-header span:last-child');
            arrow.textContent = element.classList.contains('open') ? '‚ñ≤' : '‚ñº';
        }
        
        // NEW: Account Settings Functions
        function toggleAccountSettings() {
            appState.showAccountSettings = !appState.showAccountSettings;
            updateAccountSettingsCollapseState();
            saveToLocalStorage();
        }
        
        function updateAccountSettingsCollapseState() {
            const content = document.getElementById('accountSettingsContent');
            const arrow = document.getElementById('accountSettingsArrow');
            
            if (appState.showAccountSettings) {
                content.style.display = 'block';
                content.classList.remove('account-settings-collapsed');
                content.classList.add('account-settings-expanded');
                arrow.textContent = '‚ñº';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.classList.remove('account-settings-expanded');
                content.classList.add('account-settings-collapsed');
                arrow.textContent = '‚ñ∂';
                arrow.style.transform = 'rotate(0deg)';
                setTimeout(() => {
                    if (!appState.showAccountSettings) {
                        content.style.display = 'none';
                    }
                }, 250);
            }
        }
        
        // NEW: Trade History Collapse Functions
        function toggleTradeHistory() {
            appState.showTradeHistory = !appState.showTradeHistory;
            updateTradeHistoryCollapseState();
            saveToLocalStorage();
        }
        
        function updateTradeHistoryCollapseState() {
            const container = document.getElementById('tradeHistoryTableContainer');
            const collapsedMessage = document.getElementById('tradeHistoryCollapsedMessage');
            const toggleButton = document.getElementById('tradeHistoryToggle');
            const countSpan = document.getElementById('tradeHistoryCount');
            const collapsedCountSpan = document.getElementById('collapsedTradeCount');
            
            if (appState.showTradeHistory) {
                // Show expanded
                container.style.display = 'block';
                container.classList.remove('trade-history-collapsed');
                container.classList.add('trade-history-expanded');
                collapsedMessage.style.display = 'none';
                toggleButton.textContent = '‚ñº';
                countSpan.style.display = 'none';
            } else {
                // Show collapsed
                container.classList.remove('trade-history-expanded');
                container.classList.add('trade-history-collapsed');
                collapsedMessage.style.display = 'block';
                toggleButton.textContent = '‚ñ∂';
                countSpan.style.display = 'inline';
                countSpan.textContent = `(${appState.trades.length} trades)`;
                collapsedCountSpan.textContent = appState.trades.length;
                setTimeout(() => {
                    if (!appState.showTradeHistory) {
                        container.style.display = 'none';
                    }
                }, 250);
            }
        }
        
        // NEW: Account Settings Management Functions
        let editStartingBalanceValue = null;
        
        function updateStartingBalanceValue(value) {
            editStartingBalanceValue = value;
        }
        
        function saveStartingBalance() {
            if (editStartingBalanceValue !== null && editStartingBalanceValue !== '') {
                const newBalance = parseFloat(editStartingBalanceValue);
                if (!isNaN(newBalance) && newBalance > 0) {
                    appState.startingBalance = newBalance;
                    editStartingBalanceValue = null;
                    document.getElementById('editStartingBalance').value = '';
                    updateStartingBalanceDisplay();
                    calculateStatistics();
                    updateUI();
                    showMessage('‚úÖ Starting balance updated successfully');
                } else {
                    showMessage('Please enter a valid positive number', 'error');
                }
            } else {
                showMessage('Please enter a starting balance', 'error');
            }
        }
        
        function cancelStartingBalance() {
            editStartingBalanceValue = null;
            document.getElementById('editStartingBalance').value = '';
        }
        
        function updateStartingBalanceDisplay() {
            const currentBalanceSpan = document.getElementById('currentStartingBalance');
            if (currentBalanceSpan) {
                currentBalanceSpan.textContent = (appState.startingBalance || 0).toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }
        
        function updateImportMode(mode) {
            document.getElementById('importMode').value = mode;
        }

        function updatePlatform(platform) {
            document.getElementById('platform').value = platform;
        }

        function clearAllData() {
            if (window.confirm('‚ö†Ô∏è This will delete ALL trades, screenshots, and settings. This cannot be undone!\n\nAre you sure?')) {
                appState.trades = [];
                appState.customRules = [];
                appState.startingBalance = 10000;
                appState.strategyContext = '';
                document.getElementById('strategyContextTextarea').value = '';
                updateStrategyContextCounter();

                // Also clear localStorage data
                clearAllStoredData();

                updateUI();
                showMessage('‚úÖ All data cleared successfully');
            }
        }
        
        // REMOVED: Old updateStartingBalance function - replaced with new account settings functions
        
        // Strategy Context Functions
        function loadStrategyExample(exampleKey) {
            if (exampleKey && strategyExamples[exampleKey]) {
                const textarea = document.getElementById('strategyContextTextarea');
                textarea.value = strategyExamples[exampleKey];
                updateStrategyContext(strategyExamples[exampleKey]);
                updateStrategyContextCounter();
                
                // Reset dropdown to placeholder
                document.getElementById('strategyExampleSelector').value = '';
                
                showMessage(`‚úÖ Loaded ${getStrategyExampleName(exampleKey)} example - customize it to match your approach`);
            }
        }
        
        function getStrategyExampleName(key) {
            const names = {
                'ict': 'ICT Strategy',
                'supplyDemand': 'Supply & Demand',
                'priceAction': 'Price Action',
                'breakout': 'Breakout Trading',
                'trendFollowing': 'Trend Following',
                'scalpingStrategy': 'Scalping',
                'swingTrading': 'Swing Trading'
            };
            return names[key] || 'Strategy';
        }
        
        function clearStrategyContext() {
            const textarea = document.getElementById('strategyContextTextarea');
            textarea.value = '';
            updateStrategyContext('');
            updateStrategyContextCounter();
            document.getElementById('strategyExampleSelector').value = '';
            showMessage('Strategy context cleared');
        }
        
        function updateStrategyContext(value) {
            appState.strategyContext = value;
        }
        
        function updateStrategyContextCounter() {
            const textarea = document.getElementById('strategyContextTextarea');
            const counter = document.getElementById('strategyContextCounter');
            const length = textarea.value.length;
            counter.textContent = `${length} / 2000 characters`;
            
            // Update app state
            appState.strategyContext = textarea.value;
        }
    </script>
</body>
</html>