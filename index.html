<!DOCTYPE html>
<!--
  SECURITY HARDENED VERSION - v2.4.0
  
  This version includes the following security enhancements:
  
  1. XSS PROTECTION:
     - Added escapeHtml() function for sanitizing user input
     - Replaced document.write() in printTrade() with safe DOM methods
     - Added input validation for all user-controlled data
  
  2. URL VALIDATION:
     - Added sanitizeUrl() for URL validation
     - Added safeOpenURL() to safely open external links
     - All window.open() calls now validate URLs and use noopener,noreferrer
  
  3. FILE UPLOAD SECURITY:
     - Added MAX_FILE_SIZE constant (50MB limit)
     - File size validation for CSV and JSON imports
     - Trade data validation before processing
  
  4. INJECTION PREVENTION:
     - Added validateTrade() function to validate trade objects
     - Enhanced input validation in CSV and JSON parsers
     - Symbol validation to prevent numeric-only symbols
  
  5. CODE QUALITY:
     - Fixed duplicate updateTradeField() function
     - Fixed syntax error in string concatenation (line 5151)
  
  REMAINING CONSIDERATIONS:
  - Some inline event handlers (onclick, onchange) remain for backwards compatibility
  - Future enhancement: Convert remaining inline handlers to addEventListener
  - Regular security audits recommended for production use
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Trading Journal v2.4.0</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
  /* Primitive Color Tokens */
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-teal-800: rgba(41, 150, 161, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-orange-400: rgba(230, 129, 97, 1);
  --color-orange-500: rgba(168, 75, 47, 1);

  /* RGB versions for opacity control */
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;
  --color-slate-500-rgb: 98, 108, 113;
  --color-red-500-rgb: 192, 21, 47;
  --color-red-400-rgb: 255, 84, 89;
  --color-orange-500-rgb: 168, 75, 47;
  --color-orange-400-rgb: 230, 129, 97;

  /* Background color tokens (Light Mode) */
  --color-bg-1: rgba(59, 130, 246, 0.08); /* Light blue */
  --color-bg-2: rgba(245, 158, 11, 0.08); /* Light yellow */
  --color-bg-3: rgba(34, 197, 94, 0.08); /* Light green */
  --color-bg-4: rgba(239, 68, 68, 0.08); /* Light red */
  --color-bg-5: rgba(147, 51, 234, 0.08); /* Light purple */
  --color-bg-6: rgba(249, 115, 22, 0.08); /* Light orange */
  --color-bg-7: rgba(236, 72, 153, 0.08); /* Light pink */
  --color-bg-8: rgba(6, 182, 212, 0.08); /* Light cyan */

  /* Semantic Color Tokens (Light Mode) */
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
  --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

  /* Common style patterns */
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --status-bg-opacity: 0.15;
  --status-border-opacity: 0.25;
  --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

  /* RGB versions for opacity control */
  --color-success-rgb: 33, 128, 141;
  --color-error-rgb: 192, 21, 47;
  --color-warning-rgb: 168, 75, 47;
  --color-info-rgb: 98, 108, 113;

  /* Typography */
  --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system,
    BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo,
    Monaco, Consolas, monospace;
  --font-size-xs: 11px;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  --font-size-md: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-2xl: 20px;
  --font-size-3xl: 24px;
  --font-size-4xl: 30px;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 550;
  --font-weight-bold: 600;
  --line-height-tight: 1.2;
  --line-height-normal: 1.5;
  --letter-spacing-tight: -0.01em;

  /* Spacing */
  --space-0: 0;
  --space-1: 1px;
  --space-2: 2px;
  --space-4: 4px;
  --space-6: 6px;
  --space-8: 8px;
  --space-10: 10px;
  --space-12: 12px;
  --space-16: 16px;
  --space-20: 20px;
  --space-24: 24px;
  --space-32: 32px;

  /* Border Radius */
  --radius-sm: 6px;
  --radius-base: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-full: 9999px;

  /* Shadows */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04),
    0 2px 4px -1px rgba(0, 0, 0, 0.02);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04),
    0 4px 6px -2px rgba(0, 0, 0, 0.02);
  --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15),
    inset 0 -1px 0 rgba(0, 0, 0, 0.03);

  /* Animation */
  --duration-fast: 150ms;
  --duration-normal: 250ms;
  --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

  /* Layout */
  --container-sm: 640px;
  --container-md: 768px;
  --container-lg: 1024px;
  --container-xl: 1280px;
}

/* Dark mode colors */
@media (prefers-color-scheme: dark) {
  :root {
    /* RGB versions for opacity control (Dark Mode) */
    --color-gray-400-rgb: 119, 124, 124;
    --color-teal-300-rgb: 50, 184, 198;
    --color-gray-300-rgb: 167, 169, 169;
    --color-gray-200-rgb: 245, 245, 245;

    /* Background color tokens (Dark Mode) */
    --color-bg-1: rgba(29, 78, 216, 0.15); /* Dark blue */
    --color-bg-2: rgba(180, 83, 9, 0.15); /* Dark yellow */
    --color-bg-3: rgba(21, 128, 61, 0.15); /* Dark green */
    --color-bg-4: rgba(185, 28, 28, 0.15); /* Dark red */
    --color-bg-5: rgba(107, 33, 168, 0.15); /* Dark purple */
    --color-bg-6: rgba(194, 65, 12, 0.15); /* Dark orange */
    --color-bg-7: rgba(190, 24, 93, 0.15); /* Dark pink */
    --color-bg-8: rgba(8, 145, 178, 0.15); /* Dark cyan */

    /* Semantic Color Tokens (Dark Mode) */
    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
    --color-primary: var(--color-teal-300);
    --color-primary-hover: var(--color-teal-400);
    --color-primary-active: var(--color-teal-800);
    --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
    --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
    --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
    --color-border: rgba(var(--color-gray-400-rgb), 0.3);
    --color-error: var(--color-red-400);
    --color-success: var(--color-teal-300);
    --color-warning: var(--color-orange-400);
    --color-info: var(--color-gray-300);
    --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
    --color-btn-primary-text: var(--color-slate-900);
    --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
    --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
    --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    --button-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
    --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
    --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

    /* Common style patterns - updated for dark mode */
    --focus-ring: 0 0 0 3px var(--color-focus-ring);
    --focus-outline: 2px solid var(--color-primary);
    --status-bg-opacity: 0.15;
    --status-border-opacity: 0.25;
    --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

    /* RGB versions for dark mode */
    --color-success-rgb: var(--color-teal-300-rgb);
    --color-error-rgb: var(--color-red-400-rgb);
    --color-warning-rgb: var(--color-orange-400-rgb);
    --color-info-rgb: var(--color-gray-300-rgb);
  }
}

/* Data attribute for manual theme switching */
[data-color-scheme="dark"] {
  /* RGB versions for opacity control (dark mode) */
  --color-gray-400-rgb: 119, 124, 124;
  --color-teal-300-rgb: 50, 184, 198;
  --color-gray-300-rgb: 167, 169, 169;
  --color-gray-200-rgb: 245, 245, 245;

  /* Colorful background palette - Dark Mode */
  --color-bg-1: rgba(29, 78, 216, 0.15); /* Dark blue */
  --color-bg-2: rgba(180, 83, 9, 0.15); /* Dark yellow */
  --color-bg-3: rgba(21, 128, 61, 0.15); /* Dark green */
  --color-bg-4: rgba(185, 28, 28, 0.15); /* Dark red */
  --color-bg-5: rgba(107, 33, 168, 0.15); /* Dark purple */
  --color-bg-6: rgba(194, 65, 12, 0.15); /* Dark orange */
  --color-bg-7: rgba(190, 24, 93, 0.15); /* Dark pink */
  --color-bg-8: rgba(8, 145, 178, 0.15); /* Dark cyan */

  /* Semantic Color Tokens (Dark Mode) */
  --color-background: var(--color-charcoal-700);
  --color-surface: var(--color-charcoal-800);
  --color-text: var(--color-gray-200);
  --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
  --color-primary: var(--color-teal-300);
  --color-primary-hover: var(--color-teal-400);
  --color-primary-active: var(--color-teal-800);
  --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
  --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
  --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
  --color-border: rgba(var(--color-gray-400-rgb), 0.3);
  --color-error: var(--color-red-400);
  --color-success: var(--color-teal-300);
  --color-warning: var(--color-orange-400);
  --color-info: var(--color-gray-300);
  --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
  --color-btn-primary-text: var(--color-slate-900);
  --color-card-border: rgba(var(--color-gray-400-rgb), 0.15);
  --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
  --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
    inset 0 -1px 0 rgba(0, 0, 0, 0.15);
  --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
  --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

  /* Common style patterns - updated for dark mode */
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --status-bg-opacity: 0.15;
  --status-border-opacity: 0.25;
  --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

  /* RGB versions for dark mode */
  --color-success-rgb: var(--color-teal-300-rgb);
  --color-error-rgb: var(--color-red-400-rgb);
  --color-warning-rgb: var(--color-orange-400-rgb);
  --color-info-rgb: var(--color-gray-300-rgb);
}

[data-color-scheme="light"] {
  /* RGB versions for opacity control (light mode) */
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;

  /* Semantic Color Tokens (Light Mode) */
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);

  /* RGB versions for light mode */
  --color-success-rgb: var(--color-teal-500-rgb);
  --color-error-rgb: var(--color-red-500-rgb);
  --color-warning-rgb: var(--color-orange-500-rgb);
  --color-info-rgb: var(--color-slate-500-rgb);
}

/* Base styles */
html {
  font-size: var(--font-size-base);
  font-family: var(--font-family-base);
  line-height: var(--line-height-normal);
  color: var(--color-text);
  background-color: var(--color-background);
  -webkit-font-smoothing: antialiased;
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

/* Typography */
h1,
h2,
h3,
h4,
h5,
h6 {
  margin: 0;
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  color: var(--color-text);
  letter-spacing: var(--letter-spacing-tight);
}

h1 {
  font-size: var(--font-size-4xl);
}
h2 {
  font-size: var(--font-size-3xl);
}
h3 {
  font-size: var(--font-size-2xl);
}
h4 {
  font-size: var(--font-size-xl);
}
h5 {
  font-size: var(--font-size-lg);
}
h6 {
  font-size: var(--font-size-md);
}

p {
  margin: 0 0 var(--space-16) 0;
}

a {
  color: var(--color-primary);
  text-decoration: none;
  transition: color var(--duration-fast) var(--ease-standard);
}

a:hover {
  color: var(--color-primary-hover);
}

code,
pre {
  font-family: var(--font-family-mono);
  font-size: calc(var(--font-size-base) * 0.95);
  background-color: var(--color-secondary);
  border-radius: var(--radius-sm);
}

code {
  padding: var(--space-1) var(--space-4);
}

pre {
  padding: var(--space-16);
  margin: var(--space-16) 0;
  overflow: auto;
  border: 1px solid var(--color-border);
}

pre code {
  background: none;
  padding: 0;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-8) var(--space-16);
  border-radius: var(--radius-base);
  font-size: var(--font-size-base);
  font-weight: 500;
  line-height: 1.5;
  cursor: pointer;
  transition: all var(--duration-normal) var(--ease-standard);
  border: none;
  text-decoration: none;
  position: relative;
}

.btn:focus-visible {
  outline: none;
  box-shadow: var(--focus-ring);
}

.btn--primary {
  background: var(--color-primary);
  color: var(--color-btn-primary-text);
}

.btn--primary:hover {
  background: var(--color-primary-hover);
}

.btn--primary:active {
  background: var(--color-primary-active);
}

.btn--secondary {
  background: var(--color-secondary);
  color: var(--color-text);
}

.btn--secondary:hover {
  background: var(--color-secondary-hover);
}

.btn--secondary:active {
  background: var(--color-secondary-active);
}

.btn--outline {
  background: transparent;
  border: 1px solid var(--color-border);
  color: var(--color-text);
}

.btn--outline:hover {
  background: var(--color-secondary);
}

.btn--sm {
  padding: var(--space-4) var(--space-12);
  font-size: var(--font-size-sm);
  border-radius: var(--radius-sm);
}

.btn--lg {
  padding: var(--space-10) var(--space-20);
  font-size: var(--font-size-lg);
  border-radius: var(--radius-md);
}

.btn--full-width {
  width: 100%;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Form elements */
.form-control {
  display: block;
  width: 100%;
  padding: var(--space-8) var(--space-12);
  font-size: var(--font-size-md);
  line-height: 1.5;
  color: var(--color-text);
  background-color: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  transition: border-color var(--duration-fast) var(--ease-standard),
    box-shadow var(--duration-fast) var(--ease-standard);
}

textarea.form-control {
  font-family: var(--font-family-base);
  font-size: var(--font-size-base);
}

select.form-control {
  padding: var(--space-8) var(--space-12);
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: var(--select-caret-light);
  background-repeat: no-repeat;
  background-position: right var(--space-12) center;
  background-size: 16px;
  padding-right: var(--space-32);
}

/* Add a dark mode specific caret */
@media (prefers-color-scheme: dark) {
  select.form-control {
    background-image: var(--select-caret-dark);
  }
}

/* Also handle data-color-scheme */
[data-color-scheme="dark"] select.form-control {
  background-image: var(--select-caret-dark);
}

[data-color-scheme="light"] select.form-control {
  background-image: var(--select-caret-light);
}

.form-control:focus {
  border-color: var(--color-primary);
  outline: var(--focus-outline);
}

.form-label {
  display: block;
  margin-bottom: var(--space-8);
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
}

.form-group {
  margin-bottom: var(--space-16);
}

/* Card component */
.card {
  background-color: var(--color-surface);
  border-radius: var(--radius-lg);
  border: 1px solid var(--color-card-border);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
  transition: box-shadow var(--duration-normal) var(--ease-standard);
}

.card:hover {
  box-shadow: var(--shadow-md);
}

.card__body {
  padding: var(--space-16);
}

.card__header,
.card__footer {
  padding: var(--space-16);
  border-bottom: 1px solid var(--color-card-border-inner);
}

/* Status indicators - simplified with CSS variables */
.status {
  display: inline-flex;
  align-items: center;
  padding: var(--space-6) var(--space-12);
  border-radius: var(--radius-full);
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
}

.status--success {
  background-color: rgba(
    var(--color-success-rgb, 33, 128, 141),
    var(--status-bg-opacity)
  );
  color: var(--color-success);
  border: 1px solid
    rgba(var(--color-success-rgb, 33, 128, 141), var(--status-border-opacity));
}

.status--error {
  background-color: rgba(
    var(--color-error-rgb, 192, 21, 47),
    var(--status-bg-opacity)
  );
  color: var(--color-error);
  border: 1px solid
    rgba(var(--color-error-rgb, 192, 21, 47), var(--status-border-opacity));
}

.status--warning {
  background-color: rgba(
    var(--color-warning-rgb, 168, 75, 47),
    var(--status-bg-opacity)
  );
  color: var(--color-warning);
  border: 1px solid
    rgba(var(--color-warning-rgb, 168, 75, 47), var(--status-border-opacity));
}

.status--info {
  background-color: rgba(
    var(--color-info-rgb, 98, 108, 113),
    var(--status-bg-opacity)
  );
  color: var(--color-info);
  border: 1px solid
    rgba(var(--color-info-rgb, 98, 108, 113), var(--status-border-opacity));
}

/* Container layout */
.container {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: var(--space-16);
  padding-left: var(--space-16);
}

@media (min-width: 640px) {
  .container {
    max-width: var(--container-sm);
  }
}
@media (min-width: 768px) {
  .container {
    max-width: var(--container-md);
  }
}
@media (min-width: 1024px) {
  .container {
    max-width: var(--container-lg);
  }
}
@media (min-width: 1280px) {
  .container {
    max-width: var(--container-xl);
  }
}

/* Utility classes */
.flex {
  display: flex;
}
.flex-col {
  flex-direction: column;
}
.items-center {
  align-items: center;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-4 {
  gap: var(--space-4);
}
.gap-8 {
  gap: var(--space-8);
}
.gap-16 {
  gap: var(--space-16);
}

.m-0 {
  margin: 0;
}
.mt-8 {
  margin-top: var(--space-8);
}
.mb-8 {
  margin-bottom: var(--space-8);
}
.mx-8 {
  margin-left: var(--space-8);
  margin-right: var(--space-8);
}
.my-8 {
  margin-top: var(--space-8);
  margin-bottom: var(--space-8);
}

.p-0 {
  padding: 0;
}
.py-8 {
  padding-top: var(--space-8);
  padding-bottom: var(--space-8);
}
.px-8 {
  padding-left: var(--space-8);
  padding-right: var(--space-8);
}
.py-16 {
  padding-top: var(--space-16);
  padding-bottom: var(--space-16);
}
.px-16 {
  padding-left: var(--space-16);
  padding-right: var(--space-16);
}

.block {
  display: block;
}
.hidden {
  display: none;
}

/* Accessibility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

:focus-visible {
  outline: var(--focus-outline);
  outline-offset: 2px;
}

/* Dark mode specifics */
[data-color-scheme="dark"] .btn--outline {
  border: 1px solid var(--color-border-secondary);
}

@font-face {
  font-family: 'FKGroteskNeue';
  src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2')
    format('woff2');
}

        /* Comprehensive Trading Journal Styles */
        .trading-journal {
            min-height: 100vh;
            background: #0f172a;
            color: #f8fafc;
        }

        .gradient-header {
            background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 2rem;
        }

        .section {
            background: #1e293b;
            border-radius: 12px;
            border: 1px solid #334155;
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .section-header {
            background: linear-gradient(90deg, #60a5fa 0%, #a78bfa 100%);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header h3 {
            margin: 0;
            color: white;
        }

        .section-content {
            padding: 1.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .stat-card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: transform 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            border-color: #60a5fa;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .positive { color: #10b981; }
        .negative { color: #ef4444; }
        .neutral { color: #6b7280; }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1rem;
        }

        .chart-container {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
        }

        .chart {
            height: 300px;
            position: relative;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            background: #60a5fa;
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #3b82f6;
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .trade-row {
            cursor: pointer;
            transition: background 0.2s;
        }

        .trade-row:hover {
            background: #334155;
        }

        .trade-details {
            background: #0f172a;
            padding: 1.5rem;
            border-top: 1px solid #334155;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .form-control {
            width: 100%;
            padding: 0.5rem;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 4px;
            color: white;
        }

        .form-control:focus {
            outline: none;
            border-color: #60a5fa;
        }

        .screenshot-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .screenshot {
            max-width: 100%;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .screenshot:hover {
            transform: scale(1.05);
        }

        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lightbox img {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
        }

        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
        }

        .rules-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .rule-card {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
        }

        .rule-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .calendar {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin: 1rem 0;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 0.75rem;
            position: relative;
            cursor: pointer;
            min-height: 40px;
            border: 1px solid transparent;
        }
        
        .calendar-day:hover {
            border-color: #60a5fa;
        }

        .calendar-day.has-trades {
            font-weight: bold;
        }

        .calendar-day.profit {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .calendar-day.loss {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .performance-section {
            margin-bottom: 2rem;
        }

        .breakdown-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .breakdown-item {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 1rem;
        }

        .breakdown-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .breakdown-stats {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .toggle-button {
            background: #374151;
            border: none;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .toggle-button.active {
            background: #60a5fa;
        }

        .message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .message.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        .message.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .collapsible {
            margin-bottom: 1rem;
        }

        .collapsible-header {
            background: #374151;
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-content {
            padding: 1rem;
            display: none;
        }

        .collapsible.open .collapsible-content {
            display: block;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #334155;
        }

        .table th {
            background: #374151;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .charts-grid,
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .download-notification {
                width: calc(100vw - 20px);
                right: 10px;
                left: 10px;
            }
        }
        
        @keyframes slide-down {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }
    

        /* Enhanced Screenshot and TradingView Button Styles */
        .screenshot-container {
            position: relative;
            display: inline-block;
        }

        .screenshot-container img {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .screenshot-container img:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
        }

        .btn-group {
            display: flex;
            gap: var(--space-8);
            align-items: center;
        }

        .btn-group .btn {
            flex: 1;
        }

        .btn-group .btn-icon {
            flex: none;
            padding: var(--space-8);
            min-width: 40px;
        }

        /* TradingView button specific styling */
        .btn-tradingview {
            background: linear-gradient(135deg, #2962FF, #1E88E5);
            color: white;
            border: none;
            font-weight: var(--font-weight-medium);
        }

        .btn-tradingview:hover:not(:disabled) {
            background: linear-gradient(135deg, #1E88E5, #1565C0);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-tradingview:disabled {
            background: var(--color-secondary);
            color: var(--color-text-secondary);
            cursor: not-allowed;
        }

        /* Screenshot upload button styling */
        .btn-screenshot {
            background: linear-gradient(135deg, #10B981, #059669);
            color: white;
            border: none;
            font-weight: var(--font-weight-medium);
        }

        .btn-screenshot:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        /* Clear button styling */
        .btn-clear {
            background: var(--color-error);
            color: white;
            border: none;
            padding: var(--space-8);
            min-width: 40px;
        }

        .btn-clear:hover {
            background: #DC2626;
            transform: translateY(-1px);
        }
    
    </style>
</head>
<body>
    <div class="trading-journal">
        <div style="max-width: 1200px; margin: 0 auto; padding: 2rem;">
            <!-- Header -->
            <h1 class="gradient-header">Comprehensive Trading Journal</h1>
            
            <!-- Controls -->
            <div class="controls">
                <input type="file" id="csvInput" class="file-input" accept=".csv" />
                <button class="btn" onclick="document.getElementById('csvInput').click()">
                    📄 Import CSV
                </button>

                <select id="platform" class="form-control" style="width: auto;">
                    <option value="ctrader">cTrader</option>
                    <option value="mt4">MT4</option>
                    <option value="mt5">MT5</option>
                </select>

                <select id="importMode" class="form-control" style="width: auto;">
                    <option value="overwrite">Overwrite</option>
                    <option value="append">Append</option>
                    <option value="update-open-datetime">Update Open Date/Time</option>
                </select>
                
                <input type="file" id="jsonInput" class="file-input" accept=".json" />
                <button class="btn btn-secondary" onclick="document.getElementById('jsonInput').click()">
                    📁 Import Data
                </button>
                
                <button class="btn btn-secondary" onclick="printTrades()" id="printBtn" disabled>
                    🖨️ Print
                </button>

                <!-- Export with dropdown -->
                <div class="export-menu-container" style="position: relative; display: inline-block;">
                    <button onclick="toggleExportMenu()" class="btn btn-secondary" id="exportBtn" disabled title="Export options">💾 Export ▾</button>

                    <!-- Export Options Dropdown -->
                    <div id="exportDropdown" style="display: none; position: absolute; top: 100%; left: 0; width: 320px; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); box-shadow: var(--shadow-lg); z-index: 2000; margin-top: 4px;">
                        <!-- Info box at top -->
                        <div style="padding: 12px; background: var(--color-bg-1); border-bottom: 1px solid var(--color-border);">
                            <div style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); margin-bottom: 4px; color: var(--color-primary);">
                                💾 Save Location
                            </div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">
                                Files save to your browser's default download folder (usually "Downloads")
                            </div>
                        </div>

                        <div style="padding: 8px;">
                            <button
                                onclick="handleExportData('full'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">📦 Full Export</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Everything (trades, screenshots, settings)
                                </div>
                            </button>

                            <button
                                onclick="handleExportData('trades-only'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">📊 Trades Only</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Just trade data (no screenshots or settings)
                                </div>
                            </button>

                            <button
                                onclick="handleExportData('no-screenshots'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">📋 Without Screenshots</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Trades and settings (smaller file size)
                                </div>
                            </button>

                            <button
                                onclick="handleExportData('screenshots-only'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">📸 Screenshots Only</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Just screenshots in JSON format (for backup/sharing)
                                </div>
                            </button>

                            <div style="border-top: 1px solid var(--color-border); margin: 8px 0;"></div>

                            <button
                                onclick="handleExportData('csv'); setShowExportMenu(false);"
                                style="width: 100%; text-align: left; padding: 12px; background: none; border: none; color: var(--color-text); border-radius: var(--radius-sm); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);"
                                onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'"
                                onmouseout="this.style.backgroundColor='transparent'">
                                <div style="font-weight: var(--font-weight-medium);">📄 Export as CSV</div>
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: 2px;">
                                    Trade data in CSV format (Excel compatible)
                                </div>
                            </button>
                        </div>

                        <!-- Size estimates at bottom -->
                        <div style="padding: 12px; background: var(--color-bg-8); border-top: 1px solid var(--color-border);">
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); display: grid; grid-template-columns: 1fr auto; gap: var(--space-8);">
                                <div>📦 Full Export:</div>
                                <div id="fullSizeEstimate">~calculating...</div>

                                <div>📋 Without Screenshots:</div>
                                <div id="noScreenshotsSizeEstimate">~calculating...</div>

                                <div>📸 Screenshots Only:</div>
                                <div id="screenshotsSizeEstimate">~calculating...</div>

                                <div>📊 Trades Only:</div>
                                <div id="tradesSizeEstimate">~calculating...</div>
                            </div>
                            <div style="text-align: center; margin-top: var(--space-8);">
                                <button
                                    onclick="showDownloadLocationInfo()"
                                    style="background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xs); cursor: pointer; text-decoration: underline;">
                                    Where do files save? 📂
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Download help button removed -->
            </div>

            <!-- Messages -->
            <div id="messages"></div>

            <!-- ACCOUNT SETTINGS SECTION - NEW LOCATION -->
            <div class="section" style="margin-bottom: 1.5rem;">
                <button
                    onclick="toggleAccountSettings()"
                    class="btn btn--outline"
                    style="width: 100%; display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); margin-bottom: 0; font-weight: var(--font-weight-medium);">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <span style="font-size: var(--font-size-lg);">⚙️</span>
                        <span>Account Settings</span>
                    </div>
                    <span id="accountSettingsArrow" style="font-size: var(--font-size-xl); transition: transform var(--duration-normal) var(--ease-standard);">▶</span>
                </button>

                <div id="accountSettingsContent" class="account-settings-content" style="display: none; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-top: none; border-radius: 0 0 var(--radius-base) var(--radius-base);">
                    <!-- Starting Balance -->
                    <div style="margin-bottom: 1rem;">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">
                            <span>💰</span>
                            <span>Starting Balance</span>
                        </label>
                        <div style="display: flex; gap: var(--space-8);">
                            <input
                                type="number"
                                id="editStartingBalance"
                                class="form-control"
                                style="flex: 1;"
                                placeholder="e.g., 100000"
                                onchange="updateStartingBalanceValue(this.value)">
                            <button
                                onclick="saveStartingBalance()"
                                class="btn btn--primary">Save</button>
                            <button
                                onclick="cancelStartingBalance()"
                                class="btn btn--secondary">Cancel</button>
                        </div>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4); margin-bottom: 0;">
                            Current: $<span id="currentStartingBalance">10,000.00</span>
                        </p>
                    </div>

                    <!-- Platform Selection -->
                    <div style="margin-bottom: 1rem;">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">
                            <span>🔧</span>
                            <span>Trading Platform</span>
                        </label>
                        <div style="display: flex; gap: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="platformRadio"
                                    value="ctrader"
                                    checked
                                    onchange="updatePlatform('ctrader')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">cTrader</div>
                                </div>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="platformRadio"
                                    value="mt4"
                                    onchange="updatePlatform('mt4')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">MT4</div>
                                </div>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="platformRadio"
                                    value="mt5"
                                    onchange="updatePlatform('mt5')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">MT5</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Import Mode -->
                    <div style="margin-bottom: 1rem;">
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium);">
                            <span>📥</span>
                            <span>CSV Import Mode</span>
                        </label>
                        <div style="display: flex; flex-direction: column; gap: var(--space-8);">
                            <div style="display: flex; gap: var(--space-8);">
                                <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                    <input
                                        type="radio"
                                        name="importModeRadio"
                                        value="overwrite"
                                        checked
                                        onchange="updateImportMode('overwrite')"
                                        style="accent-color: var(--color-primary);">
                                    <div>
                                        <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">Overwrite</div>
                                        <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Replace all trades</div>
                                    </div>
                                </label>
                                <label style="display: flex; align-items: center; gap: var(--space-8); flex: 1; padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                    <input
                                        type="radio"
                                        name="importModeRadio"
                                        value="append"
                                        onchange="updateImportMode('append')"
                                        style="accent-color: var(--color-primary);">
                                    <div>
                                        <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">Append</div>
                                        <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Add to existing</div>
                                    </div>
                                </label>
                            </div>
                            <label style="display: flex; align-items: center; gap: var(--space-8); padding: var(--space-8); background: var(--color-secondary); border-radius: var(--radius-base); cursor: pointer; transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='var(--color-secondary)'">
                                <input
                                    type="radio"
                                    name="importModeRadio"
                                    value="update-open-datetime"
                                    onchange="updateImportMode('update-open-datetime')"
                                    style="accent-color: var(--color-primary);">
                                <div>
                                    <div style="font-size: var(--font-size-sm); font-weight: var(--font-weight-medium);">Update Open Date/Time</div>
                                    <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Add opening date/time to existing trades without replacing data</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Clear Data - Danger Zone -->
                    <div>
                        <label class="form-label" style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8); font-weight: var(--font-weight-medium); color: var(--color-error);">
                            <span>🗑️</span>
                            <span>Danger Zone</span>
                        </label>
                        <button
                            onclick="clearAllData()"
                            class="btn"
                            style="width: 100%; background: var(--color-error); color: var(--color-btn-primary-text); font-weight: var(--font-weight-medium);">
                            Clear All Data
                        </button>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4); margin-bottom: 0;">
                            ⚠️ This will permanently delete all your trading data
                        </p>
                    </div>
                </div>
            </div>



            <!-- Statistics Dashboard -->
            <div class="section" id="statisticsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleStatistics()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">📊 Performance Statistics</h3>
                        <button
                            id="statisticsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: var(--space-8);">
                        <div style="display: flex; align-items: center; gap: var(--space-8); padding: var(--space-4) var(--space-12); background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                            <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">‹</button>
                            <span id="analyticsStatsMonthDisplay" style="font-weight: bold; min-width: 140px; text-align: center; font-size: var(--font-size-sm);"></span>
                            <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">›</button>
                        </div>
                        <button class="btn btn-secondary" onclick="resetToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time statistics">TOTAL</button>
                        <button class="toggle-button" onclick="toggleStatsConfig(); event.stopPropagation();" title="Configure Statistics">⚙️</button>
                    </div>
                </div>
                <div class="section-content">
                    <div id="statsConfigPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">📋 Configure Statistics Display</h4>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-12);">Check which statistics to display. Drag to reorder (future feature).</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--space-8);" id="statsConfigGrid">
                            <!-- Stats checkboxes will be generated here -->
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border);">
                            <button onclick="showAllStats()" style="background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xs); cursor: pointer; padding: 0;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Show All</button>
                            <button onclick="toggleStatsConfig()" class="btn btn--sm">Done</button>
                        </div>
                    </div>
                    <div class="stats-grid" id="statsGrid">
                        <!-- Stats cards will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Performance Charts -->
            <div class="section" id="chartsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleCharts()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">📈 Performance Charts</h3>
                        <button
                            id="chartsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: var(--space-8);">
                        <select id="chartZoomSelect" onchange="updateChartZoom(this.value); event.stopPropagation();" onclick="event.stopPropagation();" style="padding: var(--space-4) var(--space-8); background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-sm); color: var(--color-text); font-size: var(--font-size-xs);" title="Chart Zoom">
                            <option value="100">100%</option>
                            <option value="150">150%</option>
                            <option value="200">200%</option>
                            <option value="250">250%</option>
                            <option value="300">300%</option>
                        </select>
                        <button class="toggle-button" onclick="toggleChartsConfig(); event.stopPropagation();" title="Configure Charts">⚙️</button>
                    </div>
                </div>
                <div class="section-content">
                    <div id="chartsConfigPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">📊 Configure Charts Display</h4>
                        <div style="display: flex; flex-direction: column; gap: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="showEquityCurve" checked onchange="toggleChart('equityCurve', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Equity Curve</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="showDailyPL" checked onchange="toggleChart('dailyPL', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Daily P&L</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="showWinLoss" checked onchange="toggleChart('winLoss', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Win/Loss Distribution</span>
                            </label>
                        </div>
                        <div style="display: flex; justify-content: flex-end; margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border);">
                            <button onclick="toggleChartsConfig()" class="btn btn--sm">Done</button>
                        </div>
                    </div>
                    <div class="charts-grid">
                        <div class="chart-container" id="equityContainer">
                            <h4>Equity Curve</h4>
                            <div class="chart">
                                <canvas id="equityChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container" id="dailyPLContainer">
                            <h4>Daily P&amp;L</h4>
                            <div class="chart">
                                <canvas id="dailyPLChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-container" id="winLossContainer">
                            <h4>Win/Loss Distribution</h4>
                            <div class="chart">
                                <canvas id="winLossChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Trade History - COLLAPSIBLE -->
            <div class="section" id="tradeHistorySection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleTradeHistory()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">📋 Trade History</h3>
                        <button
                            id="tradeHistoryToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                        <span id="tradeHistoryCount" style="font-size: var(--font-size-sm); color: rgba(255,255,255,0.8); display: none;"></span>
                    </div>
                    <button class="toggle-button" onclick="toggleColumnConfig(); event.stopPropagation();" title="Configure Columns">⚙️</button>
                </div>
                <div class="section-content">
                    <!-- Column configuration (always visible when open) -->
                    <div id="columnsConfigPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">📋 Configure Table Columns</h4>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-12);">Select which columns to display in the trade history table.</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: var(--space-8);" id="columnsConfigGrid">
                            <!-- Column checkboxes will be generated here -->
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: var(--space-12); padding-top: var(--space-12); border-top: 1px solid var(--color-border);">
                            <button onclick="showAllColumns()" style="background: none; border: none; color: var(--color-primary); font-size: var(--font-size-xs); cursor: pointer; padding: 0;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Show All</button>
                            <button onclick="toggleColumnConfig()" class="btn btn--sm">Done</button>
                        </div>
                    </div>

                    <!-- Trade History Table - Collapsible -->
                    <div id="tradeHistoryTableContainer" class="trade-history-content">
                        <div style="overflow-x: auto;">
                            <table class="table">
                                <thead>
                                    <tr id="tableHeader">
                                        <!-- Headers will be generated -->
                                    </tr>
                                </thead>
                                <tbody id="tradesTableBody">
                                    <!-- Trade rows will be generated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Collapsed state message -->
                    <div id="tradeHistoryCollapsedMessage" style="display: none; padding: 2rem; background: rgba(var(--color-surface), 0.5); border-radius: var(--radius-base); border: 1px dashed var(--color-border); text-align: center;">
                        <p style="color: var(--color-text-secondary); margin: 0;">
                            Trade History collapsed. Click ▶ to expand and view <span id="collapsedTradeCount">0</span> trades.
                        </p>
                    </div>
                </div>
            </div>

            <!-- RULE COMBINATIONS ANALYSIS - NEW -->
            <div class="section" style="display: none;" id="ruleCombinationsSection">
                <div class="section-header" style="cursor: pointer;" onclick="toggleRuleCombinations()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">🔬 Rule Combinations Analysis</h3>
                        <button
                            id="ruleCombinationsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                        <span style="font-size: var(--font-size-xs); color: rgba(255,255,255,0.8);">
                            (Find best rule combinations)
                        </span>
                    </div>
                    <div style="display: flex; align-items: center; gap: var(--space-8);">
                        <div style="display: flex; align-items: center; gap: var(--space-8); padding: var(--space-4) var(--space-12); background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                            <button class="btn btn-secondary" onclick="changeRuleCombinationsMonth(-1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">‹</button>
                            <span id="ruleCombinationsMonthDisplay" style="font-weight: bold; min-width: 140px; text-align: center; font-size: var(--font-size-sm);"></span>
                            <button class="btn btn-secondary" onclick="changeRuleCombinationsMonth(1); event.stopPropagation();" style="padding: var(--space-4) var(--space-8); font-size: var(--font-size-xs);">›</button>
                        </div>
                        <button class="btn btn-secondary" onclick="resetRuleCombinationsToTotalView(); event.stopPropagation();" style="padding: var(--space-4) var(--space-12); font-size: var(--font-size-xs);" title="View all-time rule combinations">TOTAL</button>
                    </div>
                </div>
                <div class="section-content">
                    <div id="ruleCombinationsContent">
                        <p style="font-size: var(--font-size-sm); color: var(--color-text-secondary); margin-bottom: 1rem;">
                            This analysis shows performance for all possible combinations of your custom trading rules.
                            Find which rules work best together to maximize your win rate and profitability.
                        </p>

                        <div id="ruleCombinationsResults">
                            <!-- Results will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Custom Trading Rules -->
            <div class="section" id="rulesSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleRules()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">Custom Trading Rules</h3>
                        <button
                            id="rulesToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                    <button class="btn btn-secondary" onclick="addCustomRule(); event.stopPropagation();">+ Add Rule</button>
                </div>
                <div class="section-content">
                    <div class="rules-grid" id="rulesGrid">
                        <!-- Rules will be generated here -->
                    </div>
                    <div style="margin-top: 1rem;">
                        <h4>Rule Performance</h4>
                        <div id="ruleStats"></div>
                    </div>
                </div>
            </div>

            <!-- Performance Breakdowns -->
            <div class="section" id="breakdownsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleBreakdowns()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">Performance Breakdowns</h3>
                        <button
                            id="breakdownsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                </div>
                <div class="section-content">
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Setup Type</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="breakdownSetupMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div class="breakdown-grid" id="setupBreakdown"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Market Condition</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="breakdownMarketMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div class="breakdown-grid" id="marketBreakdown"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Emotional State</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="breakdownEmotionalMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div class="breakdown-grid" id="emotionalBreakdown"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>By Rule Adherence</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="breakdownRuleMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeBreakdownMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div class="breakdown-grid" id="ruleBreakdown"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Time-based Analytics -->
            <div class="section" id="timeAnalyticsSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleTimeAnalytics()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">Time-based Analytics</h3>
                        <button
                            id="timeAnalyticsToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                </div>
                <div class="section-content">
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>Monthly Performance</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="analyticsMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div id="monthlyStats"></div>
                        </div>
                    </div>
                    
                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>Daily Performance</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="analyticsDailyMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div id="dailyStats"></div>
                        </div>
                    </div>

                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>OPEN HOURLY PERFORMANCE</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="analyticsOpenHourlyMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div id="openHourlyStats"></div>
                        </div>
                    </div>

                    <div class="collapsible" onclick="toggleCollapsible(this)">
                        <div class="collapsible-header">
                            <span>CLOSE HOURLY PERFORMANCE</span>
                            <span>▼</span>
                        </div>
                        <div class="collapsible-content">
                            <div style="display: flex; justify-content: center; align-items: center; gap: var(--space-12); margin-bottom: 1rem; padding: 0.5rem; background: rgba(var(--color-surface), 0.3); border-radius: var(--radius-base);">
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(-1); event.stopPropagation();">‹ Prev</button>
                                <span id="analyticsCloseHourlyMonthDisplay" style="font-weight: bold; min-width: 150px; text-align: center;"></span>
                                <button class="btn btn-secondary" onclick="changeAnalyticsMonth(1); event.stopPropagation();">Next ›</button>
                            </div>
                            <div id="hourlyStats"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Calendar View -->
            <div class="section" id="calendarSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleCalendar()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">Calendar View</h3>
                        <button
                            id="calendarToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                    <div>
                        <button class="btn btn-secondary" onclick="changeMonth(-1); event.stopPropagation();">‹ Prev</button>
                        <span id="calendarMonth"></span>
                        <button class="btn btn-secondary" onclick="changeMonth(1); event.stopPropagation();">Next ›</button>
                    </div>
                </div>
                <div class="section-content">
                    <div class="calendar" id="calendar"></div>
                </div>
            </div>

            <!-- AI Analysis -->
            <div class="section" id="aiSection" style="display: none;">
                <div class="section-header" style="cursor: pointer;" onclick="toggleAI()">
                    <div style="display: flex; align-items: center; gap: var(--space-12);">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: var(--space-8);">🤖 AI Analysis</h3>
                        <button
                            id="aiToggle"
                            style="background: none; border: none; color: white; font-size: var(--font-size-xl); cursor: pointer; padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);"
                            title="Collapse/Expand"
                            onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                            onmouseout="this.style.backgroundColor='transparent'">▼</button>
                    </div>
                </div>
                <div class="section-content">
                    <!-- Strategy Context Box - NEW -->
                    <div style="margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">📋 Strategy Context (Optional)</h4>
                        <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-12);">
                            Describe your trading strategy to help AI provide more relevant insights. You can select an example below and customize it, or write your own from scratch.
                        </p>
                        
                        <!-- Example Strategy Selector -->
                        <div style="margin-bottom: var(--space-12);">
                            <label style="display: block; font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-bottom: var(--space-4);">
                                💡 Load Example Strategy:
                            </label>
                            <select
                                id="strategyExampleSelector"
                                class="form-control"
                                style="margin-bottom: var(--space-4);"
                                onchange="loadStrategyExample(this.value)">
                                <option value="">-- Select an example or write your own --</option>
                                <option value="ict">ICT (Inner Circle Trader) Strategy</option>
                                <option value="supplyDemand">Supply &amp; Demand Zones</option>
                                <option value="priceAction">Pure Price Action Day Trading</option>
                                <option value="breakout">Breakout Trading</option>
                                <option value="trendFollowing">Trend Following (MA Crossover)</option>
                                <option value="scalpingStrategy">Scalping Strategy</option>
                                <option value="swingTrading">Swing Trading</option>
                            </select>
                            <p style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">
                                💡 Select an example to load it, then customize it to match your specific approach
                            </p>
                        </div>
                        <textarea
                            id="strategyContextTextarea"
                            class="form-control"
                            rows="6"
                            placeholder="Describe your trading strategy, methodology, timeframes, risk management, entry/exit criteria, trading sessions, instruments, and goals..."
                            style="width: 100%; margin-bottom: var(--space-8); resize: vertical;"
                            maxlength="2000"
                            onchange="updateStrategyContext(this.value)"
                            oninput="updateStrategyContextCounter()"></textarea>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-8);">
                            <button
                                type="button"
                                onclick="clearStrategyContext()"
                                style="background: none; border: none; color: var(--color-error); font-size: var(--font-size-xs); cursor: pointer; padding: 0;"
                                onmouseover="this.style.textDecoration='underline'"
                                onmouseout="this.style.textDecoration='none'">Clear</button>
                            <div id="strategyContextCounter" style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">
                                0 / 2000 characters
                            </div>
                        </div>
                    </div>
                    
                    <!-- Include in Prompt checkboxes -->
                    <div style="margin-bottom: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base);">
                        <h4 style="font-size: var(--font-size-sm); font-weight: var(--font-weight-semibold); margin-bottom: var(--space-12); color: var(--color-text);">📋 Include in AI Prompt:</h4>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-8);">
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeOverview" checked onchange="updateAiPromptInclusion('overview', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Performance Overview</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeSetupPerformance" checked onchange="updateAiPromptInclusion('setupPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Setup Type Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeMarketCondition" checked onchange="updateAiPromptInclusion('marketCondition', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Market Conditions</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeEmotionalState" checked onchange="updateAiPromptInclusion('emotionalState', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Emotional State</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeRuleAdherence" checked onchange="updateAiPromptInclusion('ruleAdherence', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Rule Adherence</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeMonthlyPerformance" checked onchange="updateAiPromptInclusion('monthlyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Monthly Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeDailyPerformance" checked onchange="updateAiPromptInclusion('dailyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Daily Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeOpenHourlyPerformance" checked onchange="updateAiPromptInclusion('openHourlyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Open Hourly Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeCloseHourlyPerformance" checked onchange="updateAiPromptInclusion('closeHourlyPerformance', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Close Hourly Performance</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                                <input type="checkbox" id="includeCustomRules" checked onchange="updateAiPromptInclusion('customRules', this.checked)" style="border-radius: var(--radius-sm);">
                                <span>Custom Trading Rules</span>
                            </label>
                            <!-- Trade details dropdown replaces checkbox -->
                            <div style="grid-column: span 2; margin-top: var(--space-8); padding-top: var(--space-8); border-top: 1px solid var(--color-border);">
                                <label style="display: block; font-size: var(--font-size-sm); font-weight: var(--font-weight-medium); margin-bottom: var(--space-8); color: var(--color-text);">
                                    📝 Individual Trade Details:
                                </label>
                                <select id="tradesOption" class="form-control" onchange="updateAiPromptInclusion('tradesOption', this.value)" style="width: 100%;">
                                    <option value="none">None - Don't include trades</option>
                                    <option value="recent10">Recent 10 trades</option>
                                    <option value="recent20">Recent 20 trades</option>
                                    <option value="recent50">Recent 50 trades</option>
                                    <option value="all">All trades</option>
                                    <option value="winning">Winning trades only</option>
                                    <option value="losing">Losing trades only</option>
                                    <option value="bestWorst">Best 5 &amp; Worst 5 trades</option>
                                </select>
                                <p id="tradesOptionHelper" style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);"></p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Analysis Format</label>
                        <select id="analysisFormat" class="form-control" onchange="appState.exportPromptFormat = this.value">
                            <option value="readable">Easy to Read</option>
                            <option value="json">JSON Technical</option>
                        </select>
                    </div>
                    
                    <div style="display: flex; gap: var(--space-8); margin-bottom: var(--space-16);">
                        <button class="btn" onclick="generateAIAnalysisPrompt()">Generate AI Analysis</button>
                        <button class="btn btn-secondary" onclick="copyAIPromptToClipboard()" id="copyPromptBtn" disabled>📋 Copy Prompt</button>
                    </div>
                    
                    <div id="promptCopiedMessage" style="display: none; padding: var(--space-8); background: var(--color-bg-3); color: var(--color-success); border-radius: var(--radius-base); font-size: var(--font-size-sm); margin-bottom: var(--space-16);">✅ Prompt copied to clipboard!</div>
                    
                    <div id="analysisPrompt" style="margin-top: 1rem; display: none;">
                        <textarea id="promptText" class="form-control" rows="15" readonly></textarea>
                    </div>
                </div>
            </div>

            <!-- Download Notification -->
            <div id="downloadNotificationContainer"></div>

            <!-- Footer -->
            <footer style="margin-top: var(--space-32); padding-top: var(--space-16); border-top: 1px solid var(--color-border); text-align: center; font-size: var(--font-size-sm); color: var(--color-text-secondary);">
                <p>Trading Journal v2.1.0 | Built with Chart.js &amp; Modern Web Technologies</p>
                <p style="font-size: var(--font-size-xs); margin-top: var(--space-4);">© 2025 | Your complete trading analysis solution</p>
            </footer>

            <!-- Empty State -->
            <div id="emptyState" class="section" style="text-align: center; padding: 4rem 2rem;">
                <h2>📊 Welcome to Your Trading Journal</h2>
                <p style="color: #94a3b8; margin: 1rem 0;">Import your trading data to start analyzing your performance</p>
                <p style="font-size: 0.875rem; color: #6b7280;">Supported platforms: cTrader, MT4, MT5<br>
                <em>Note: Trades with numeric-only symbols will be automatically filtered out</em></p>
                <button class="btn" onclick="document.getElementById('csvInput').click()" style="margin-top: 1rem;">
                    📄 Import Your First CSV
                </button>
            </div>
        </div>
    </div>

    <!-- Lightbox for screenshots -->
    <div id="lightbox" class="lightbox" style="display: none;" onclick="closeLightbox()">
        <button class="lightbox-close" onclick="closeLightbox()">×</button>
        <img id="lightboxImage" alt="Trade Screenshot">
    </div>

    <script>
        // ============================================================================
        // SECURITY FUNCTIONS - Added for XSS and injection protection
        // ============================================================================
        
        // Security: HTML sanitization helper
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Security: URL sanitization helper
        function sanitizeUrl(url) {
            if (!url) return '';
            try {
                const urlObj = new URL(url);
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    return '';
                }
                return urlObj.href;
            } catch {
                return '';
            }
        }

        // Security: Safe URL opener with validation
        function safeOpenURL(url) {
            if (!url || !url.trim()) {
                showMessage('Please enter a valid URL first', 'error');
                return;
            }
            try {
                const fullUrl = url.startsWith('http') ? url : 'https://' + url;
                const urlObj = new URL(fullUrl);
                if (!['http:', 'https:'].includes(urlObj.protocol)) {
                    throw new Error('Invalid protocol - only HTTP and HTTPS are allowed');
                }
                window.open(urlObj.href, '_blank', 'noopener,noreferrer');
            } catch (error) {
                showMessage('Invalid URL: ' + error.message, 'error');
            }
        }

        // Security: File size validation constant
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB

        // Security: Trade data validation
        function validateTrade(trade) {
            if (!trade || typeof trade !== 'object') {
                throw new Error('Invalid trade object');
            }
            if (!trade.symbol || typeof trade.symbol !== 'string' || trade.symbol.length === 0) {
                throw new Error('Invalid symbol');
            }
            if (!Number.isFinite(trade.entryPrice) || trade.entryPrice < 0) {
                throw new Error('Invalid entry price');
            }
            if (!Number.isFinite(trade.exitPrice) || trade.exitPrice < 0) {
                throw new Error('Invalid exit price');
            }
            return true;
        }

        // ============================================================================
        // END SECURITY FUNCTIONS
        // ============================================================================

        // Symbol Validation Function
        // Filters out numeric-only symbols (e.g. "123", "456789") during import
        // Valid symbols: "EURUSD", "GBPUSD", "US30", "BTC-USD", etc.
        // Invalid symbols: "123", "456789", "001", "999", etc.
        function isValidSymbol(symbol) {
            if (!symbol || typeof symbol !== 'string') return false;
            // Skip if symbol is only digits (regex matches start-to-end digits only)
            if (/^\d+$/.test(symbol)) return false;
            // Must contain at least one letter or valid symbol character
            return /[a-zA-Z]/.test(symbol);
        }

        // Strategy Examples Object
        const strategyExamples = {
            ict: `I trade using ICT (Inner Circle Trader) concepts including market structure, order blocks, fair value gaps, and liquidity sweeps. I focus on 15-minute and 1-hour timeframes during London and New York sessions. My entry criteria include waiting for liquidity sweeps above/below key levels, followed by a market structure shift, and entering on pullbacks to order blocks or fair value gaps. I target a minimum 2:1 risk-reward ratio and risk 1-2% per trade. I primarily trade EURUSD, GBPUSD, and USDJPY.`,
            
            supplyDemand: `I trade supply and demand zones with confirmation from technical indicators. I look for fresh zones where price has spent minimal time, preferring zones with strong rejection wicks. I use stochastic oscillator for overbought/oversold confirmation and enter on reversal patterns at zone boundaries. I trade on 1-hour and 4-hour charts across all trading sessions. My targets are set at 3:1 minimum risk-reward ratio with a trailing stop to capture extended moves.`,
            
            priceAction: `I'm a pure price action day trader focusing on key support/resistance levels and candlestick patterns. I trade exclusively on 5-minute charts during the New York session (8 AM - 12 PM EST). My setup includes identifying key levels from higher timeframes, waiting for price to reach these levels, and entering on reversal candlestick patterns (pin bars, engulfing, inside bars). I use fixed stops at 20 pips and targets at 40 pips for consistent 2:1 risk-reward.`,
            
            breakout: `I trade breakout strategies on range-bound markets. I identify consolidation zones on 1-hour and 4-hour charts, mark key support and resistance levels, and wait for volume confirmation on the breakout. I enter on the first pullback after breakout with stops below/above the breakout level. My targets are measured moves (height of the range projected from breakout point). I focus on major forex pairs and trade during high liquidity sessions.`,
            
            trendFollowing: `I follow established trends using moving average crossovers (20/50 EMA) on daily charts. I only trade in the direction of the major trend and wait for pullbacks to key moving averages for entry. I use higher highs/higher lows for uptrends and lower highs/lower lows for downtrends to confirm trend continuation. Position sizing is 1% risk per trade with stops below recent swing lows/highs. I trail stops using the 20 EMA and target previous highs/lows.`,
            
            scalpingStrategy: `I scalp forex markets on 1-minute and 5-minute charts during high volatility sessions (London open and NY open). I use a combination of Bollinger Bands and RSI to identify overbought/oversold conditions at key levels. My entries are quick with tight 5-10 pip stops and targets of 10-15 pips for 1.5:1 to 2:1 RR. I limit myself to 10 trades per day maximum and stop trading after 3 consecutive losses. I primarily scalp EURUSD and GBPUSD due to tight spreads.`,
            
            swingTrading: `I swing trade forex using weekly and daily chart analysis. I identify major support and resistance zones, trend lines, and chart patterns (triangles, flags, head and shoulders). I enter on confirmations from daily chart and hold positions for several days to weeks. My risk management includes 2% risk per trade with stops at logical levels (below structure, not arbitrary pips). Targets are based on measured moves or next major resistance/support zone. I review positions once daily and avoid intraday noise.`
        };

        // Global State Management
        let appState = {
            downloadNotification: null,
            showExportMenu: false,
            trades: [],
            startingBalance: 10000,
            currentBalance: 10000,
            customRules: [],
            statistics: {},
            chartInstances: {},
            activeTradeIndex: null,
            activePasteTarget: 'entry', // 'entry' or 'exit'
            viewSettings: {
                showStats: {
                    totalTrades: true,
                    winningTrades: true,
                    losingTrades: true,
                    winRate: true,
                    rulesWinRate: true,
                    netPL: true,
                    totalFees: true,
                    profitFactor: true,
                    avgWin: true,
                    avgLoss: true,
                    largestWin: true,
                    largestLoss: true,
                    expectancy: true,
                    accountGrowth: true,
                    currentBalance: true,
                    startingBalance: true
                },
                showColumns: {
                    date: true,
                    time: true,
                    symbol: true,
                    direction: true,
                    entry: true,
                    exit: true,
                    pips: true,
                    pl: true,
                    setup: true
                },
                showCharts: {
                    equity: true,
                    dailyPL: true,
                    winLoss: true
                }
            },
            currentMonth: new Date().getMonth(),
            currentYear: new Date().getFullYear(),
            // Monthly analytics navigation state
            analyticsCurrentMonth: -1,  // -1 means "TOTAL (All Time)" view
            analyticsCurrentYear: new Date().getFullYear(),
            // Rule combinations navigation state
            ruleCombinationsCurrentMonth: -1,  // -1 means "TOTAL (All Time)" view
            ruleCombinationsCurrentYear: new Date().getFullYear(),
            // Performance breakdowns navigation state
            breakdownCurrentMonth: -1,  // -1 means "TOTAL (All Time)" view
            breakdownCurrentYear: new Date().getFullYear(),
            aiPromptInclusions: {
                overview: true,
                setupPerformance: true,
                marketCondition: true,
                emotionalState: true,
                ruleAdherence: true,
                monthlyPerformance: true,
                dailyPerformance: true,
                openHourlyPerformance: true,
                closeHourlyPerformance: true,
                customRules: true,
                tradesOption: 'none',  // Changed from boolean to string with options
                screenshots: false  // Don't include screenshots in prompt
            },
            exportPromptFormat: 'readable',
            showPromptCopied: false,
            strategyContext: '',
            // Configuration state
            showStatsConfig: false,
            showChartsConfig: false,
            showColumnsConfig: false,
            chartZoom: 100,
            // UI Collapse States
            showTradeHistory: true,
            showAccountSettings: false,
            showRuleCombinations: false,
            showStatistics: true,
            showCharts: true,
            showRules: true,
            showBreakdowns: true,
            showTimeAnalytics: true,
            showCalendar: true,
            showAI: true,
            visibleStats: {
                startingBalance: true,
                currentBalance: true,
                accountGrowth: true,
                totalTrades: true,
                winningTrades: true,
                losingTrades: true,
                winRate: true,
                rulesWinRate: true,
                profitFactor: true,
                netPL: true,
                avgWin: true,
                avgLoss: true,
                largestWin: true,
                largestLoss: true,
                expectancy: true,
                totalFees: true,
                // Phase 1 New Stats
                maxDrawdown: true,
                maxDrawdownPercent: true,
                recoveryFactor: true,
                currentStreak: true,
                longestWinStreak: true,
                longestLossStreak: true,
                riskRewardRatio: true,
                avgTradeDuration: true
            },
            visibleCharts: {
                equityCurve: true,
                dailyPL: true,
                winLoss: true
            },
            visibleColumns: {
                openDate: true,
                openTime: true,
                date: true,
                time: true,
                symbol: true,
                direction: true,
                entry: true,
                exit: true,
                pips: true,
                pl: true,
                setup: true
            }
        };

        // Setup type options
        const setupTypes = ['Breakout', 'Pullback', 'Reversal', 'Range', 'Trend Following'];
        const marketConditions = ['Trending', 'Ranging', 'Volatile'];
        const emotionalStates = ['Confident', 'Uncertain', 'Fearful', 'Greedy', 'Disciplined', 'Impulsive'];
        const ruleAdherence = ['Perfect', 'Custom', 'Partial', 'None'];

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            initializeDefaultRules();
            initializeUIStates();
            updateUI();
        });
        
        function initializeUIStates() {
            // Initialize account settings collapse state
            updateAccountSettingsCollapseState();
            
            // Initialize trade history collapse state
            updateTradeHistoryCollapseState();
            
            // Initialize starting balance display
            updateStartingBalanceDisplay();
            
            // Sync import mode selector with radio buttons
            const importModeValue = document.getElementById('importMode').value;
            const radioButton = document.querySelector(`input[name="importModeRadio"][value="${importModeValue}"]`);
            if (radioButton) {
                radioButton.checked = true;
            }
        }

        function setupEventListeners() {
            document.getElementById('csvInput').addEventListener('change', handleCSVImport);
            document.getElementById('jsonInput').addEventListener('change', handleJSONImport);
            
            // Click outside to close export menu
            document.addEventListener('click', function(e) {
                if (appState.showExportMenu && !e.target.closest('.export-menu-container')) {
                    setShowExportMenu(false);
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeLightbox();
                }
            });
            
            // Paste event for screenshots
            document.addEventListener('paste', handlePaste);
        }

        function initializeDefaultRules() {
            appState.customRules = [
                { id: 1, text: 'Wait for confirmation candle', enabled: true },
                { id: 2, text: 'Risk no more than 2% per trade', enabled: true },
                { id: 3, text: 'Check higher timeframe trend', enabled: true }
            ];
        }


        // Utility Functions
        function showMessage(message, type = 'success') {
            const messagesDiv = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.textContent = message;
            messagesDiv.innerHTML = '';
            messagesDiv.appendChild(messageEl);
            
            setTimeout(() => {
                if (messageEl.parentNode) {
                    messageEl.parentNode.removeChild(messageEl);
                }
            }, 5000);
        }

        function formatCurrency(amount) {
            return '$' + amount.toFixed(2);
        }

        function formatPercentage(value) {
            return value.toFixed(1) + '%';
        }

        function formatDuration(milliseconds) {
            if (milliseconds === 0) return '0m';

            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                const remainingHours = hours % 24;
                return remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days}d`;
            } else if (hours > 0) {
                const remainingMinutes = minutes % 60;
                return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
            } else if (minutes > 0) {
                return `${minutes}m`;
            } else {
                return `${seconds}s`;
            }
        }

        function updateUI() {
            const hasData = appState.trades.length > 0;
            
            // Show/hide sections
            document.getElementById('emptyState').style.display = hasData ? 'none' : 'block';
            // Account Settings section is always visible after import
            document.getElementById('statisticsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('chartsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('tradeHistorySection').style.display = hasData ? 'block' : 'none';
            document.getElementById('ruleCombinationsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('rulesSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('breakdownsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('timeAnalyticsSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('calendarSection').style.display = hasData ? 'block' : 'none';
            document.getElementById('aiSection').style.display = hasData ? 'block' : 'none';
            
            // Enable buttons
            document.getElementById('exportBtn').disabled = !hasData;
            document.getElementById('printBtn').disabled = !hasData;
            
            if (hasData) {
                calculateStatistics();
                updateStatisticsDisplay();
                updateChartsDisplay();
                updateTradesTable();
                updateCustomRulesDisplay();
                updatePerformanceBreakdowns();
                updateTimeAnalytics();
                updateCalendarView();
                updateRuleCombinationsMonthDisplay();
                updateRuleCombinationsAnalysis();

                // Initialize chart zoom selector
                document.getElementById('chartZoomSelect').value = appState.chartZoom;
                
                // Update collapse states
                updateTradeHistoryCollapseState();
                updateAccountSettingsCollapseState();
                updateStartingBalanceDisplay();
            }
        }

        // CSV Import Functions

        // Helper function to generate a unique fingerprint for a trade
        function getTradeFingerprint(trade) {
            // Create a unique identifier based on key trade properties
            return `${trade.symbol}_${trade.openDate}_${trade.openTime}_${trade.date}_${trade.time}_${trade.entryPrice}_${trade.exitPrice}_${trade.volume}`;
        }

        // Helper function to calculate similarity between existing and new trades
        function calculateTradeSimilarity(existingTrades, newTrades) {
            if (existingTrades.length === 0) {
                return 0; // No existing trades, 0% similarity
            }

            const existingFingerprints = new Set(existingTrades.map(t => getTradeFingerprint(t)));
            const matchingCount = newTrades.filter(t => existingFingerprints.has(getTradeFingerprint(t))).length;

            return (matchingCount / newTrades.length) * 100;
        }

        function handleCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Security: File size validation
            if (file.size > MAX_FILE_SIZE) {
                showMessage(`File too large. Maximum size: ${MAX_FILE_SIZE / (1024 * 1024)}MB`, 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.csv')) {
                showMessage('Please select a CSV file', 'error');
                return;
            }

            const mode = document.getElementById('importMode').value;
            const platform = document.getElementById('platform').value;
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;

                    // Route to appropriate parser based on platform
                    let result;
                    if (platform === 'mt4') {
                        result = parseMT4CSV(csvText);
                    } else if (platform === 'mt5') {
                        result = parseMT5CSV(csvText);
                    } else {
                        result = parseCSV(csvText); // cTrader
                    }
                    
                    if (result.trades.length === 0) {
                        showMessage('❌ Error: No valid trades found in CSV file', 'error');
                        return;
                    }

                    // Calculate similarity between existing and new trades
                    const similarity = calculateTradeSimilarity(appState.trades, result.trades);
                    console.log(`Trade similarity: ${similarity.toFixed(2)}%`);

                    // Intelligent merge: if 90% or more of data is the same, add only missing trades
                    if (appState.trades.length > 0 && similarity >= 90) {
                        // Smart merge: add only new trades that don't exist
                        const existingFingerprints = new Set(appState.trades.map(t => getTradeFingerprint(t)));
                        const newTrades = result.trades.filter(t => !existingFingerprints.has(getTradeFingerprint(t)));

                        if (newTrades.length > 0) {
                            appState.trades = [...appState.trades, ...newTrades];
                            if (result.skippedCount > 0) {
                                showMessage(`✅ Smart merge: Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} existing, ${result.skippedCount} invalid symbols skipped)`);
                            } else {
                                showMessage(`✅ Smart merge: Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} already exist)`);
                            }
                        } else {
                            showMessage(`ℹ️ No new trades to add - all ${result.trades.length} trades already exist`);
                        }
                    } else if (mode === 'overwrite') {
                        // Overwrite mode: replace all trades
                        appState.trades = result.trades;
                        appState.startingBalance = result.startingBalance || 10000;
                        // Update import mode to match the selected radio button
                        const checkedMode = document.querySelector('input[name="importModeRadio"]:checked');
                        if (checkedMode) {
                            document.getElementById('importMode').value = checkedMode.value;
                        }
                        if (result.skippedCount > 0) {
                            showMessage(`✅ Imported ${result.trades.length} trades (${result.skippedCount} skipped - invalid symbols)`);
                        } else {
                            showMessage(`✅ Imported ${result.trades.length} trades successfully`);
                        }
                    } else if (mode === 'append') {
                        // Append mode with duplicate detection
                        const existingFingerprints = new Set(appState.trades.map(t => getTradeFingerprint(t)));
                        const newTrades = result.trades.filter(t => !existingFingerprints.has(getTradeFingerprint(t)));
                        appState.trades = [...appState.trades, ...newTrades];
                        if (result.skippedCount > 0) {
                            showMessage(`✅ Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} duplicates, ${result.skippedCount} invalid symbols skipped)`);
                        } else {
                            showMessage(`✅ Added ${newTrades.length} new trades (${result.trades.length - newTrades.length} duplicates skipped)`);
                        }
                    } else if (mode === 'update-open-datetime') {
                        // Update Open Date/Time mode: merge opening date/time without replacing other data
                        let updatedCount = 0;
                        let notFoundCount = 0;

                        // Create a map of existing trades using a fingerprint WITHOUT openDate/openTime
                        const existingTradesMap = new Map();
                        appState.trades.forEach(trade => {
                            const key = `${trade.symbol}_${trade.date}_${trade.time}_${trade.entryPrice}_${trade.exitPrice}_${trade.volume}`;
                            existingTradesMap.set(key, trade);
                        });

                        // Update matching trades with new openDate and openTime
                        result.trades.forEach(newTrade => {
                            const key = `${newTrade.symbol}_${newTrade.date}_${newTrade.time}_${newTrade.entryPrice}_${newTrade.exitPrice}_${newTrade.volume}`;
                            const existingTrade = existingTradesMap.get(key);

                            if (existingTrade) {
                                // Update only openDate and openTime fields
                                existingTrade.openDate = newTrade.openDate;
                                existingTrade.openTime = newTrade.openTime;
                                updatedCount++;
                            } else {
                                notFoundCount++;
                            }
                        });

                        if (updatedCount > 0) {
                            if (result.skippedCount > 0) {
                                showMessage(`✅ Updated ${updatedCount} trades with opening date/time (${notFoundCount} not matched, ${result.skippedCount} invalid symbols skipped)`);
                            } else {
                                showMessage(`✅ Updated ${updatedCount} trades with opening date/time (${notFoundCount} not matched)`);
                            }
                        } else {
                            showMessage(`ℹ️ No matching trades found to update. Processed ${result.trades.length} trades from CSV.`);
                        }
                    }

                    updateUI();
                    
                    // Auto-expand trade history after successful import
                    if (result.trades.length > 0) {
                        appState.showTradeHistory = true;
                        updateTradeHistoryCollapseState();
                    }
                } catch (error) {
                    console.error('CSV parsing error:', error);
                    showMessage('❌ Error: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        }
        
        // Download Notification Functions
        function showDownloadNotification(data) {
            const container = document.getElementById('downloadNotificationContainer');
            
            const notification = document.createElement('div');
            notification.className = 'download-notification';
            notification.innerHTML = `
                <div style="padding: var(--space-16);">
                    <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: var(--space-12);">
                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-8);">
                                <span style="font-size: var(--font-size-xl);">✅</span>
                                <span style="font-weight: var(--font-weight-bold); color: white;">Download Started!</span>
                            </div>
                            
                            <div style="font-size: var(--font-size-sm); color: rgba(255, 255, 255, 0.9); margin-bottom: var(--space-8);">
                                <div style="display: flex; align-items: center; gap: var(--space-8); margin-bottom: var(--space-4);">
                                    <span>📄</span>
                                    <span style="font-family: var(--font-family-mono); font-size: var(--font-size-xs); word-break: break-all;">
                                        ${data.filename}
                                    </span>
                                </div>
                                <div style="display: flex; align-items: center; gap: var(--space-8);">
                                    <span>🕐</span>
                                    <span>${data.timestamp}</span>
                                </div>
                            </div>
                            
                            <div style="padding-top: var(--space-12); border-top: 1px solid rgba(255, 255, 255, 0.2); margin-bottom: var(--space-12);">
                                <div style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); color: white; margin-bottom: var(--space-8);">
                                    <strong>📂 Check your Downloads folder:</strong>
                                </div>
                                <div style="font-size: var(--font-size-xs); color: rgba(255, 255, 255, 0.9); line-height: 1.4;">
                                    • Look at bottom of browser window<br>
                                    • Open File Explorer → Downloads<br>
                                    • Press Ctrl+J (Chrome) or Cmd+Shift+J (Mac)
                                </div>
                            </div>
                            
                            <button onclick="showDetailedInstructions()" style="background: white; color: #10b981; border: none; padding: var(--space-6) var(--space-12); border-radius: var(--radius-base); font-size: var(--font-size-sm); font-weight: var(--font-weight-medium); cursor: pointer; transition: all var(--duration-fast) var(--ease-standard);" onmouseover="this.style.background='#f0f9ff'" onmouseout="this.style.background='white'">
                                📖 Detailed Instructions
                            </button>
                        </div>
                        
                        <button onclick="hideDownloadNotification()" style="background: none; border: none; color: white; font-size: var(--font-size-lg); cursor: pointer; margin-left: var(--space-8); padding: var(--space-4); border-radius: var(--radius-sm); transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                            ✕
                        </button>
                    </div>
                </div>
            `;
            
            container.appendChild(notification);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                hideDownloadNotification();
            }, 10000);
        }
        
        function hideDownloadNotification() {
            const container = document.getElementById('downloadNotificationContainer');
            const notification = container.querySelector('.download-notification');
            if (notification) {
                notification.style.animation = 'slide-down 0.3s ease-out';
                setTimeout(() => {
                    container.removeChild(notification);
                }, 300);
            }
        }
        
        function showDetailedInstructions() {
            alert(
                '📂 FINDING YOUR DOWNLOAD\n\n' +
                '1️⃣ BROWSER DOWNLOAD BAR\n' +
                '   Look at the BOTTOM of your browser window\n' +
                '   You should see the file downloading there\n\n' +
                '2️⃣ OPEN DOWNLOADS FOLDER\n' +
                '   Windows: Press Ctrl+J in Chrome/Edge\n' +
                '   Mac: Press Cmd+Shift+J or Cmd+Option+L\n' +
                '   Or manually open: File Explorer → Downloads\n\n' +
                '3️⃣ FILE LOCATION\n' +
                '   Windows: C:\\Users\\YourName\\Downloads\n' +
                '   Mac: /Users/YourName/Downloads\n' +
                '   Linux: ~/Downloads\n\n' +
                '4️⃣ BROWSER SETTINGS\n' +
                '   Check browser settings if downloads aren\'t working:\n' +
                '   Settings → Downloads → Choose location\n\n' +
                '5️⃣ POP-UP BLOCKER\n' +
                '   Make sure pop-ups are allowed for this site'
            );
        }
        
        // Test Download Function
        function testDownload() {
            try {
                const testData = {
                    test: 'This is a test download',
                    timestamp: new Date().toISOString(),
                    message: 'If you can see this file, downloads are working correctly!'
                };
                const blob = new Blob([JSON.stringify(testData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'test-download.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show test download notification
                showDownloadNotification({
                    filename: 'test-download.json',
                    type: 'test',
                    timestamp: new Date().toLocaleTimeString()
                });
                
                alert(
                    '✅ TEST DOWNLOAD STARTED\n\n' +
                    'Check your Downloads folder for:\n' +
                    'test-download.json\n\n' +
                    'If you see it, downloads are working!\n' +
                    'If not, check:\n' +
                    '1. Browser download settings\n' +
                    '2. Pop-up blocker settings\n' +
                    '3. Try a different browser'
                );
            } catch (error) {
                alert('❌ Download test failed: ' + error.message);
            }
        }
        
        // Download Help Functions
        function toggleDownloadHelp() {
            const helpSection = document.getElementById('downloadHelpSection');
            const isVisible = helpSection.style.display !== 'none';
            helpSection.style.display = isVisible ? 'none' : 'block';
        }

        function parseCSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim());
                
                // Find sections in cTrader format
                let dealsStartIndex = -1;
                let summaryStartIndex = -1;
                let balanceStartIndex = -1;
                let startingBalance = 10000;
                
                // Look for section headers (case insensitive)
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim().toLowerCase();
                    if (line === 'deals' || line.includes('deals')) {
                        dealsStartIndex = i;
                    } else if (line === 'summary' || line.includes('summary')) {
                        summaryStartIndex = i;
                    } else if (line === 'balance' || line.includes('balance')) {
                        balanceStartIndex = i;
                    }
                }
                
                // Extract starting balance from Summary section
                if (summaryStartIndex !== -1) {
                    // Look for deposit/starting balance in summary section
                    for (let i = summaryStartIndex + 1; i < Math.min(summaryStartIndex + 10, lines.length); i++) {
                        const line = lines[i].trim();
                        
                        // Skip empty lines
                        if (!line) continue;
                        
                        // Check if this is a header line containing 'Deposit'
                        if (line.toLowerCase().includes('deposit')) {
                            // Look for the corresponding data in next few lines
                            for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                                const dataLine = lines[j].trim();
                                if (!dataLine || dataLine.toLowerCase().includes('deposit')) continue;
                                
                                const parts = dataLine.split(',');
                                if (parts.length > 0) {
                                    // First column should be Deposit (starting balance)
                                    const depositStr = parts[0].trim();
                                    // Remove spaces and parse: "100 000.00" -> 100000.00
                                    const cleanDeposit = depositStr.replace(/\s+/g, '').replace(/[^\d.-]/g, '');
                                    const deposit = parseFloat(cleanDeposit);
                                    if (!isNaN(deposit) && deposit > 0) {
                                        startingBalance = deposit;
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                        
                        // Alternative: look for any line with a large number (potential balance)
                        const possibleBalance = line.replace(/[^\d\s.-]/g, '').trim();
                        if (possibleBalance) {
                            const cleanBalance = possibleBalance.replace(/\s+/g, '');
                            const balance = parseFloat(cleanBalance);
                            if (!isNaN(balance) && balance > 1000) {
                                startingBalance = balance;
                                break;
                            }
                        }
                    }
                }
                
                // Parse trades from Deals section
                if (dealsStartIndex === -1) {
                    throw new Error('Invalid file format - Deals section not found. Please ensure this is a cTrader CSV export.');
                }
                
                let headerIndex = -1;
                let dataStartIndex = -1;
                
                // Find the header line in Deals section (more flexible matching)
                for (let i = dealsStartIndex + 1; i < Math.min(dealsStartIndex + 10, lines.length); i++) {
                    const line = lines[i].trim().toLowerCase();
                    // Check for key columns that indicate this is the header
                    if ((line.includes('symbol') || line.includes('instrument')) && 
                        (line.includes('direction') || line.includes('side')) && 
                        (line.includes('price') || line.includes('entry') || line.includes('open'))) {
                        headerIndex = i;
                        dataStartIndex = i + 1;
                        break;
                    }
                }
                
                if (headerIndex === -1) {
                    // Try alternative approach - look for any line with multiple columns
                    for (let i = dealsStartIndex + 1; i < Math.min(dealsStartIndex + 10, lines.length); i++) {
                        const line = lines[i].trim();
                        const parts = parseCSVLine(line);
                        if (parts.length >= 8) { // Minimum expected columns
                            headerIndex = i;
                            dataStartIndex = i + 1;
                            console.log('Using fallback header detection at line:', i);
                            break;
                        }
                    }
                }
                
                if (headerIndex === -1) {
                    throw new Error('Invalid file format - Could not find trade data header in Deals section');
                }
                
                const headerLine = lines[headerIndex];
                const headers = parseCSVLine(headerLine).map(h => h.trim().toLowerCase());
                
                // Map columns for cTrader format
                const columnMap = {
                    symbol: findColumnIndex(headers, ['symbol', 'instrument', 'pair']),
                    direction: findColumnIndex(headers, ['opening direction', 'direction', 'side', 'type']),
                    openingTime: findColumnIndex(headers, ['opening time (utc-4)', 'opening time', 'open time', 'entry time']),
                    closingTime: findColumnIndex(headers, ['closing time (utc-4)', 'closing time', 'close time', 'time', 'date']),
                    entryPrice: findColumnIndex(headers, ['entry price', 'open price', 'opening price', 'price']),
                    closingPrice: findColumnIndex(headers, ['closing price', 'close price', 'exit price']),
                    closingQuantity: findColumnIndex(headers, ['closing quantity', 'quantity', 'volume', 'size', 'lots']),
                    swap: findColumnIndex(headers, ['swap', 'rollover']),
                    commissions: findColumnIndex(headers, ['commissions', 'commission', 'fee']),
                    pips: findColumnIndex(headers, ['pips', 'points']),
                    grossUSD: findColumnIndex(headers, ['gross usd', 'gross p&l', 'gross pl', 'gross']),
                    netUSD: findColumnIndex(headers, ['net usd', 'net p&l', 'net pl', 'net', 'profit']),
                    balanceUSD: findColumnIndex(headers, ['balance usd', 'balance', 'running balance'])
                };
                
                console.log('Column mapping:', columnMap);
                console.log('Headers found:', headers);
                
                const trades = [];
                const skippedTrades = [];
                let tradeIndex = 1;
                
                // Parse trade data
                for (let i = dataStartIndex; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    // Stop if we hit another section or empty line starting with commas
                    if (!line || line === 'Summary' || line === 'Balance' || line.match(/^,+$/)) {
                        break;
                    }
                    
                    try {
                        const cells = parseCSVLine(line);
                        
                        // Skip if not enough columns or if symbol is empty
                        if (cells.length < 3) {
                            continue;
                        }
                        
                        // Check if we have a valid symbol
                        const symbolCell = columnMap.symbol >= 0 ? cells[columnMap.symbol] : cells[0];
                        if (!symbolCell || !symbolCell.trim() || symbolCell.trim().length < 2) {
                            continue;
                        }
                        
                        // SYMBOL FILTERING: Skip trades with numeric-only symbols
                        if (!isValidSymbol(symbolCell.trim())) {
                            skippedTrades.push({
                                symbol: symbolCell.trim(),
                                line: i + 1
                            });
                            console.log(`Filtered out trade with invalid symbol: "${symbolCell.trim()}" (numeric-only)`);
                            continue;
                        }
                        
                        // Parse opening time: "06 Oct 2025 04:29:33.732"
                        const openingTimeStr = columnMap.openingTime >= 0 ? cells[columnMap.openingTime] : '';
                        const openDateTime = parsecTraderDateTime(openingTimeStr);

                        // Parse closing time: "06 Oct 2025 04:29:33.732"
                        const closingTimeStr = columnMap.closingTime >= 0 ? cells[columnMap.closingTime] : '';
                        const { date, time } = parsecTraderDateTime(closingTimeStr);
                        
                        // Parse volume: "0.1 Lots" -> 0.1
                        const volumeStr = columnMap.closingQuantity >= 0 ? cells[columnMap.closingQuantity] : '1';
                        const volume = parseFloat(volumeStr.replace(/[^\d.-]/g, '')) || 1;
                        
                        // Parse balance: "100 003.84" -> 100003.84
                        const balanceStr = columnMap.balanceUSD >= 0 ? cells[columnMap.balanceUSD] : '0';
                        const balance = parseFloat(balanceStr.replace(/\s+/g, '').replace(/[^\d.-]/g, '')) || 0;
                        
                        // Parse other numeric fields with better error handling
                        const entryPrice = columnMap.entryPrice >= 0 ? parseFloat(cells[columnMap.entryPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const exitPrice = columnMap.closingPrice >= 0 ? parseFloat(cells[columnMap.closingPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const pips = columnMap.pips >= 0 ? parseFloat(cells[columnMap.pips].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const netProfit = columnMap.netUSD >= 0 ? parseFloat(cells[columnMap.netUSD].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const commission = columnMap.commissions >= 0 ? parseFloat(cells[columnMap.commissions].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const swap = columnMap.swap >= 0 ? parseFloat(cells[columnMap.swap].replace(/[^\d.-]/g, '')) || 0 : 0;
                        
                        const trade = {
                            id: `${Date.now()}_${tradeIndex}`,
                            symbol: symbolCell.trim(),
                            direction: columnMap.direction >= 0 ? cells[columnMap.direction] || 'Buy' : 'Buy',
                            openDate: openDateTime.date,
                            openTime: openDateTime.time,
                            date: date,
                            time: time,
                            closeTime: closingTimeStr, // Keep original for parsing
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            volume: volume,
                            pips: pips,
                            grossProfit: columnMap.grossUSD >= 0 ? parseFloat(cells[columnMap.grossUSD].replace(/[^\d.-]/g, '')) || 0 : 0,
                            netProfit: netProfit,
                            netPL: netProfit, // Primary field for calculations
                            profit: netProfit, // For compatibility
                            commission: commission,
                            swap: swap,
                            balance: balance,

                            // Additional fields for comprehensive journal
                            setupType: '',
                            marketCondition: '',
                            emotionalState: '',
                            ruleAdherence: '',
                            notes: '',
                            entryScreenshot: null,
                            exitScreenshot: null,
                            tradingViewEntry: '',
                            tradingViewExit: '',
                            rulesFollowed: []
                        };
                        
                        // Security: Validate trade data before adding
                        try {
                            validateTrade(trade);
                        } catch (validationError) {
                            console.warn(`Trade validation failed:`, validationError.message, trade);
                            continue;
                        }

                        trades.push(trade);
                        tradeIndex++;
                    } catch (error) {
                        console.warn(`Error parsing trade row ${i}:`, error, lines[i]);
                    }
                }
                
                if (trades.length === 0) {
                    if (skippedTrades.length > 0) {
                        throw new Error(`No valid trades found. ${skippedTrades.length} trades skipped due to invalid symbols (numeric-only): ${skippedTrades.slice(0, 3).map(t => t.symbol).join(', ')}${skippedTrades.length > 3 ? '...' : ''}`);
                    }
                    throw new Error('No valid trades found. Please check your CSV format.');
                }
                
                return { trades, startingBalance, skippedCount: skippedTrades.length };
            } catch (error) {
                console.error('CSV parsing failed:', error);
                throw new Error(`CSV parsing failed: ${error.message}`);
            }
        }

        // Parse MT4 CSV format
        function parseMT4CSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim());
                const trades = [];
                const skippedTrades = [];
                let tradeIndex = 1;

                // Find header line (usually first line or after some metadata)
                let headerIndex = -1;
                for (let i = 0; i < Math.min(lines.length, 10); i++) {
                    const line = lines[i].trim().toLowerCase();
                    if ((line.includes('order') || line.includes('ticket')) &&
                        (line.includes('time') || line.includes('open')) &&
                        line.includes('type') && line.includes('symbol')) {
                        headerIndex = i;
                        break;
                    }
                }

                if (headerIndex === -1) {
                    headerIndex = 0; // Assume first line is header
                }

                const headerLine = lines[headerIndex];
                const headers = parseCSVLine(headerLine).map(h => h.trim().toLowerCase());

                // Map columns for MT4 format
                const columnMap = {
                    order: findColumnIndex(headers, ['order', 'ticket', '#']),
                    openTime: findColumnIndex(headers, ['open time', 'time', 'open', 'date']),
                    type: findColumnIndex(headers, ['type', 'cmd', 'order type']),
                    size: findColumnIndex(headers, ['size', 'volume', 'lots', 'quantity']),
                    symbol: findColumnIndex(headers, ['symbol', 'item', 'instrument']),
                    openPrice: findColumnIndex(headers, ['price', 'open price', 'opening price']),
                    sl: findColumnIndex(headers, ['s/l', 'sl', 'stop loss', 'stoploss']),
                    tp: findColumnIndex(headers, ['t/p', 'tp', 'take profit', 'takeprofit']),
                    closeTime: findColumnIndex(headers, ['close time', 'closing time']),
                    closePrice: findColumnIndex(headers, ['close price', 'closing price', 'price']),
                    commission: findColumnIndex(headers, ['commission', 'commissions', 'fee']),
                    swap: findColumnIndex(headers, ['swap', 'rollover']),
                    profit: findColumnIndex(headers, ['profit', 'p/l', 'pl', 'net']),
                    balance: findColumnIndex(headers, ['balance'])
                };

                console.log('MT4 Column mapping:', columnMap);
                console.log('MT4 Headers found:', headers);

                // Parse trade data
                for (let i = headerIndex + 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    try {
                        const cells = parseCSVLine(line);
                        if (cells.length < 3) continue;

                        // Get basic trade info
                        const typeCell = columnMap.type >= 0 ? cells[columnMap.type].toLowerCase() : '';

                        // Skip balance adjustments and pending orders
                        if (typeCell.includes('balance') ||
                            typeCell.includes('credit') ||
                            typeCell.includes('deposit') ||
                            typeCell.includes('limit') ||
                            typeCell.includes('stop') && !typeCell.includes('buy') && !typeCell.includes('sell')) {
                            continue;
                        }

                        const symbolCell = columnMap.symbol >= 0 ? cells[columnMap.symbol] : '';
                        if (!symbolCell || !isValidSymbol(symbolCell.trim())) {
                            skippedTrades.push({ symbol: symbolCell, reason: 'Invalid symbol' });
                            continue;
                        }

                        // Parse times (MT4 format: YYYY.MM.DD HH:MM)
                        const openTimeStr = columnMap.openTime >= 0 ? cells[columnMap.openTime] : '';
                        const closeTimeStr = columnMap.closeTime >= 0 ? cells[columnMap.closeTime] : '';

                        const openDateTime = parseMT4DateTime(openTimeStr);
                        const closeDateTime = parseMT4DateTime(closeTimeStr);

                        // Parse direction
                        let direction = 'Buy';
                        if (typeCell.includes('sell')) {
                            direction = 'Sell';
                        } else if (typeCell.includes('buy')) {
                            direction = 'Buy';
                        }

                        // Parse numeric values
                        const volume = columnMap.size >= 0 ? parseFloat(cells[columnMap.size].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const entryPrice = columnMap.openPrice >= 0 ? parseFloat(cells[columnMap.openPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const exitPrice = columnMap.closePrice >= 0 ? parseFloat(cells[columnMap.closePrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const profit = columnMap.profit >= 0 ? parseFloat(cells[columnMap.profit].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const commission = columnMap.commission >= 0 ? parseFloat(cells[columnMap.commission].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const swap = columnMap.swap >= 0 ? parseFloat(cells[columnMap.swap].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const balance = columnMap.balance >= 0 ? parseFloat(cells[columnMap.balance].replace(/\s+/g, '').replace(/[^\d.-]/g, '')) || 0 : 0;

                        // Calculate pips (approximate)
                        const priceDiff = direction === 'Buy' ? exitPrice - entryPrice : entryPrice - exitPrice;
                        const symbol = symbolCell.trim();
                        const pipMultiplier = symbol.includes('JPY') ? 100 : 10000;
                        const pips = Math.round(priceDiff * pipMultiplier * 10) / 10;

                        const trade = {
                            id: `${Date.now()}_${tradeIndex++}`,
                            symbol: symbol,
                            direction: direction,
                            openDate: openDateTime.date,
                            openTime: openDateTime.time,
                            date: closeDateTime.date,
                            time: closeDateTime.time,
                            closeTime: closeTimeStr,
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            volume: volume,
                            pips: pips,
                            grossProfit: profit - commission - swap,
                            netProfit: profit,
                            netPL: profit,
                            profit: profit,
                            commission: commission,
                            swap: swap,
                            balance: balance,

                            // Journal fields
                            setupType: '',
                            marketCondition: '',
                            emotionalState: '',
                            ruleAdherence: '',
                            notes: '',
                            entryScreenshot: null,
                            exitScreenshot: null,
                            tradingViewEntry: '',
                            tradingViewExit: '',
                            rulesFollowed: []
                        };

                        if (validateTrade(trade)) {
                            trades.push(trade);
                        } else {
                            skippedTrades.push({ symbol: trade.symbol, reason: 'Validation failed' });
                        }
                    } catch (error) {
                        console.error('Error parsing MT4 trade line:', error, line);
                        continue;
                    }
                }

                return {
                    trades: trades,
                    skippedCount: skippedTrades.length,
                    startingBalance: 10000
                };
            } catch (error) {
                console.error('MT4 CSV parsing failed:', error);
                throw new Error(`MT4 CSV parsing failed: ${error.message}`);
            }
        }

        // Parse MT5 CSV format
        function parseMT5CSV(csvText) {
            try {
                const lines = csvText.split('\n').filter(line => line.trim());
                const trades = [];
                const skippedTrades = [];
                let tradeIndex = 1;

                // Find header line
                let headerIndex = -1;
                for (let i = 0; i < Math.min(lines.length, 10); i++) {
                    const line = lines[i].trim().toLowerCase();
                    if ((line.includes('ticket') || line.includes('order')) &&
                        (line.includes('time') || line.includes('open')) &&
                        line.includes('type') && line.includes('symbol')) {
                        headerIndex = i;
                        break;
                    }
                }

                if (headerIndex === -1) {
                    headerIndex = 0; // Assume first line is header
                }

                const headerLine = lines[headerIndex];
                const headers = parseCSVLine(headerLine).map(h => h.trim().toLowerCase());

                // Map columns for MT5 format (similar to MT4 but may have different column names)
                const columnMap = {
                    ticket: findColumnIndex(headers, ['ticket', 'order', '#']),
                    openTime: findColumnIndex(headers, ['time', 'open time', 'entry time', 'date']),
                    type: findColumnIndex(headers, ['type', 'order type', 'action']),
                    volume: findColumnIndex(headers, ['volume', 'size', 'lots', 'quantity']),
                    symbol: findColumnIndex(headers, ['symbol', 'item', 'instrument']),
                    openPrice: findColumnIndex(headers, ['price', 'open price', 'entry price']),
                    sl: findColumnIndex(headers, ['s/l', 'sl', 'stop loss']),
                    tp: findColumnIndex(headers, ['t/p', 'tp', 'take profit']),
                    closeTime: findColumnIndex(headers, ['close time', 'closing time', 'exit time']),
                    closePrice: findColumnIndex(headers, ['close price', 'exit price', 'closing price']),
                    commission: findColumnIndex(headers, ['commission', 'fee']),
                    swap: findColumnIndex(headers, ['swap', 'rollover']),
                    profit: findColumnIndex(headers, ['profit', 'p/l', 'pl', 'net']),
                    balance: findColumnIndex(headers, ['balance'])
                };

                console.log('MT5 Column mapping:', columnMap);
                console.log('MT5 Headers found:', headers);

                // Parse trade data
                for (let i = headerIndex + 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    try {
                        const cells = parseCSVLine(line);
                        if (cells.length < 3) continue;

                        // Get basic trade info
                        const typeCell = columnMap.type >= 0 ? cells[columnMap.type].toLowerCase() : '';

                        // Skip balance adjustments and pending orders
                        if (typeCell.includes('balance') ||
                            typeCell.includes('credit') ||
                            typeCell.includes('deposit') ||
                            typeCell.includes('limit') ||
                            typeCell.includes('stop') && !typeCell.includes('buy') && !typeCell.includes('sell')) {
                            continue;
                        }

                        const symbolCell = columnMap.symbol >= 0 ? cells[columnMap.symbol] : '';
                        if (!symbolCell || !isValidSymbol(symbolCell.trim())) {
                            skippedTrades.push({ symbol: symbolCell, reason: 'Invalid symbol' });
                            continue;
                        }

                        // Parse times (MT5 format similar to MT4: YYYY.MM.DD HH:MM)
                        const openTimeStr = columnMap.openTime >= 0 ? cells[columnMap.openTime] : '';
                        const closeTimeStr = columnMap.closeTime >= 0 ? cells[columnMap.closeTime] : '';

                        const openDateTime = parseMT4DateTime(openTimeStr); // MT5 uses similar format
                        const closeDateTime = parseMT4DateTime(closeTimeStr);

                        // Parse direction
                        let direction = 'Buy';
                        if (typeCell.includes('sell')) {
                            direction = 'Sell';
                        } else if (typeCell.includes('buy')) {
                            direction = 'Buy';
                        }

                        // Parse numeric values
                        const volume = columnMap.volume >= 0 ? parseFloat(cells[columnMap.volume].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const entryPrice = columnMap.openPrice >= 0 ? parseFloat(cells[columnMap.openPrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const exitPrice = columnMap.closePrice >= 0 ? parseFloat(cells[columnMap.closePrice].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const profit = columnMap.profit >= 0 ? parseFloat(cells[columnMap.profit].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const commission = columnMap.commission >= 0 ? parseFloat(cells[columnMap.commission].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const swap = columnMap.swap >= 0 ? parseFloat(cells[columnMap.swap].replace(/[^\d.-]/g, '')) || 0 : 0;
                        const balance = columnMap.balance >= 0 ? parseFloat(cells[columnMap.balance].replace(/\s+/g, '').replace(/[^\d.-]/g, '')) || 0 : 0;

                        // Calculate pips (approximate)
                        const priceDiff = direction === 'Buy' ? exitPrice - entryPrice : entryPrice - exitPrice;
                        const symbol = symbolCell.trim();
                        const pipMultiplier = symbol.includes('JPY') ? 100 : 10000;
                        const pips = Math.round(priceDiff * pipMultiplier * 10) / 10;

                        const trade = {
                            id: `${Date.now()}_${tradeIndex++}`,
                            symbol: symbol,
                            direction: direction,
                            openDate: openDateTime.date,
                            openTime: openDateTime.time,
                            date: closeDateTime.date,
                            time: closeDateTime.time,
                            closeTime: closeTimeStr,
                            entryPrice: entryPrice,
                            exitPrice: exitPrice,
                            volume: volume,
                            pips: pips,
                            grossProfit: profit - commission - swap,
                            netProfit: profit,
                            netPL: profit,
                            profit: profit,
                            commission: commission,
                            swap: swap,
                            balance: balance,

                            // Journal fields
                            setupType: '',
                            marketCondition: '',
                            emotionalState: '',
                            ruleAdherence: '',
                            notes: '',
                            entryScreenshot: null,
                            exitScreenshot: null,
                            tradingViewEntry: '',
                            tradingViewExit: '',
                            rulesFollowed: []
                        };

                        if (validateTrade(trade)) {
                            trades.push(trade);
                        } else {
                            skippedTrades.push({ symbol: trade.symbol, reason: 'Validation failed' });
                        }
                    } catch (error) {
                        console.error('Error parsing MT5 trade line:', error, line);
                        continue;
                    }
                }

                return {
                    trades: trades,
                    skippedCount: skippedTrades.length,
                    startingBalance: 10000
                };
            } catch (error) {
                console.error('MT5 CSV parsing failed:', error);
                throw new Error(`MT5 CSV parsing failed: ${error.message}`);
            }
        }

        // Parse MT4/MT5 DateTime format (YYYY.MM.DD HH:MM or YYYY.MM.DD HH:MM:SS)
        function parseMT4DateTime(dateTimeStr) {
            if (!dateTimeStr || !dateTimeStr.trim()) {
                const now = new Date();
                const yyyy = now.getFullYear();
                const mm = (now.getMonth() + 1).toString().padStart(2, '0');
                const dd = now.getDate().toString().padStart(2, '0');
                return {
                    date: `${yyyy}-${mm}-${dd}`,
                    time: '12:00'
                };
            }

            try {
                // Match pattern: "YYYY.MM.DD HH:MM:SS" or "YYYY.MM.DD HH:MM"
                const match = dateTimeStr.match(/(\d{4})\.(\d{2})\.(\d{2})\s+(\d{1,2}):(\d{2})/);
                if (match) {
                    const [, year, month, day, hour, minute] = match;
                    return {
                        date: `${year}-${month}-${day}`,
                        time: `${hour.padStart(2, '0')}:${minute}`
                    };
                }
            } catch (error) {
                console.error('Error parsing MT4/MT5 date:', error, dateTimeStr);
            }

            // Fallback
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = (now.getMonth() + 1).toString().padStart(2, '0');
            const dd = now.getDate().toString().padStart(2, '0');
            return {
                date: `${yyyy}-${mm}-${dd}`,
                time: '12:00'
            };
        }

        function parsecTraderDateTime(dateTimeStr) {
            // Parse cTrader format: "06 Oct 2025 04:29:33.732"
            if (!dateTimeStr || !dateTimeStr.trim()) {
                const now = new Date();
                // FIX: Format date parts directly
                const yyyy = now.getFullYear();
                const mm = (now.getMonth() + 1).toString().padStart(2, '0');
                const dd = now.getDate().toString().padStart(2, '0');
                return {
                    date: `${yyyy}-${mm}-${dd}`,
                    time: '12:00'
                };
            }
            
            try {
                // Match pattern: "DD Mon YYYY HH:MM:SS.mmm"
                const match = dateTimeStr.match(/(\d{1,2})\s+(\w{3})\s+(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/);                
                if (match) {
                    const [, day, monthName, year, hour, minute] = match;
                    
                    // Convert month name to number
                    const months = {
                        'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5,
                        'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
                    };
                    
                    const monthNum = months[monthName.toLowerCase()];
                    if (monthNum !== undefined) {
                        // FIX: Format date parts directly to avoid timezone shift from toISOString()
                        const yyyy = parseInt(year);
                        const mm = (monthNum + 1).toString().padStart(2, '0');
                        const dd = parseInt(day).toString().padStart(2, '0');
                        
                        return {
                            date: `${yyyy}-${mm}-${dd}`, // e.g., "2025-10-06"
                            time: `${hour.padStart(2, '0')}:${minute}`
                        };
                    }
                }
                
                // Fallback: try to parse as standard date
                const date = new Date(dateTimeStr);
                if (!isNaN(date.getTime())) {
                    // FIX: Get local date parts, not UTC from toISOString()
                    const yyyy = date.getFullYear();
                    const mm = (date.getMonth() + 1).toString().padStart(2, '0');
                    const dd = date.getDate().toString().padStart(2, '0');

                    return {
                        date: `${yyyy}-${mm}-${dd}`,
                        time: date.toTimeString().substring(0, 5)
                    };
                }
            } catch (error) {
                console.warn('Date parsing error:', error, dateTimeStr);
            }
            
            // Final fallback
            const now = new Date();
            // FIX: Format date parts directly
            const yyyy = now.getFullYear();
            const mm = (now.getMonth() + 1).toString().padStart(2, '0');
            const dd = now.getDate().toString().padStart(2, '0');
            return {
                date: `${yyyy}-${mm}-${dd}`,
                time: '12:00'
            };
        }

        function findColumnIndex(headers, possibleNames) {
            for (const name of possibleNames) {
                const index = headers.findIndex(h => h.includes(name));
                if (index !== -1) return index;
            }
            return -1;
        }

        function parseCSVLine(line) {
            const cells = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    cells.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            cells.push(current.trim());
            return cells.map(cell => cell.replace(/^"|"$/g, ''));
        }

        // Trade Management Functions
        function toggleTradeDetails(tradeIndex) {
            const detailsRow = document.querySelector(`#details_${tradeIndex}`).parentElement.parentElement;
            const isVisible = detailsRow.style.display !== 'none';

            if (isVisible) {
                detailsRow.style.display = 'none';
                appState.activeTradeIndex = null;
            } else {
                detailsRow.style.display = 'table-row';
                renderTradeDetails(tradeIndex);
                appState.activeTradeIndex = tradeIndex;
            }
        }
        
        function renderTradeDetails(tradeIndex) {
            const trade = appState.trades[tradeIndex];
            const container = document.getElementById(`details_${tradeIndex}`);

            container.innerHTML = `
                <div class="form-grid">
                    <div class="form-group">
                        <label>Setup Type</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'setupType', this.value)">
                            <option value="">Select setup...</option>
                            ${setupTypes.map(type => `<option value="${type}" ${trade.setupType === type ? 'selected' : ''}>${type}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Market Condition</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'marketCondition', this.value)">
                            <option value="">Select condition...</option>
                            ${marketConditions.map(condition => `<option value="${condition}" ${trade.marketCondition === condition ? 'selected' : ''}>${condition}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Emotional State</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'emotionalState', this.value)">
                            <option value="">Select state...</option>
                            ${emotionalStates.map(state => `<option value="${state}" ${trade.emotionalState === state ? 'selected' : ''}>${state}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Rule Adherence</label>
                        <select class="form-control" onchange="updateTradeField(${tradeIndex}, 'ruleAdherence', this.value)">
                            <option value="">Select...</option>
                            <option value="Perfect" ${trade.ruleAdherence === 'Perfect' ? 'selected' : ''}>Perfect</option>
                            <option value="Custom" ${trade.ruleAdherence === 'Custom' ? 'selected' : ''}>Custom</option>
                            <option value="Partial" ${trade.ruleAdherence === 'Partial' ? 'selected' : ''}>Partial</option>
                            <option value="None" ${trade.ruleAdherence === 'None' ? 'selected' : ''}>None</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Trading Notes</label>
                    <textarea class="form-control" rows="3" placeholder="Add your trading notes..." onchange="updateTradeField(${tradeIndex}, 'notes', this.value)">${trade.notes || ''}</textarea>
                </div>

                <!-- Enhanced TradingView Links Section -->
                <div class="form-grid">
                    <div class="form-group">
                        <label>TradingView Entry Link</label>
                        <div style="display: flex; gap: var(--space-8); align-items: center;">
                            <input type="url" class="form-control" style="flex: 1;" placeholder="https://tradingview.com/..." value="${trade.tradingViewEntry || ''}" onchange="updateTradeField(${tradeIndex}, 'tradingViewEntry', this.value)" id="tvEntry_${tradeIndex}">
                            <button class="btn btn-tradingview" onclick="openTradingViewLink(${tradeIndex}, 'entry')" ${!trade.tradingViewEntry ? 'disabled' : ''} title="Open TradingView Entry Link">
                                🔗 Open
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>TradingView Exit Link</label>
                        <div style="display: flex; gap: var(--space-8); align-items: center;">
                            <input type="url" class="form-control" style="flex: 1;" placeholder="https://tradingview.com/..." value="${trade.tradingViewExit || ''}" onchange="updateTradeField(${tradeIndex}, 'tradingViewExit', this.value)" id="tvExit_${tradeIndex}">
                            <button class="btn btn-tradingview" onclick="openTradingViewLink(${tradeIndex}, 'exit')" ${!trade.tradingViewExit ? 'disabled' : ''} title="Open TradingView Exit Link">
                                🔗 Open
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Enhanced Screenshots Section -->
                <div class="form-grid">
                    <div class="form-group" onclick="appState.activePasteTarget = 'entry'">
                        <label>Entry Screenshot</label>
                        <div style="display: flex; gap: var(--space-8); margin-bottom: var(--space-8);">
                            <button class="btn btn-screenshot" onclick="appState.activePasteTarget = 'entry'; document.getElementById('entryScreenshot_${tradeIndex}').click()" style="flex: 1;">
                                📷 Upload Entry Screenshot
                            </button>
                            ${trade.entryScreenshot ? `<button class="btn btn-secondary" class="btn btn-clear" onclick="clearScreenshot(${tradeIndex}, 'entry')" title="Remove Screenshot">🗑️</button>` : ''}
                        </div>
                        <input type="file" id="entryScreenshot_${tradeIndex}" class="form-control" accept="image/*" onchange="handleScreenshotUpload(${tradeIndex}, 'entry', this)" style="display: none;">
                        <small style="color: var(--color-text-secondary);">Or paste with Ctrl+V (active target: entry)</small>
                        ${trade.entryScreenshot && typeof trade.entryScreenshot === 'string' ? `
                            <div class="screenshot-container" style="margin-top: var(--space-8);">
                                <img src="${getScreenshotSrc(trade.entryScreenshot)}" class="screenshot" onclick="openLightbox('${getScreenshotSrc(trade.entryScreenshot)}')" onerror="console.error('Failed to load entry screenshot'); this.style.display='none';" style="max-width: 200px; max-height: 150px; cursor: pointer; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">Click to view full size</div>
                            </div>
                        ` : ''}
                    </div>

                    <div class="form-group" onclick="appState.activePasteTarget = 'exit'">
                        <label>Exit Screenshot</label>
                        <div style="display: flex; gap: var(--space-8); margin-bottom: var(--space-8);">
                            <button class="btn btn-screenshot" onclick="appState.activePasteTarget = 'exit'; document.getElementById('exitScreenshot_${tradeIndex}').click()" style="flex: 1;">
                                📷 Upload Exit Screenshot
                            </button>
                            ${trade.exitScreenshot ? `<button class="btn btn-secondary" class="btn btn-clear" onclick="clearScreenshot(${tradeIndex}, 'exit')" title="Remove Screenshot">🗑️</button>` : ''}
                        </div>
                        <input type="file" id="exitScreenshot_${tradeIndex}" class="form-control" accept="image/*" onchange="handleScreenshotUpload(${tradeIndex}, 'exit', this)" style="display: none;">
                        <small style="color: var(--color-text-secondary);">Or paste with Ctrl+V (active target: exit)</small>
                        ${trade.exitScreenshot && typeof trade.exitScreenshot === 'string' ? `
                            <div class="screenshot-container" style="margin-top: var(--space-8);">
                                <img src="${getScreenshotSrc(trade.exitScreenshot)}" class="screenshot" onclick="openLightbox('${getScreenshotSrc(trade.exitScreenshot)}')" onerror="console.error('Failed to load exit screenshot'); this.style.display='none';" style="max-width: 200px; max-height: 150px; cursor: pointer; border-radius: var(--radius-base); border: 1px solid var(--color-border);">
                                <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary); margin-top: var(--space-4);">Click to view full size</div>
                            </div>
                        ` : ''}
                    </div>
                </div>

                <div class="form-group">
                    <label>Custom Rules Followed</label>
                    <div id="rulesChecklist_${tradeIndex}">
                        ${generateRulesChecklist(tradeIndex, trade.rulesFollowed || [])}
                    </div>
                </div>

                <div style="margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="printTrade(${tradeIndex})">🖨️ Print This Trade</button>
                </div>
            `;
        }

        function calculateStatistics() {
            if (appState.trades.length === 0) {
                appState.statistics = {};
                return;
            }

            const trades = appState.trades;
            // CORRECTED: Use netPL consistently for calculations
            const wins = trades.filter(t => (t.netPL || t.profit) > 0);
            const losses = trades.filter(t => (t.netPL || t.profit) < 0);
            const totalProfit = wins.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalLoss = Math.abs(losses.reduce((sum, t) => sum + (t.netPL || t.profit), 0));
            const netPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalFees = trades.reduce((sum, t) => sum + t.commission + t.swap, 0);

            // Rule adherence statistics
            const tradesWithRules = trades.filter(t => t.rulesFollowed && t.rulesFollowed.length > 0);
            const rulesWins = tradesWithRules.filter(t => (t.netPL || t.profit) > 0);
            const rulesWinRate = tradesWithRules.length > 0 ? (rulesWins.length / tradesWithRules.length * 100) : 0;

            const currentBalance = appState.startingBalance + netPL;
            const accountGrowth = ((currentBalance - appState.startingBalance) / appState.startingBalance * 100);
            const expectancy = trades.length > 0 ? netPL / trades.length : 0;

            // PHASE 1 STATS: Calculate Max Drawdown and Recovery Factor
            // Sort trades chronologically for equity curve calculation
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateA - dateB;
            });

            // Build equity curve and calculate max drawdown
            let runningBalance = appState.startingBalance;
            let peak = appState.startingBalance;
            let maxDrawdown = 0;
            let maxDrawdownPercent = 0;

            sortedTrades.forEach(trade => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                runningBalance += tradePL;

                // Update peak if we've reached a new high
                if (runningBalance > peak) {
                    peak = runningBalance;
                }

                // Calculate current drawdown
                const drawdown = peak - runningBalance;
                const drawdownPercent = peak > 0 ? (drawdown / peak * 100) : 0;

                // Update max drawdown
                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                    maxDrawdownPercent = drawdownPercent;
                }
            });

            // Recovery Factor = Net P/L / Max Drawdown
            const recoveryFactor = maxDrawdown > 0 ? (netPL / maxDrawdown) : 0;

            // PHASE 1 STATS: Calculate Consecutive Win/Loss Streaks
            let currentStreak = 0;
            let longestWinStreak = 0;
            let longestLossStreak = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;

            sortedTrades.forEach((trade, index) => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                const isWin = tradePL > 0;

                if (isWin) {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > longestWinStreak) {
                        longestWinStreak = currentWinStreak;
                    }
                } else if (tradePL < 0) {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > longestLossStreak) {
                        longestLossStreak = currentLossStreak;
                    }
                } else {
                    // Break-even trade resets both streaks
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }

                // Current streak is determined by the last trade
                if (index === sortedTrades.length - 1) {
                    currentStreak = isWin ? currentWinStreak : (tradePL < 0 ? -currentLossStreak : 0);
                }
            });

            // PHASE 1 STATS: Risk-Reward Ratio
            const avgWin = wins.length > 0 ? (totalProfit / wins.length) : 0;
            const avgLoss = losses.length > 0 ? (totalLoss / losses.length) : 0;
            const riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;

            // PHASE 1 STATS: Average Trade Duration
            let totalDuration = 0;
            let tradesWithDuration = 0;

            trades.forEach(trade => {
                // Check if we have both open and close times
                if (trade.openDate && trade.date) {
                    const openDateTime = new Date(`${trade.openDate}T${trade.openTime || '00:00:00'}`);
                    const closeDateTime = new Date(`${trade.date}T${trade.time || '00:00:00'}`);

                    if (!isNaN(openDateTime.getTime()) && !isNaN(closeDateTime.getTime())) {
                        const durationMs = closeDateTime - openDateTime;
                        if (durationMs >= 0) {
                            totalDuration += durationMs;
                            tradesWithDuration++;
                        }
                    }
                }
            });

            const avgTradeDuration = tradesWithDuration > 0 ? (totalDuration / tradesWithDuration) : 0;

            appState.statistics = {
                totalTrades: trades.length,
                winningTrades: wins.length,
                losingTrades: losses.length,
                winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                rulesWinRate: rulesWinRate,
                netPL: netPL,
                totalFees: Math.abs(totalFees),
                totalProfit: totalProfit,
                totalLoss: totalLoss,
                profitFactor: totalLoss > 0 ? (totalProfit / totalLoss) : 0,
                avgWin: avgWin,
                avgLoss: avgLoss,
                largestWin: wins.length > 0 ? Math.max(...wins.map(t => t.profit)) : 0,
                largestLoss: losses.length > 0 ? Math.min(...losses.map(t => t.profit)) : 0,
                expectancy: expectancy,
                accountGrowth: accountGrowth,
                currentBalance: currentBalance,
                startingBalance: appState.startingBalance,
                // Phase 1 New Stats
                maxDrawdown: maxDrawdown,
                maxDrawdownPercent: maxDrawdownPercent,
                recoveryFactor: recoveryFactor,
                currentStreak: currentStreak,
                longestWinStreak: longestWinStreak,
                longestLossStreak: longestLossStreak,
                riskRewardRatio: riskRewardRatio,
                avgTradeDuration: avgTradeDuration
            };

            appState.currentBalance = currentBalance;
        }

        // Calculate statistics for a specific month
        function calculateStatisticsForMonth(year, month) {
            // Filter trades for the selected month
            const selectedMonthKey = `${year}-${String(month + 1).padStart(2, '0')}`;
            const monthTrades = appState.trades.filter(trade => {
                const tradeDate = new Date(trade.date);
                const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                return tradeMonthKey === selectedMonthKey;
            });

            if (monthTrades.length === 0) {
                return {
                    totalTrades: 0,
                    winningTrades: 0,
                    losingTrades: 0,
                    winRate: 0,
                    rulesWinRate: 0,
                    netPL: 0,
                    totalFees: 0,
                    totalProfit: 0,
                    totalLoss: 0,
                    profitFactor: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    largestWin: 0,
                    largestLoss: 0,
                    expectancy: 0,
                    accountGrowth: 0,
                    currentBalance: appState.startingBalance,
                    startingBalance: appState.startingBalance,
                    maxDrawdown: 0,
                    maxDrawdownPercent: 0,
                    recoveryFactor: 0,
                    currentStreak: 0,
                    longestWinStreak: 0,
                    longestLossStreak: 0,
                    riskRewardRatio: 0,
                    avgTradeDuration: 0
                };
            }

            // Use same calculation logic as calculateStatistics but with filtered trades
            const trades = monthTrades;
            const wins = trades.filter(t => (t.netPL || t.profit) > 0);
            const losses = trades.filter(t => (t.netPL || t.profit) < 0);
            const totalProfit = wins.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalLoss = Math.abs(losses.reduce((sum, t) => sum + (t.netPL || t.profit), 0));
            const netPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
            const totalFees = trades.reduce((sum, t) => sum + t.commission + t.swap, 0);

            // Rule adherence statistics
            const tradesWithRules = trades.filter(t => t.rulesFollowed && t.rulesFollowed.length > 0);
            const rulesWins = tradesWithRules.filter(t => (t.netPL || t.profit) > 0);
            const rulesWinRate = tradesWithRules.length > 0 ? (rulesWins.length / tradesWithRules.length * 100) : 0;

            const currentBalance = appState.startingBalance + netPL;
            const accountGrowth = ((currentBalance - appState.startingBalance) / appState.startingBalance * 100);
            const expectancy = trades.length > 0 ? netPL / trades.length : 0;

            // Calculate Max Drawdown and Recovery Factor
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateA - dateB;
            });

            let runningBalance = appState.startingBalance;
            let peak = appState.startingBalance;
            let maxDrawdown = 0;
            let maxDrawdownPercent = 0;

            sortedTrades.forEach(trade => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                runningBalance += tradePL;

                if (runningBalance > peak) {
                    peak = runningBalance;
                }

                const drawdown = peak - runningBalance;
                const drawdownPercent = peak > 0 ? (drawdown / peak * 100) : 0;

                if (drawdown > maxDrawdown) {
                    maxDrawdown = drawdown;
                    maxDrawdownPercent = drawdownPercent;
                }
            });

            const recoveryFactor = maxDrawdown > 0 ? (netPL / maxDrawdown) : 0;

            // Calculate Consecutive Win/Loss Streaks
            let currentStreak = 0;
            let longestWinStreak = 0;
            let longestLossStreak = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;

            sortedTrades.forEach((trade, index) => {
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                const isWin = tradePL > 0;

                if (isWin) {
                    currentWinStreak++;
                    currentLossStreak = 0;
                    if (currentWinStreak > longestWinStreak) {
                        longestWinStreak = currentWinStreak;
                    }
                } else if (tradePL < 0) {
                    currentLossStreak++;
                    currentWinStreak = 0;
                    if (currentLossStreak > longestLossStreak) {
                        longestLossStreak = currentLossStreak;
                    }
                } else {
                    currentWinStreak = 0;
                    currentLossStreak = 0;
                }

                if (index === sortedTrades.length - 1) {
                    currentStreak = isWin ? currentWinStreak : (tradePL < 0 ? -currentLossStreak : 0);
                }
            });

            // Risk-Reward Ratio
            const avgWin = wins.length > 0 ? (totalProfit / wins.length) : 0;
            const avgLoss = losses.length > 0 ? (totalLoss / losses.length) : 0;
            const riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;

            // Average Trade Duration
            let totalDuration = 0;
            let tradesWithDuration = 0;

            trades.forEach(trade => {
                if (trade.openDate && trade.date) {
                    const openDateTime = new Date(`${trade.openDate}T${trade.openTime || '00:00:00'}`);
                    const closeDateTime = new Date(`${trade.date}T${trade.time || '00:00:00'}`);

                    if (!isNaN(openDateTime.getTime()) && !isNaN(closeDateTime.getTime())) {
                        const durationMs = closeDateTime - openDateTime;
                        if (durationMs >= 0) {
                            totalDuration += durationMs;
                            tradesWithDuration++;
                        }
                    }
                }
            });

            const avgTradeDuration = tradesWithDuration > 0 ? (totalDuration / tradesWithDuration) : 0;

            return {
                totalTrades: trades.length,
                winningTrades: wins.length,
                losingTrades: losses.length,
                winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                rulesWinRate: rulesWinRate,
                netPL: netPL,
                totalFees: Math.abs(totalFees),
                totalProfit: totalProfit,
                totalLoss: totalLoss,
                profitFactor: totalLoss > 0 ? (totalProfit / totalLoss) : 0,
                avgWin: avgWin,
                avgLoss: avgLoss,
                largestWin: wins.length > 0 ? Math.max(...wins.map(t => t.profit)) : 0,
                largestLoss: losses.length > 0 ? Math.min(...losses.map(t => t.profit)) : 0,
                expectancy: expectancy,
                accountGrowth: accountGrowth,
                currentBalance: currentBalance,
                startingBalance: appState.startingBalance,
                maxDrawdown: maxDrawdown,
                maxDrawdownPercent: maxDrawdownPercent,
                recoveryFactor: recoveryFactor,
                currentStreak: currentStreak,
                longestWinStreak: longestWinStreak,
                longestLossStreak: longestLossStreak,
                riskRewardRatio: riskRewardRatio,
                avgTradeDuration: avgTradeDuration
            };
        }

        function updateStatisticsDisplay() {
            if (appState.trades.length === 0) return;

            const statsGrid = document.getElementById('statsGrid');
            const statsConfig = appState.visibleStats;

            // Get stats based on selected view: TOTAL (-1) or specific month
            const stats = appState.analyticsCurrentMonth === -1
                ? appState.statistics
                : calculateStatisticsForMonth(appState.analyticsCurrentYear, appState.analyticsCurrentMonth);

            // Helper function to format a stat value
            const formatStatValue = (value, format) => {
                switch (format) {
                    case 'currency': return formatCurrency(value);
                    case 'percentage': return formatPercentage(value);
                    case 'decimal': return value.toFixed(2);
                    case 'duration': return formatDuration(value);
                    case 'streak':
                        return value === 0 ? '0' : (value > 0 ? `+${value}` : value.toString());
                    default: return value.toString();
                }
            };

            // Helper function to get class for a stat
            const getStatClass = (key, value, format) => {
                if (format === 'streak') {
                    return value > 0 ? 'positive' : (value < 0 ? 'negative' : '');
                }
                switch (key) {
                    case 'winningTrades':
                    case 'avgWin':
                    case 'largestWin':
                    case 'longestWinStreak':
                        return 'positive';
                    case 'losingTrades':
                    case 'avgLoss':
                    case 'largestLoss':
                    case 'totalFees':
                    case 'maxDrawdown':
                    case 'maxDrawdownPercent':
                    case 'longestLossStreak':
                        return 'negative';
                    case 'netPL':
                    case 'expectancy':
                    case 'accountGrowth':
                        return value >= 0 ? 'positive' : 'negative';
                    case 'recoveryFactor':
                    case 'riskRewardRatio':
                        return value >= 1 ? 'positive' : 'negative';
                    default:
                        return '';
                }
            };

            const statsDefinitions = [
                { key: 'totalTrades', label: 'Total Trades', format: 'number' },
                { key: 'winningTrades', label: 'Winning Trades', format: 'number' },
                { key: 'losingTrades', label: 'Losing Trades', format: 'number' },
                { key: 'winRate', label: 'Win Rate', format: 'percentage' },
                { key: 'rulesWinRate', label: 'Rules Win Rate', format: 'percentage' },
                { key: 'netPL', label: 'Net P&L', format: 'currency' },
                { key: 'totalFees', label: 'Total Fees', format: 'currency' },
                { key: 'profitFactor', label: 'Profit Factor', format: 'decimal' },
                { key: 'avgWin', label: 'Average Win', format: 'currency' },
                { key: 'avgLoss', label: 'Average Loss', format: 'currency' },
                { key: 'largestWin', label: 'Largest Win', format: 'currency' },
                { key: 'largestLoss', label: 'Largest Loss', format: 'currency' },
                { key: 'expectancy', label: 'Expectancy', format: 'currency' },
                { key: 'accountGrowth', label: 'Account Growth', format: 'percentage' },
                { key: 'currentBalance', label: 'Current Balance', format: 'currency' },
                { key: 'startingBalance', label: 'Starting Balance', format: 'currency' },
                { key: 'maxDrawdown', label: 'Max Drawdown', format: 'currency' },
                { key: 'maxDrawdownPercent', label: 'Max Drawdown %', format: 'percentage' },
                { key: 'recoveryFactor', label: 'Recovery Factor', format: 'decimal' },
                { key: 'currentStreak', label: 'Current Streak', format: 'streak' },
                { key: 'longestWinStreak', label: 'Longest Win Streak', format: 'number' },
                { key: 'longestLossStreak', label: 'Longest Loss Streak', format: 'number' },
                { key: 'riskRewardRatio', label: 'Risk/Reward Ratio', format: 'decimal' },
                { key: 'avgTradeDuration', label: 'Avg Trade Duration', format: 'duration' }
            ];

            let html = '';

            // Generate cards for each visible stat showing only one value
            statsDefinitions.filter(stat => statsConfig[stat.key]).forEach(stat => {
                const value = stats[stat.key];

                // Adjust values that need absolute formatting
                const displayValue = (stat.key === 'avgLoss' || stat.key === 'largestLoss') ? Math.abs(value) : value;

                const formattedValue = formatStatValue(displayValue, stat.format);
                const valueClass = getStatClass(stat.key, displayValue, stat.format);

                html += `
                    <div class="stat-card">
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value ${valueClass}">${formattedValue}</div>
                    </div>
                `;
            });

            statsGrid.innerHTML = html;
        }

        function updateChartsDisplay() {
            if (appState.trades.length === 0) return;
            
            // Clear existing charts
            Object.values(appState.chartInstances).forEach(chart => {
                if (chart) chart.destroy();
            });
            
            // Show/hide chart containers based on settings
            document.getElementById('equityContainer').style.display = appState.visibleCharts.equityCurve ? 'block' : 'none';
            document.getElementById('dailyPLContainer').style.display = appState.visibleCharts.dailyPL ? 'block' : 'none';
            document.getElementById('winLossContainer').style.display = appState.visibleCharts.winLoss ? 'block' : 'none';
            
            if (appState.visibleCharts.equityCurve) drawEquityCurve();
            if (appState.visibleCharts.dailyPL) drawDailyPLChart();
            if (appState.visibleCharts.winLoss) drawWinLossChart();
        }

        function drawEquityCurve() {
            const ctx = document.getElementById('equityChart').getContext('2d');
            const trades = [...appState.trades]; // Create copy to avoid mutation
            
            // CORRECTED: Sort trades by date/time for proper equity curve
            trades.sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateA - dateB;
            });
            
            // CORRECTED: Calculate cumulative balance properly using netPL
            let cumulative = 0;
            const cumulativeData = [];
            
            // Add starting point at trade 0
            cumulativeData.push({ x: 0, y: appState.startingBalance });
            
            trades.forEach((trade, index) => {
                // Use netPL consistently for P/L calculations
                const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                cumulative += tradePL;
                const balance = appState.startingBalance + cumulative;
                cumulativeData.push({
                    x: index + 1, // Trade number 1, 2, 3, ...
                    y: parseFloat(balance.toFixed(2)) // Cumulative balance
                });
            });
            
            appState.chartInstances.equity = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Account Balance',
                        data: cumulativeData,
                        borderColor: '#60a5fa',
                        backgroundColor: 'rgba(96, 165, 250, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 1,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#f8fafc'
                            }
                        },
                        tooltip: {
                            backgroundColor: '#1e293b',
                            borderColor: '#475569',
                            titleColor: '#e2e8f0',
                            bodyColor: '#60a5fa',
                            callbacks: {
                                title: function(context) {
                                    return context[0].parsed.x === 0 ? 'Starting Balance' : `Trade ${context[0].parsed.x}`;
                                },
                                label: function(context) {
                                    return 'Account Balance: $' + context.parsed.y.toFixed(2);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Trade Number',
                                color: '#94a3b8'
                            },
                            ticks: {
                                color: '#94a3b8',
                                stepSize: 1,
                                callback: function(value) {
                                    return Number.isInteger(value) ? value : '';
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.2)',
                                drawOnChartArea: true
                            },
                            min: 0
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Account Balance ($)',
                                color: '#94a3b8'
                            },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.2)',
                                drawOnChartArea: true
                            }
                        }
                    }
                }
            });
        }

        function drawDailyPLChart() {
            const ctx = document.getElementById('dailyPLChart').getContext('2d');
            const trades = appState.trades;
            
            // Group trades by date using correct P/L field
            const dailyPL = {};
            trades.forEach(trade => {
                if (!dailyPL[trade.date]) {
                    dailyPL[trade.date] = 0;
                }
                dailyPL[trade.date] += (trade.netPL || trade.profit);
            });
            
            const dates = Object.keys(dailyPL).sort();
            const values = dates.map(date => dailyPL[date]);
            
            appState.chartInstances.dailyPL = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Daily P&L',
                        data: values,
                        backgroundColor: values.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderColor: values.map(v => v >= 0 ? '#10b981' : '#ef4444'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#f8fafc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Profit/Loss ($)',
                                color: '#94a3b8'
                            },
                            ticks: {
                                color: '#94a3b8',
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            grid: {
                                color: 'rgba(148, 163, 184, 0.1)'
                            }
                        }
                    }
                }
            });
        }

        function drawWinLossChart() {
            const ctx = document.getElementById('winLossChart').getContext('2d');
            const stats = appState.statistics;
            
            appState.chartInstances.winLoss = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: ['Wins', 'Losses'],
                    datasets: [{
                        data: [stats.winningTrades, stats.losingTrades],
                        backgroundColor: ['#10b981', '#ef4444'],
                        borderColor: ['#059669', '#dc2626'],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#f8fafc',
                                padding: 20
                            }
                        }
                    }
                }
            });
        }

        function updateTradesTable() {
            updateTableHeader();
            updateTableBody();
            // Update collapse state display after table updates
            if (appState.trades && appState.trades.length > 0) {
                updateTradeHistoryCollapseState();
            }
        }
        
        function updateTableHeader() {
            const header = document.getElementById('tableHeader');
            const columns = appState.visibleColumns;

            let html = '';
            if (columns.openDate) html += '<th>Open Date</th>';
            if (columns.openTime) html += '<th>Open Time</th>';
            if (columns.date) html += '<th>Close Date</th>';
            if (columns.time) html += '<th>Close Time</th>';
            if (columns.symbol) html += '<th>Symbol</th>';
            if (columns.direction) html += '<th>Direction</th>';
            if (columns.entry) html += '<th>Entry</th>';
            if (columns.exit) html += '<th>Exit</th>';
            if (columns.pips) html += '<th>Pips</th>';
            if (columns.pl) html += '<th>P&L</th>';
            if (columns.setup) html += '<th>Setup</th>';
            html += '<th>Actions</th>';

            header.innerHTML = html;
        }
        
        function updateTableBody() {
            const tbody = document.getElementById('tradesTableBody');
            tbody.innerHTML = '';

            appState.trades.forEach((trade, index) => {
                const row = tbody.insertRow();
                row.className = 'trade-row';

                const columns = appState.visibleColumns;
                let html = '';

                if (columns.openDate) html += `<td>${trade.openDate || '-'}</td>`;
                if (columns.openTime) html += `<td>${trade.openTime || '-'}</td>`;
                if (columns.date) html += `<td>${trade.date}</td>`;
                if (columns.time) html += `<td>${trade.time}</td>`;
                if (columns.symbol) html += `<td>${trade.symbol}</td>`;
                if (columns.direction) html += `<td>${trade.direction}</td>`;
                if (columns.entry) html += `<td>${trade.entryPrice.toFixed(5)}</td>`;
                if (columns.exit) html += `<td>${trade.exitPrice.toFixed(5)}</td>`;
                if (columns.pips) html += `<td class="${trade.pips >= 0 ? 'positive' : 'negative'}">${trade.pips.toFixed(1)}</td>`;
                if (columns.pl) html += `<td class="${(trade.netPL || trade.profit) >= 0 ? 'positive' : 'negative'}">$${(trade.netPL || trade.profit).toFixed(2)}</td>`;
                if (columns.setup) html += `<td>${trade.setupType || '-'}</td>`;

                html += `<td><button class="btn btn-secondary" onclick="toggleTradeDetails(${index})">Details</button></td>`;

                row.innerHTML = html;

                // Add expandable details row
                const detailRow = tbody.insertRow();
                detailRow.style.display = 'none';
                detailRow.innerHTML = `
                    <td colspan="${Object.values(columns).filter(Boolean).length + 1}">
                        <div class="trade-details" id="details_${index}"></div>
                    </td>
                `;
            });
        }

        // Export Menu Functions
        function toggleExportMenu() {
            setShowExportMenu(!appState.showExportMenu);
            if (appState.showExportMenu) {
                updateSizeEstimates();
            }
        }
        
        function setShowExportMenu(show) {
            appState.showExportMenu = show;
            const dropdown = document.getElementById('exportDropdown');
            dropdown.style.display = show ? 'block' : 'none';
        }
        
        function handleExportData(exportType = 'full') {
            if (appState.trades.length === 0) {
                showMessage('No data to export', 'error');
                return;
            }
            
            const timestamp = new Date().toISOString().split('T')[0];
            let exportData = {};
            let filename = '';
            
            switch(exportType) {
                case 'full':
                    // Complete export with everything
                    exportData = {
                        trades: appState.trades,
                        screenshots: getScreenshotsObject(),
                        startingBalance: appState.startingBalance,
                        finalBalance: appState.currentBalance,
                        customRules: appState.customRules,
                        strategyContext: appState.strategyContext,
                        visibleStats: appState.visibleStats,
                        statsOrder: appState.statsOrder,
                        visibleCharts: appState.visibleCharts,
                        chartOrder: appState.chartOrder,
                        visibleColumns: appState.visibleColumns,
                        visiblePerformanceSections: appState.visiblePerformanceSections,
                        visibleTimeStats: appState.visibleTimeStats,
                        chartZoom: appState.chartZoom,
                        showCalendar: appState.showCalendar,
                        importMode: document.getElementById('importMode').value,
                        uiPreferences: {
                            showTradeHistory: appState.showTradeHistory,
                            showAccountSettings: appState.showAccountSettings
                        },
                        appVersion: '1.7',
                        exportDate: new Date().toISOString(),
                        exportType: 'full'
                    };
                    filename = `trading-journal-full-${timestamp}.json`;
                    break;
                
                case 'trades-only':
                    // Just trades, no settings or screenshots
                    exportData = {
                        trades: appState.trades.map(trade => ({
                            ...trade,
                            entryScreenshot: null,
                            exitScreenshot: null
                        })),
                        startingBalance: appState.startingBalance,
                        finalBalance: appState.currentBalance,
                        appVersion: '1.7',
                        exportDate: new Date().toISOString(),
                        exportType: 'trades-only'
                    };
                    filename = `trading-journal-trades-${timestamp}.json`;
                    break;
                
                case 'no-screenshots':
                    // Everything except screenshots (much smaller file)
                    exportData = {
                        trades: appState.trades.map(trade => ({
                            ...trade,
                            entryScreenshot: null,
                            exitScreenshot: null
                        })),
                        startingBalance: appState.startingBalance,
                        finalBalance: appState.currentBalance,
                        customRules: appState.customRules,
                        strategyContext: appState.strategyContext,
                        visibleStats: appState.visibleStats,
                        statsOrder: appState.statsOrder,
                        visibleCharts: appState.visibleCharts,
                        chartOrder: appState.chartOrder,
                        visibleColumns: appState.visibleColumns,
                        visiblePerformanceSections: appState.visiblePerformanceSections,
                        visibleTimeStats: appState.visibleTimeStats,
                        chartZoom: appState.chartZoom,
                        showCalendar: appState.showCalendar,
                        importMode: document.getElementById('importMode').value,
                        uiPreferences: {
                            showTradeHistory: appState.showTradeHistory,
                            showAccountSettings: appState.showAccountSettings
                        },
                        appVersion: '1.7',
                        exportDate: new Date().toISOString(),
                        exportType: 'no-screenshots',
                        note: 'Screenshots excluded to reduce file size'
                    };
                    filename = `trading-journal-no-screenshots-${timestamp}.json`;
                    break;
                
                case 'screenshots-only':
                    // Export only screenshots data
                    const screenshotTrades = appState.trades.filter(t => t.entryScreenshot || t.exitScreenshot);
                    const screenshotCount = screenshotTrades.length;
                    
                    if (screenshotCount === 0) {
                        showMessage('⚠️ No screenshots to export', 'error');
                        return;
                    }
                    
                    const screenshots = getScreenshotsObject();
                    exportData = {
                        screenshots: screenshots,
                        tradeIds: Object.keys(screenshots),
                        screenshotCount: screenshotCount,
                        exportDate: new Date().toISOString(),
                        exportType: 'screenshots-only',
                        appVersion: '1.8',
                        note: 'Import this file to restore screenshots. Trade data not included.'
                    };
                    
                    // Calculate approximate size
                    const dataSize = JSON.stringify(screenshots).length;
                    const sizeMB = (dataSize / (1024 * 1024)).toFixed(2);
                    
                    filename = `trading-journal-screenshots-${timestamp}.json`;
                    
                    if (parseFloat(sizeMB) > 1) {
                        if (!window.confirm(`📸 Exporting ${screenshotCount} screenshot(s)\nApproximate size: ${sizeMB} MB\n\nThis may take a moment to download. Continue?`)) {
                            return;
                        }
                    } else {
                        showMessage(`📸 Exporting ${screenshotCount} screenshot(s)\nApproximate size: ${sizeMB} MB`);
                    }
                    break;
                
                case 'csv':
                    // Export as CSV for Excel
                    return handleExportCSV();
                
                default:
                    exportData = { trades: appState.trades };
                    filename = `trading-journal-${timestamp}.json`;
            }
            
            try {
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                    type: 'application/json' 
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show download notification
                showDownloadNotification({
                    filename: filename,
                    type: exportType,
                    timestamp: new Date().toLocaleTimeString()
                });
                
                showMessage(`✅ Exported successfully!\nFile: ${filename}\nType: ${exportType}`);
            } catch (error) {
                console.error('Export error:', error);
                showMessage('❌ Error exporting data: ' + error.message, 'error');
            }
        }
        
        function handleExportCSV() {
            if (!appState.trades.length) {
                showMessage('⚠️ No trades to export', 'error');
                return;
            }
            
            const timestamp = new Date().toISOString().split('T')[0];
            
            // CSV Headers
            const headers = [
                'Open Date', 'Open Time', 'Close Date', 'Close Time', 'Symbol', 'Direction', 'Entry Price', 'Exit Price',
                'Volume', 'Pips', 'Gross P/L', 'Net P/L', 'Commission', 'Swap',
                'Setup Type', 'Market Condition', 'Emotional State', 'Rule Adherence', 'Notes'
            ];

            // CSV Rows
            const rows = appState.trades.map(trade => [
                trade.openDate || '',
                trade.openTime || '',
                formatDate(trade.closeTime || trade.date),
                formatTime(trade.closeTime || trade.time),
                trade.symbol,
                trade.direction,
                trade.entryPrice,
                trade.exitPrice || trade.closePrice,
                trade.volume || trade.quantity,
                trade.pips,
                trade.grossProfit || trade.grossPL || 0,
                trade.netPL || trade.profit,
                trade.commission,
                trade.swap,
                trade.setupType || '',
                trade.marketCondition || '',
                trade.emotionalState || '',
                trade.ruleAdherence || '',
                (trade.notes || '').replace(/"/g, '""') // Escape quotes
            ]);
            
            // Build CSV content
            let csvContent = headers.join(',') + '\n';
            rows.forEach(row => {
                csvContent += row.map(cell => {
                    // Quote cells that contain commas or quotes
                    const str = String(cell);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str}"`;
                    }
                    return str;
                }).join(',') + '\n';
            });
            
            // Download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trading-journal-${timestamp}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show CSV download notification
            showDownloadNotification({
                filename: `trading-journal-${timestamp}.csv`,
                type: 'csv',
                timestamp: new Date().toLocaleTimeString()
            });
            
            showMessage(`✅ Exported ${appState.trades.length} trades as CSV!\nFile: trading-journal-${timestamp}.csv`);
        }
        
        // Size estimation functions
        function estimateFullSize() {
            const fullData = {
                trades: appState.trades,
                screenshots: getScreenshotsObject(),
                startingBalance: appState.startingBalance,
                customRules: appState.customRules,
                strategyContext: appState.strategyContext,
                visibleStats: appState.visibleStats,
                visibleCharts: appState.visibleCharts,
                visibleColumns: appState.visibleColumns
            };
            const size = JSON.stringify(fullData).length;
            return formatBytes(size);
        }
        
        function estimateScreenshotsSize() {
            const screenshots = getScreenshotsObject();
            const size = JSON.stringify(screenshots).length;
            return formatBytes(size);
        }
        
        function estimateNoScreenshotsSize() {
            const dataWithoutScreenshots = {
                trades: appState.trades.map(trade => ({ ...trade, entryScreenshot: null, exitScreenshot: null })),
                startingBalance: appState.startingBalance,
                customRules: appState.customRules,
                strategyContext: appState.strategyContext,
                visibleStats: appState.visibleStats,
                visibleCharts: appState.visibleCharts,
                visibleColumns: appState.visibleColumns
            };
            const size = JSON.stringify(dataWithoutScreenshots).length;
            return formatBytes(size);
        }
        
        function estimateTradesSize() {
            const tradesData = {
                trades: appState.trades.map(trade => ({ ...trade, entryScreenshot: null, exitScreenshot: null })),
                startingBalance: appState.startingBalance,
                finalBalance: appState.currentBalance
            };
            const size = JSON.stringify(tradesData).length;
            return formatBytes(size);
        }
        
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        function updateSizeEstimates() {
            if (appState.trades.length === 0) {
                document.getElementById('fullSizeEstimate').textContent = '~0 B';
                document.getElementById('noScreenshotsSizeEstimate').textContent = '~0 B';
                document.getElementById('screenshotsSizeEstimate').textContent = '~0 B';
                document.getElementById('tradesSizeEstimate').textContent = '~0 B';
                return;
            }
            
            try {
                document.getElementById('fullSizeEstimate').textContent = '~' + estimateFullSize();
                document.getElementById('noScreenshotsSizeEstimate').textContent = '~' + estimateNoScreenshotsSize();
                document.getElementById('screenshotsSizeEstimate').textContent = '~' + estimateScreenshotsSize();
                document.getElementById('tradesSizeEstimate').textContent = '~' + estimateTradesSize();
            } catch (error) {
                console.error('Error updating size estimates:', error);
            }
        }
        
        function showDownloadLocationInfo() {
            const message = '💾 DOWNLOAD LOCATION\n\n' +
                'Files are saved to your browser\'s default download folder.\n\n' +
                '📂 Common locations:\n' +
                '• Windows: C:\\Users\\YourName\\Downloads\n' +
                '• Mac: /Users/YourName/Downloads\n' +
                '• Linux: ~/Downloads\n\n' +
                '⚙️ To change location:\n' +
                'Check your browser\'s download settings (usually in Settings > Downloads)';
            
            alert(message);
        }
        
        // Helper function to get screenshots object
        function getScreenshotsObject() {
            const screenshots = {};
            appState.trades.forEach(trade => {
                if (trade.entryScreenshot || trade.exitScreenshot) {
                    screenshots[trade.id] = {
                        entry: trade.entryScreenshot ? [trade.entryScreenshot] : [],
                        exit: trade.exitScreenshot ? [trade.exitScreenshot] : []
                    };
                }
            });
            return screenshots;
        }
        
        // Helper functions for CSV export
        function formatDate(dateTime) {
            if (!dateTime) return '';
            if (dateTime.includes(' ')) {
                return dateTime.split(' ')[0];
            }
            return dateTime;
        }
        
        function formatTime(dateTime) {
            if (!dateTime) return '';
            if (dateTime.includes(' ')) {
                const timePart = dateTime.split(' ')[1];
                return timePart ? timePart.substring(0, 5) : '';
            }
            return dateTime.substring(0, 5);
        }

        // CRITICAL FIX: Helper function to get screenshot source with proper data URI prefix
        function getScreenshotSrc(base64Data) {
            // Check if data exists and is a string
            if (!base64Data || typeof base64Data !== 'string') {
                return null;
            }
            
            // If already has data URI prefix, return as-is
            if (base64Data.startsWith('data:image/')) {
                return base64Data;
            }
            
            // If it's raw Base64, add the prefix
            return `data:image/png;base64,${base64Data}`;
        }

        function handleJSONImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Security: File size validation
            if (file.size > MAX_FILE_SIZE) {
                showMessage(`File too large. Maximum size: ${MAX_FILE_SIZE / (1024 * 1024)}MB`, 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.json')) {
                showMessage('Please select a JSON file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate data structure
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid JSON format');
                    }
                    
                    // Check if it's a screenshots-only export
                    if (data.exportType === 'screenshots-only') {
                        if (!data.screenshots) {
                            showMessage('❌ No screenshots found in file', 'error');
                            return;
                        }
                        
                        // Merge with existing screenshots
                        let importedCount = 0;
                        Object.entries(data.screenshots).forEach(([tradeId, screenshots]) => {
                            const trade = appState.trades.find(t => t.id === tradeId);
                            if (trade) {
                                if (screenshots.entry && screenshots.entry.length > 0) {
                                    trade.entryScreenshot = getScreenshotSrc(screenshots.entry[0]);
                                }
                                if (screenshots.exit && screenshots.exit.length > 0) {
                                    trade.exitScreenshot = getScreenshotSrc(screenshots.exit[0]);
                                }
                                importedCount++;
                            }
                        });
                        
                        updateUI();
                        showMessage(`✅ Imported screenshots for ${importedCount} trades\n\nScreenshots have been added to your existing trades.`);
                        return;
                    }
                    
                    // Check if it's a comprehensive journal export format
                    if (data.trades && Array.isArray(data.trades) && data.version) {
                        // Filter out trades with invalid symbols before processing
                        const validTrades = data.trades.filter(trade => {
                            const symbol = trade.symbol || '';
                            // Security: Validate symbol and basic trade structure
                            if (!isValidSymbol(symbol)) return false;
                            try {
                                // Basic validation - will be more thorough in mapping
                                if (!trade.entryPrice || !trade.exitPrice) return false;
                                return true;
                            } catch (e) {
                                return false;
                            }
                        });
                        const skippedCount = data.trades.length - validTrades.length;
                        
                        // Full journal restore
                        appState.trades = validTrades.map(trade => {
                            // Parse date/time from closeTime if available
                            let parsedDate, parsedTime;
                            if (trade.closeTime) {
                                const parsed = parsecTraderDateTime(trade.closeTime);
                                parsedDate = parsed.date;
                                parsedTime = parsed.time;
                            } else {
                                parsedDate = trade.date || new Date().toISOString().split('T')[0];
                                parsedTime = trade.time || '12:00';
                            }
                            
                            // CRITICAL FIX: Handle Base64 screenshots with proper validation
                            let entryScreenshot = null;
                            let exitScreenshot = null;
                            
                            // Check all possible screenshot field names with validation
                            const entryScreenshotData = 
                                trade.entryScreenshot || 
                                trade.screenshotEntry || 
                                trade.screenshot_entry ||
                                null;
                            
                            const exitScreenshotData = 
                                trade.exitScreenshot || 
                                trade.screenshotExit || 
                                trade.screenshot_exit ||
                                null;
                            
                            // Only process if we have valid string data
                            if (entryScreenshotData && typeof entryScreenshotData === 'string') {
                                entryScreenshot = getScreenshotSrc(entryScreenshotData);
                            }
                            
                            if (exitScreenshotData && typeof exitScreenshotData === 'string') {
                                exitScreenshot = getScreenshotSrc(exitScreenshotData);
                            }
                            
                            return {
                                ...trade,
                                // Ensure all required fields exist
                                id: trade.id || `${Date.now()}_${Math.random()}`,
                                rulesFollowed: trade.rulesFollowed || [],
                                setupType: trade.setupType || '',
                                marketCondition: trade.marketCondition || '',
                                emotionalState: trade.emotionalState || '',
                                ruleAdherence: trade.ruleAdherence || '',
                                notes: trade.notes || '',
                                tradingViewEntry: trade.tradingViewEntry || '',
                                tradingViewExit: trade.tradingViewExit || '',
                                entryScreenshot: entryScreenshot,
                                exitScreenshot: exitScreenshot,
                                // Map different field names for compatibility
                                netPL: trade.netPL || trade.profit || trade.netProfit || 0, // Primary field
                                profit: trade.netPL || trade.profit || trade.netProfit || 0, // For compatibility
                                netProfit: trade.netPL || trade.profit || trade.netProfit || 0,
                                date: parsedDate,
                                time: parsedTime,
                                closeTime: trade.closeTime || `${parsedDate} ${parsedTime}`,
                                entryPrice: trade.entryPrice || 0,
                                exitPrice: trade.closePrice || trade.exitPrice || 0,
                                volume: trade.quantity || trade.volume || 1,
                                pips: trade.pips || 0,
                                commission: trade.commission || 0,
                                swap: trade.swap || 0
                            };
                        });
                        
                        // CRITICAL FIX: Import screenshots with array format handling
                        if (data.screenshots && typeof data.screenshots === 'object' && !Array.isArray(data.screenshots)) {
                            const screenshotsObj = {};
                            
                            Object.entries(data.screenshots).forEach(([tradeId, images]) => {
                                if (images && typeof images === 'object') {
                                    const screenshotData = {};
                                    
                                    // Handle entry (array or string)
                                    if (Array.isArray(images.entry)) {
                                        if (images.entry.length > 0 && typeof images.entry[0] === 'string') {
                                            screenshotData.entry = images.entry[0];
                                        }
                                    } else if (typeof images.entry === 'string' && images.entry) {
                                        screenshotData.entry = images.entry;
                                    }
                                    
                                    // Handle exit (array or string)
                                    if (Array.isArray(images.exit)) {
                                        if (images.exit.length > 0 && typeof images.exit[0] === 'string') {
                                            screenshotData.exit = images.exit[0];
                                        }
                                    } else if (typeof images.exit === 'string' && images.exit) {
                                        screenshotData.exit = images.exit;
                                    }
                                    
                                    // Only add if we have at least one screenshot
                                    if (screenshotData.entry || screenshotData.exit) {
                                        screenshotsObj[tradeId] = screenshotData;
                                    }
                                }
                            });
                            
                            // Apply screenshots to matching trades
                            Object.entries(screenshotsObj).forEach(([tradeId, screenshots]) => {
                                const trade = appState.trades.find(t => t.id === tradeId);
                                if (trade) {
                                    if (screenshots.entry && !trade.entryScreenshot) {
                                        const entryScreenshotSrc = getScreenshotSrc(screenshots.entry);
                                        if (entryScreenshotSrc) {
                                            trade.entryScreenshot = entryScreenshotSrc;
                                        }
                                    }
                                    
                                    if (screenshots.exit && !trade.exitScreenshot) {
                                        const exitScreenshotSrc = getScreenshotSrc(screenshots.exit);
                                        if (exitScreenshotSrc) {
                                            trade.exitScreenshot = exitScreenshotSrc;
                                        }
                                    }
                                }
                            });
                            
                            console.log('✅ Processed screenshots for', Object.keys(screenshotsObj).length, 'trades');
                        }
                        
                        appState.startingBalance = data.startingBalance || data.finalBalance - appState.trades.reduce((sum, t) => sum + t.profit, 0) || 10000;
                        appState.customRules = data.customRules || [];
                        
                        // Import strategy context
                        if (data.strategyContext) {
                            appState.strategyContext = data.strategyContext;
                            document.getElementById('strategyContextTextarea').value = data.strategyContext;
                            updateStrategyContextCounter();
                        }
                        
                        // Restore view settings
                        if (data.visibleStats) appState.visibleStats = { ...appState.visibleStats, ...data.visibleStats };
                        if (data.visibleColumns) appState.visibleColumns = { ...appState.visibleColumns, ...data.visibleColumns };
                        if (data.visibleCharts) appState.visibleCharts = { ...appState.visibleCharts, ...data.visibleCharts };
                        if (data.chartZoom) appState.chartZoom = data.chartZoom;
                        
                        // Restore UI preferences
                        if (data.uiPreferences) {
                            if (data.uiPreferences.showTradeHistory !== undefined) {
                                appState.showTradeHistory = data.uiPreferences.showTradeHistory;
                            }
                            if (data.uiPreferences.showAccountSettings !== undefined) {
                                appState.showAccountSettings = data.uiPreferences.showAccountSettings;
                            }
                        }
                        
                        updateUI();
                        
                        // Show import message with filtering info
                        const screenshotCount = appState.trades.filter(t => t.entryScreenshot || t.exitScreenshot).length;
                        const screenshotMsg = screenshotCount > 0 ? ` (${screenshotCount} trades with screenshots)` : '';
                        if (skippedCount > 0) {
                            showMessage(`✅ Imported ${validTrades.length} trades (${skippedCount} skipped - invalid symbols) with all journal data${screenshotMsg}`);
                        } else {
                            showMessage(`✅ Imported ${validTrades.length} trades with all journal data successfully${screenshotMsg}`);
                        }
                        
                        // Auto-expand trade history after successful import
                        if (validTrades.length > 0) {
                            appState.showTradeHistory = true;
                            updateTradeHistoryCollapseState();
                        }
                    } else if (data.trades && Array.isArray(data.trades)) {
                        // Filter out trades with invalid symbols
                        const validTrades = data.trades.filter(trade => {
                            const symbol = trade.symbol || '';
                            return isValidSymbol(symbol);
                        });
                        const skippedCount = data.trades.length - validTrades.length;
                        
                        // Simple trades array format
                        appState.trades = validTrades.map(trade => {
                            // Parse date/time from closeTime if available
                            let parsedDate, parsedTime;
                            if (trade.closeTime) {
                                const parsed = parsecTraderDateTime(trade.closeTime);
                                parsedDate = parsed.date;
                                parsedTime = parsed.time;
                            } else {
                                parsedDate = trade.date || new Date().toISOString().split('T')[0];
                                parsedTime = trade.time || '12:00';
                            }
                            
                            // CRITICAL FIX: Handle Base64 screenshots with proper validation for simple format
                            let entryScreenshot = null;
                            let exitScreenshot = null;
                            
                            // Check all possible screenshot field names with validation
                            const entryScreenshotData = 
                                trade.entryScreenshot || 
                                trade.screenshotEntry || 
                                trade.screenshot_entry ||
                                null;
                            
                            const exitScreenshotData = 
                                trade.exitScreenshot || 
                                trade.screenshotExit || 
                                trade.screenshot_exit ||
                                null;
                            
                            // Only process if we have valid string data
                            if (entryScreenshotData && typeof entryScreenshotData === 'string') {
                                entryScreenshot = getScreenshotSrc(entryScreenshotData);
                            }
                            
                            if (exitScreenshotData && typeof exitScreenshotData === 'string') {
                                exitScreenshot = getScreenshotSrc(exitScreenshotData);
                            }
                            
                            return {
                                ...trade,
                                id: trade.id || `${Date.now()}_${Math.random()}`,
                                netPL: trade.netPL || trade.profit || 0,
                                profit: trade.netPL || trade.profit || 0,
                                date: parsedDate,
                                time: parsedTime,
                                closeTime: trade.closeTime || `${parsedDate} ${parsedTime}`,
                                rulesFollowed: trade.rulesFollowed || [],
                                setupType: trade.setupType || '',
                                marketCondition: trade.marketCondition || '',
                                emotionalState: trade.emotionalState || '',
                                ruleAdherence: trade.ruleAdherence || '',
                                notes: trade.notes || '',
                                entryScreenshot: entryScreenshot,
                                exitScreenshot: exitScreenshot
                            };
                        });
                        
                        // CRITICAL FIX: Import screenshots with array format handling (simple format)
                        if (data.screenshots && typeof data.screenshots === 'object' && !Array.isArray(data.screenshots)) {
                            const screenshotsObj = {};
                            
                            Object.entries(data.screenshots).forEach(([tradeId, images]) => {
                                if (images && typeof images === 'object') {
                                    const screenshotData = {};
                                    
                                    // Handle entry (array or string)
                                    if (Array.isArray(images.entry)) {
                                        if (images.entry.length > 0 && typeof images.entry[0] === 'string') {
                                            screenshotData.entry = images.entry[0];
                                        }
                                    } else if (typeof images.entry === 'string' && images.entry) {
                                        screenshotData.entry = images.entry;
                                    }
                                    
                                    // Handle exit (array or string)
                                    if (Array.isArray(images.exit)) {
                                        if (images.exit.length > 0 && typeof images.exit[0] === 'string') {
                                            screenshotData.exit = images.exit[0];
                                        }
                                    } else if (typeof images.exit === 'string' && images.exit) {
                                        screenshotData.exit = images.exit;
                                    }
                                    
                                    // Only add if we have at least one screenshot
                                    if (screenshotData.entry || screenshotData.exit) {
                                        screenshotsObj[tradeId] = screenshotData;
                                    }
                                }
                            });
                            
                            // Apply screenshots to matching trades
                            Object.entries(screenshotsObj).forEach(([tradeId, screenshots]) => {
                                const trade = appState.trades.find(t => t.id === tradeId);
                                if (trade) {
                                    if (screenshots.entry && !trade.entryScreenshot) {
                                        const entryScreenshotSrc = getScreenshotSrc(screenshots.entry);
                                        if (entryScreenshotSrc) {
                                            trade.entryScreenshot = entryScreenshotSrc;
                                        }
                                    }
                                    
                                    if (screenshots.exit && !trade.exitScreenshot) {
                                        const exitScreenshotSrc = getScreenshotSrc(screenshots.exit);
                                        if (exitScreenshotSrc) {
                                            trade.exitScreenshot = exitScreenshotSrc;
                                        }
                                    }
                                }
                            });
                            
                            console.log('✅ Processed screenshots for', Object.keys(screenshotsObj).length, 'trades');
                        }
                        
                        appState.startingBalance = data.startingBalance || 10000;
                        if (data.customRules) appState.customRules = data.customRules;
                        
                        // Import strategy context for simple format
                        if (data.strategyContext) {
                            appState.strategyContext = data.strategyContext;
                            document.getElementById('strategyContextTextarea').value = data.strategyContext;
                            updateStrategyContextCounter();
                        }
                        
                        // Restore UI preferences for simple format
                        if (data.uiPreferences) {
                            if (data.uiPreferences.showTradeHistory !== undefined) {
                                appState.showTradeHistory = data.uiPreferences.showTradeHistory;
                            }
                            if (data.uiPreferences.showAccountSettings !== undefined) {
                                appState.showAccountSettings = data.uiPreferences.showAccountSettings;
                            }
                        }
                        
                        updateUI();
                        
                        // Show import message with filtering info
                        const screenshotCount = appState.trades.filter(t => t.entryScreenshot || t.exitScreenshot).length;
                        const screenshotMsg = screenshotCount > 0 ? ` (${screenshotCount} trades with screenshots)` : '';
                        if (skippedCount > 0) {
                            showMessage(`✅ Imported ${validTrades.length} trades (${skippedCount} skipped - invalid symbols)${screenshotMsg}`);
                        } else {
                            showMessage(`✅ Imported ${validTrades.length} trades successfully${screenshotMsg}`);
                        }
                        
                        // Auto-expand trade history after successful import
                        if (validTrades.length > 0) {
                            appState.showTradeHistory = true;
                            updateTradeHistoryCollapseState();
                        }
                    } else {
                        throw new Error('Invalid file format - expected trades array or journal export');
                    }
                } catch (error) {
                    console.error('JSON import error:', error);
                    showMessage(`❌ Error importing data: ${error.message}\n\nPlease check that your file is a valid Trading Journal export.`, 'error');
                }
            };
            reader.readAsText(file);
        }
        

        // Helper function to open TradingView links
        function openTradingViewLink(tradeIndex, type) {
            const trade = appState.trades[tradeIndex];
            const url = type === 'entry' ? trade.tradingViewEntry : trade.tradingViewExit;


            // Security: Use safe URL opener with validation
            if (url && url.trim()) {
                safeOpenURL(url);
            } else {
                showMessage('Please enter a TradingView URL first', 'error');
            }
        }

        // Helper function to clear screenshots
        function clearScreenshot(tradeIndex, type) {
            const field = type === 'entry' ? 'entryScreenshot' : 'exitScreenshot';
            appState.trades[tradeIndex][field] = null;
            renderTradeDetails(tradeIndex); // Refresh the details view
            showMessage(`${type.charAt(0).toUpperCase() + type.slice(1)} screenshot removed`, 'success');
        }

        // Enhanced updateTradeField to handle button state updates
        function updateTradeField(tradeIndex, field, value) {
            appState.trades[tradeIndex][field] = value;
            calculateStatistics();
            updateUI();

            // Update TradingView button states if it's a TradingView field
            if (field === 'tradingViewEntry') {
                const button = document.querySelector(`button[onclick="openTradingViewLink(${tradeIndex}, 'entry')"]`);
                if (button) {
                    button.disabled = !value || !value.trim();
                }
            } else if (field === 'tradingViewExit') {
                const button = document.querySelector(`button[onclick="openTradingViewLink(${tradeIndex}, 'exit')"]`);
                if (button) {
                    button.disabled = !value || !value.trim();
                }
            }
        }
        
        function handleScreenshotUpload(tradeIndex, type, input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const field = type === 'entry' ? 'entryScreenshot' : 'exitScreenshot';
                appState.trades[tradeIndex][field] = e.target.result;
                renderTradeDetails(tradeIndex); // Refresh to show image
            };
            reader.readAsDataURL(file);
        }
        
        function handlePaste(event) {
            const items = event.clipboardData?.items;
            if (!items) return;

            // Check if we have an active trade details section open
            if (appState.activeTradeIndex === null) {
                return; // No trade details open, ignore paste
            }

            for (let item of items) {
                if (item.type.startsWith('image/')) {
                    event.preventDefault(); // Prevent default paste behavior

                    const file = item.getAsFile();
                    if (!file) continue;

                    // Read the file and save it to the appropriate screenshot field
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const tradeIndex = appState.activeTradeIndex;
                        const field = appState.activePasteTarget === 'entry' ? 'entryScreenshot' : 'exitScreenshot';
                        const type = appState.activePasteTarget;

                        // Save the screenshot to the trade
                        appState.trades[tradeIndex][field] = e.target.result;

                        // Refresh the trade details to show the new screenshot
                        renderTradeDetails(tradeIndex);

                        // Show success message
                        showMessage(`${type.charAt(0).toUpperCase() + type.slice(1)} screenshot pasted successfully`, 'success');
                    };
                    reader.readAsDataURL(file);

                    break; // Only handle the first image
                }
            }
        }
        
        function generateRulesChecklist(tradeIndex, followedRules) {
            return appState.customRules.map(rule => {
                const isChecked = followedRules.includes(rule.id);
                return `
                    <label style="display: block; margin-bottom: 0.5rem;">
                        <input type="checkbox" ${isChecked ? 'checked' : ''} 
                               onchange="toggleTradeRule(${tradeIndex}, ${rule.id}, this.checked)">
                        ${rule.text}
                    </label>
                `;
            }).join('');
        }
        
        function toggleTradeRule(tradeIndex, ruleId, checked) {
            const trade = appState.trades[tradeIndex];
            if (!trade.rulesFollowed) trade.rulesFollowed = [];
            
            if (checked) {
                if (!trade.rulesFollowed.includes(ruleId)) {
                    trade.rulesFollowed.push(ruleId);
                }
            } else {
                trade.rulesFollowed = trade.rulesFollowed.filter(id => id !== ruleId);
            }
            
            calculateStatistics();
            updateUI();
        }
        
        // Lightbox Functions
        function openLightbox(imageSrc) {
            document.getElementById('lightboxImage').src = imageSrc;
            document.getElementById('lightbox').style.display = 'flex';
        }
        
        function closeLightbox() {
            document.getElementById('lightbox').style.display = 'none';
        }
        
        // Custom Rules Management
        function updateRuleCombinationsAnalysis() {
            const resultsDiv = document.getElementById('ruleCombinationsResults');

            // Get combinations based on selected view: TOTAL (-1) or specific month
            const combinations = appState.ruleCombinationsCurrentMonth === -1
                ? calculateRuleCombinations()
                : calculateRuleCombinations(appState.ruleCombinationsCurrentYear, appState.ruleCombinationsCurrentMonth);
            
            if (combinations.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="padding: 2rem; text-center; color: var(--color-text-secondary);">
                        <p>No trades with Custom rule adherence found.</p>
                        <p style="font-size: var(--font-size-xs); margin-top: var(--space-8);">
                            Mark trades as "Custom" and check which rules you followed to see analysis.
                        </p>
                    </div>
                `;
                return;
            }
            
            const bestCombination = combinations[0];
            const mostProfitableCombination = combinations.sort((a, b) => b.totalPL - a.totalPL)[0];
            const worstCombination = combinations[combinations.length - 1];
            
            // Re-sort for display
            combinations.sort((a, b) => {
                if (Math.abs(b.winRate - a.winRate) > 1) {
                    return b.winRate - a.winRate;
                }
                return b.totalPL - a.totalPL;
            });
            
            resultsDiv.innerHTML = `
                <!-- Summary Stats -->
                <div style="margin-bottom: 1rem; padding: var(--space-12); background: var(--color-bg-1); border-radius: var(--radius-base);">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; text-align: center;">
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Total Combinations</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold);">${combinations.length}</div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Best Win Rate</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: var(--color-success);">
                                ${bestCombination.winRate.toFixed(1)}%
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Best Combination</div>
                            <div style="font-size: var(--font-size-xs); font-weight: var(--font-weight-medium); max-width: 150px; margin: 0 auto; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${bestCombination.ruleNames.length} ${bestCombination.ruleNames.length === 1 ? 'rule' : 'rules'}
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Combinations Table -->
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: var(--font-size-sm);">
                        <thead style="background: var(--color-bg-2);">
                            <tr>
                                <th style="padding: var(--space-8); text-align: left;">Rank</th>
                                <th style="padding: var(--space-8); text-align: left;">Rule Combination</th>
                                <th style="padding: var(--space-8); text-align: center;">Trades</th>
                                <th style="padding: var(--space-8); text-align: center;">W/L</th>
                                <th style="padding: var(--space-8); text-align: center;">Win Rate</th>
                                <th style="padding: var(--space-8); text-align: right;">Total P&L</th>
                                <th style="padding: var(--space-8); text-align: center;">PF</th>
                                <th style="padding: var(--space-8); text-align: right;">Expectancy</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${combinations.map((combo, index) => `
                                <tr style="border-top: 1px solid var(--color-border); ${
                                    index === 0 ? 'background: rgba(var(--color-success-rgb), 0.1);' :
                                    index === combinations.length - 1 ? 'background: rgba(var(--color-error-rgb), 0.1);' :
                                    ''
                                } transition: background-color var(--duration-fast) var(--ease-standard);" onmouseover="this.style.backgroundColor='var(--color-secondary-hover)'" onmouseout="this.style.backgroundColor='${index === 0 ? 'rgba(var(--color-success-rgb), 0.1)' : index === combinations.length - 1 ? 'rgba(var(--color-error-rgb), 0.1)' : 'transparent'}'">
                                    <td style="padding: var(--space-8);">
                                        ${index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`}
                                    </td>
                                    <td style="padding: var(--space-8);">
                                        <div style="display: flex; flex-wrap: wrap; gap: var(--space-4);">
                                            ${combo.ruleNames.map((name, i) => `
                                                <span style="padding: var(--space-2) var(--space-6); background: var(--color-bg-3); color: var(--color-primary); border-radius: var(--radius-sm); font-size: var(--font-size-xs);">
                                                    ${name}
                                                </span>
                                            `).join('')}
                                        </div>
                                    </td>
                                    <td style="padding: var(--space-8); text-align: center;">${combo.totalTrades}</td>
                                    <td style="padding: var(--space-8); text-align: center;">
                                        <span style="color: var(--color-success);">${combo.wins}</span>/
                                        <span style="color: var(--color-error);">${combo.losses}</span>
                                    </td>
                                    <td style="padding: var(--space-8); text-align: center;">
                                        <span style="color: ${
                                            combo.winRate >= 60 ? 'var(--color-success)' :
                                            combo.winRate >= 50 ? 'var(--color-warning)' :
                                            'var(--color-error)'
                                        }; font-weight: ${combo.winRate >= 60 ? 'var(--font-weight-bold)' : 'normal'};">
                                            ${combo.winRate.toFixed(1)}%
                                        </span>
                                    </td>
                                    <td style="padding: var(--space-8); text-align: right; font-family: var(--font-family-mono); color: ${combo.totalPL >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">
                                        $${combo.totalPL.toFixed(2)}
                                    </td>
                                    <td style="padding: var(--space-8); text-align: center;">
                                        ${combo.profitFactor > 0 ? combo.profitFactor.toFixed(2) : '—'}
                                    </td>
                                    <td style="padding: var(--space-8); text-align: right; font-family: var(--font-family-mono); color: ${combo.expectancy >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">
                                        $${combo.expectancy.toFixed(2)}
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
                
                <!-- Insights -->
                <div style="margin-top: 1rem; padding: var(--space-12); background: var(--color-bg-3); border: 1px solid rgba(var(--color-primary-rgb), 0.3); border-radius: var(--radius-base);">
                    <h4 style="font-weight: var(--font-weight-semibold); color: var(--color-primary); margin-bottom: var(--space-8); font-size: var(--font-size-sm);">💡 Key Insights:</h4>
                    <ul style="font-size: var(--font-size-sm); color: var(--color-text); margin: 0; padding-left: var(--space-16); line-height: 1.6;">
                        <li style="margin-bottom: var(--space-4);">🥇 <strong>Best combination:</strong> ${bestCombination.displayName} with ${bestCombination.winRate.toFixed(1)}% win rate (${bestCombination.totalTrades} trades)</li>
                        <li style="margin-bottom: var(--space-4);">📊 <strong>Most profitable:</strong> ${mostProfitableCombination.displayName} with $${mostProfitableCombination.totalPL.toFixed(2)} total P&L</li>
                        <li style="margin-bottom: 0;">⚠️ <strong>Least effective:</strong> ${worstCombination.displayName} with ${worstCombination.winRate.toFixed(1)}% win rate</li>
                    </ul>
                </div>
            `;
        }
        
        function updateCustomRulesDisplay() {
            const rulesGrid = document.getElementById('rulesGrid');
            const ruleStats = document.getElementById('ruleStats');
            
            rulesGrid.innerHTML = appState.customRules.map((rule, index) => `
                <div class="rule-card">
                    <input type="text" class="form-control" value="${rule.text}" 
                           onchange="updateCustomRule(${rule.id}, this.value)" 
                           placeholder="Rule description...">
                    <button class="btn btn-secondary" onclick="removeCustomRule(${rule.id})">Remove</button>
                    <div class="rule-stats">
                        <span>Followed: ${getRuleFollowedCount(rule.id)}</span>
                        <span>Win Rate: ${getRuleWinRate(rule.id).toFixed(1)}%</span>
                    </div>
                </div>
            `).join('');
            
            // Overall rule statistics
            const totalRulesTrades = appState.trades.filter(t => t.rulesFollowed?.length > 0).length;
            const rulesWins = appState.trades.filter(t => t.rulesFollowed?.length > 0 && (t.netPL || t.profit) > 0).length;
            const rulesWinRate = totalRulesTrades > 0 ? (rulesWins / totalRulesTrades * 100) : 0;
            
            const noRulesTrades = appState.trades.filter(t => !t.rulesFollowed || t.rulesFollowed.length === 0).length;
            const noRulesWins = appState.trades.filter(t => (!t.rulesFollowed || t.rulesFollowed.length === 0) && (t.netPL || t.profit) > 0).length;
            const noRulesWinRate = noRulesTrades > 0 ? (noRulesWins / noRulesTrades * 100) : 0;
            
            ruleStats.innerHTML = `
                <div class="breakdown-grid">
                    <div class="breakdown-item">
                        <div class="breakdown-header">With Rules</div>
                        <div class="breakdown-stats">
                            Trades: ${totalRulesTrades}<br>
                            Win Rate: <span class="${rulesWinRate >= 50 ? 'positive' : 'negative'}">${rulesWinRate.toFixed(1)}%</span>
                        </div>
                    </div>
                    <div class="breakdown-item">
                        <div class="breakdown-header">Without Rules</div>
                        <div class="breakdown-stats">
                            Trades: ${noRulesTrades}<br>
                            Win Rate: <span class="${noRulesWinRate >= 50 ? 'positive' : 'negative'}">${noRulesWinRate.toFixed(1)}%</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function addCustomRule() {
            if (appState.customRules.length >= 10) {
                showMessage('Maximum 10 custom rules allowed', 'error');
                return;
            }
            
            const newId = Math.max(...appState.customRules.map(r => r.id), 0) + 1;
            appState.customRules.push({
                id: newId,
                text: 'New Rule',
                enabled: true
            });
            
            updateCustomRulesDisplay();
        }
        
        function updateCustomRule(ruleId, newText) {
            const rule = appState.customRules.find(r => r.id === ruleId);
            if (rule) {
                rule.text = newText;
            }
        }
        
        function removeCustomRule(ruleId) {
            appState.customRules = appState.customRules.filter(r => r.id !== ruleId);
            
            // Remove rule from all trades
            appState.trades.forEach(trade => {
                if (trade.rulesFollowed) {
                    trade.rulesFollowed = trade.rulesFollowed.filter(id => id !== ruleId);
                }
            });
            
            updateCustomRulesDisplay();
        }
        
        function getRuleFollowedCount(ruleId) {
            return appState.trades.filter(t => t.rulesFollowed?.includes(ruleId)).length;
        }
        
        function getRuleWinRate(ruleId) {
            const trades = appState.trades.filter(t => t.rulesFollowed?.includes(ruleId));
            const wins = trades.filter(t => (t.netPL || t.profit) > 0);
            return trades.length > 0 ? (wins.length / trades.length * 100) : 0;
        }
        
        // RULE COMBINATIONS ANALYSIS - NEW FEATURE
        function calculateRuleCombinations(year = null, month = null) {
            if (!appState.trades.length || !appState.customRules.length) return [];

            // Get all trades with Custom rule adherence and rules followed
            let customTrades = appState.trades.filter(t =>
                t.ruleAdherence === 'Custom' &&
                Array.isArray(t.rulesFollowed) &&
                t.rulesFollowed.length > 0
            );

            // Filter by month if specified (month !== null and month !== -1)
            if (month !== null && month !== -1 && year !== null) {
                customTrades = customTrades.filter(t => {
                    const tradeDate = new Date(t.date);
                    return tradeDate.getMonth() === month && tradeDate.getFullYear() === year;
                });
            }
            
            if (customTrades.length === 0) return [];
            
            // Generate all possible combinations
            const combinations = [];
            const ruleIds = appState.customRules.map(r => r.id);
            
            // Single rules
            ruleIds.forEach(ruleId => {
                combinations.push([ruleId]);
            });
            
            // Pairs (2 rules)
            for (let i = 0; i < ruleIds.length; i++) {
                for (let j = i + 1; j < ruleIds.length; j++) {
                    combinations.push([ruleIds[i], ruleIds[j]]);
                }
            }
            
            // Triplets (3 rules)
            for (let i = 0; i < ruleIds.length; i++) {
                for (let j = i + 1; j < ruleIds.length; j++) {
                    for (let k = j + 1; k < ruleIds.length; k++) {
                        combinations.push([ruleIds[i], ruleIds[j], ruleIds[k]]);
                    }
                }
            }
            
            // Quads (4 rules) - if applicable
            if (ruleIds.length >= 4) {
                for (let i = 0; i < ruleIds.length; i++) {
                    for (let j = i + 1; j < ruleIds.length; j++) {
                        for (let k = j + 1; k < ruleIds.length; k++) {
                            for (let l = k + 1; l < ruleIds.length; l++) {
                                combinations.push([ruleIds[i], ruleIds[j], ruleIds[k], ruleIds[l]]);
                            }
                        }
                    }
                }
            }
            
            // All rules together
            if (ruleIds.length > 1) {
                combinations.push(ruleIds);
            }
            
            // Calculate stats for each combination
            const results = combinations.map(combo => {
                // Find trades that have ALL rules in this combination
                const matchingTrades = customTrades.filter(trade => {
                    return combo.every(ruleId => trade.rulesFollowed.includes(ruleId));
                });
                
                if (matchingTrades.length === 0) {
                    return null; // Skip combinations with no trades
                }
                
                const wins = matchingTrades.filter(t => parseFloat(t.netPL || 0) > 0).length;
                const losses = matchingTrades.filter(t => parseFloat(t.netPL || 0) < 0).length;
                const totalPL = matchingTrades.reduce((sum, t) => sum + (parseFloat(t.netPL) || 0), 0);
                const winRate = matchingTrades.length > 0 ? (wins / matchingTrades.length) * 100 : 0;
                
                const avgWin = wins > 0 ? matchingTrades
                    .filter(t => parseFloat(t.netPL || 0) > 0)
                    .reduce((sum, t) => sum + parseFloat(t.netPL), 0) / wins : 0;
                
                const avgLoss = losses > 0 ? matchingTrades
                    .filter(t => parseFloat(t.netPL || 0) < 0)
                    .reduce((sum, t) => sum + parseFloat(t.netPL), 0) / losses : 0;
                
                const profitFactor = losses > 0 && avgLoss < 0 ? 
                    (wins * avgWin) / (losses * Math.abs(avgLoss)) : 0;
                
                // Get rule names
                const ruleNames = combo.map(ruleId => {
                    const rule = appState.customRules.find(r => r.id === ruleId);
                    return rule ? rule.text : 'Unknown';
                });
                
                return {
                    combo: combo,
                    ruleNames: ruleNames,
                    displayName: ruleNames.join(' + '),
                    totalTrades: matchingTrades.length,
                    wins: wins,
                    losses: losses,
                    winRate: winRate,
                    totalPL: totalPL,
                    avgWin: avgWin,
                    avgLoss: avgLoss,
                    profitFactor: profitFactor,
                    expectancy: (winRate / 100 * avgWin) + ((1 - winRate / 100) * avgLoss)
                };
            }).filter(r => r !== null); // Remove null results
            
            // Sort by win rate (descending), then by total P/L
            return results.sort((a, b) => {
                if (Math.abs(b.winRate - a.winRate) > 1) {
                    return b.winRate - a.winRate;
                }
                return b.totalPL - a.totalPL;
            });
        }
        
        function toggleRuleCombinations() {
            appState.showRuleCombinations = !appState.showRuleCombinations;
            updateRuleCombinationsDisplay();
        }
        
        function updateRuleCombinationsDisplay() {
            const content = document.getElementById('ruleCombinationsContent');
            const toggleButton = document.getElementById('ruleCombinationsToggle');

            if (appState.showRuleCombinations) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        // Toggle functions for collapsible sections
        function toggleStatistics() {
            appState.showStatistics = !appState.showStatistics;
            const content = document.querySelector('#statisticsSection .section-content');
            const toggleButton = document.getElementById('statisticsToggle');
            if (appState.showStatistics) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        function toggleCharts() {
            appState.showCharts = !appState.showCharts;
            const content = document.querySelector('#chartsSection .section-content');
            const toggleButton = document.getElementById('chartsToggle');
            if (appState.showCharts) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        function toggleRules() {
            appState.showRules = !appState.showRules;
            const content = document.querySelector('#rulesSection .section-content');
            const toggleButton = document.getElementById('rulesToggle');
            if (appState.showRules) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        function toggleBreakdowns() {
            appState.showBreakdowns = !appState.showBreakdowns;
            const content = document.querySelector('#breakdownsSection .section-content');
            const toggleButton = document.getElementById('breakdownsToggle');
            if (appState.showBreakdowns) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        function toggleTimeAnalytics() {
            appState.showTimeAnalytics = !appState.showTimeAnalytics;
            const content = document.querySelector('#timeAnalyticsSection .section-content');
            const toggleButton = document.getElementById('timeAnalyticsToggle');
            if (appState.showTimeAnalytics) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        function toggleCalendar() {
            appState.showCalendar = !appState.showCalendar;
            const content = document.querySelector('#calendarSection .section-content');
            const toggleButton = document.getElementById('calendarToggle');
            if (appState.showCalendar) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        function toggleAI() {
            appState.showAI = !appState.showAI;
            const content = document.querySelector('#aiSection .section-content');
            const toggleButton = document.getElementById('aiToggle');
            if (appState.showAI) {
                content.style.display = 'block';
                toggleButton.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggleButton.textContent = '▶';
            }
        }

        // Performance Breakdowns
        function updatePerformanceBreakdowns() {
            updateBreakdownMonthDisplay();
            updateSetupBreakdown();
            updateMarketBreakdown();
            updateEmotionalBreakdown();
            updateRuleBreakdown();
        }
        
        function updateSetupBreakdown() {
            const container = document.getElementById('setupBreakdown');
            const breakdowns = {};

            // Filter trades by selected month/year
            let filteredTrades = appState.trades;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });
            }

            setupTypes.forEach(setup => {
                const trades = filteredTrades.filter(t => t.setupType === setup);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                breakdowns[setup] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            container.innerHTML = Object.entries(breakdowns).map(([setup, data]) => `
                <div class="breakdown-item">
                    <div class="breakdown-header">${setup}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');
        }
        
        function updateMarketBreakdown() {
            const container = document.getElementById('marketBreakdown');
            const breakdowns = {};

            // Filter trades by selected month/year
            let filteredTrades = appState.trades;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });
            }

            marketConditions.forEach(condition => {
                const trades = filteredTrades.filter(t => t.marketCondition === condition);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                breakdowns[condition] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            container.innerHTML = Object.entries(breakdowns).map(([condition, data]) => `
                <div class="breakdown-item">
                    <div class="breakdown-header">${condition}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');
        }
        
        function updateEmotionalBreakdown() {
            const container = document.getElementById('emotionalBreakdown');
            const breakdowns = {};

            // Filter trades by selected month/year
            let filteredTrades = appState.trades;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });
            }

            emotionalStates.forEach(state => {
                const trades = filteredTrades.filter(t => t.emotionalState === state);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                breakdowns[state] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            container.innerHTML = Object.entries(breakdowns).map(([state, data]) => `
                <div class="breakdown-item">
                    <div class="breakdown-header">${state}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');
        }
        
        function updateRuleBreakdown() {
            const container = document.getElementById('ruleBreakdown');
            const breakdowns = {};

            // Filter trades by selected month/year
            let filteredTrades = appState.trades;
            if (appState.breakdownCurrentMonth !== -1) {
                const selectedMonthKey = `${appState.breakdownCurrentYear}-${String(appState.breakdownCurrentMonth + 1).padStart(2, '0')}`;
                filteredTrades = appState.trades.filter(trade => {
                    const tradeDate = new Date(trade.date);
                    const tradeMonthKey = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;
                    return tradeMonthKey === selectedMonthKey;
                });
            }

            ruleAdherence.forEach(adherence => {
                const trades = filteredTrades.filter(t => t.ruleAdherence === adherence);
                const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                breakdowns[adherence] = {
                    trades: trades.length,
                    winRate: trades.length > 0 ? (wins.length / trades.length * 100) : 0,
                    totalPL: totalPL
                };
            });

            container.innerHTML = Object.entries(breakdowns).map(([adherence, data]) => `
                <div class="breakdown-item">
                    <div class="breakdown-header">${adherence}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: <span class="${data.winRate >= 50 ? 'positive' : 'negative'}">${data.winRate.toFixed(1)}%</span><br>
                        P&L: <span class="${data.totalPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.totalPL)}</span>
                    </div>
                </div>
            `).join('');
        }
        
        // Time Analytics
        function updateTimeAnalytics() {
            updateMonthlyStats();
            updateDailyStats();
            updateOpenHourlyStats();
            updateHourlyStats();
        }
        
        function updateMonthlyStats() {
            const container = document.getElementById('monthlyStats');
            const monthlyData = {};

            // Aggregate trades by month
            appState.trades.forEach(trade => {
                const month = trade.date.substring(0, 7); // YYYY-MM
                if (!monthlyData[month]) {
                    monthlyData[month] = {
                        trades: [],
                        wins: [],
                        losses: []
                    };
                }

                const pl = (trade.netPL || trade.profit);
                monthlyData[month].trades.push(trade);

                if (pl > 0) {
                    monthlyData[month].wins.push(trade);
                } else if (pl < 0) {
                    monthlyData[month].losses.push(trade);
                }
            });

            // Calculate detailed statistics for each month
            const monthlyStats = Object.entries(monthlyData).map(([month, data]) => {
                const totalTrades = data.trades.length;
                const winCount = data.wins.length;
                const lossCount = data.losses.length;
                const winRate = totalTrades > 0 ? (winCount / totalTrades * 100) : 0;

                const totalProfit = data.wins.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                const totalLoss = Math.abs(data.losses.reduce((sum, t) => sum + (t.netPL || t.profit), 0));
                const netPL = data.trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);

                const avgWin = winCount > 0 ? (totalProfit / winCount) : 0;
                const avgLoss = lossCount > 0 ? (totalLoss / lossCount) : 0;
                const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss) : 0;
                const riskRewardRatio = avgLoss > 0 ? (avgWin / avgLoss) : 0;

                // Calculate max drawdown for the month
                const sortedTrades = [...data.trades].sort((a, b) => {
                    const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                    const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                    return dateA - dateB;
                });

                let runningPL = 0;
                let peak = 0;
                let maxDrawdown = 0;

                sortedTrades.forEach(trade => {
                    const tradePL = parseFloat(trade.netPL) || parseFloat(trade.profit) || 0;
                    runningPL += tradePL;

                    if (runningPL > peak) {
                        peak = runningPL;
                    }

                    const drawdown = peak - runningPL;
                    if (drawdown > maxDrawdown) {
                        maxDrawdown = drawdown;
                    }
                });

                return {
                    month,
                    totalTrades,
                    winCount,
                    lossCount,
                    winRate,
                    netPL,
                    totalProfit,
                    totalLoss,
                    avgWin,
                    avgLoss,
                    profitFactor,
                    riskRewardRatio,
                    maxDrawdown
                };
            });

            // Calculate TOTAL statistics
            const allTrades = appState.trades;
            const allWins = allTrades.filter(t => (t.netPL || t.profit) > 0);
            const allLosses = allTrades.filter(t => (t.netPL || t.profit) < 0);

            const totalStats = {
                month: 'TOTAL',
                totalTrades: allTrades.length,
                winCount: allWins.length,
                lossCount: allLosses.length,
                winRate: allTrades.length > 0 ? (allWins.length / allTrades.length * 100) : 0,
                netPL: allTrades.reduce((sum, t) => sum + (t.netPL || t.profit), 0),
                totalProfit: allWins.reduce((sum, t) => sum + (t.netPL || t.profit), 0),
                totalLoss: Math.abs(allLosses.reduce((sum, t) => sum + (t.netPL || t.profit), 0)),
                avgWin: allWins.length > 0 ? (allWins.reduce((sum, t) => sum + (t.netPL || t.profit), 0) / allWins.length) : 0,
                avgLoss: allLosses.length > 0 ? (Math.abs(allLosses.reduce((sum, t) => sum + (t.netPL || t.profit), 0)) / allLosses.length) : 0,
                profitFactor: 0,
                riskRewardRatio: 0,
                maxDrawdown: appState.statistics?.maxDrawdown || 0
            };

            totalStats.profitFactor = totalStats.totalLoss > 0 ? (totalStats.totalProfit / totalStats.totalLoss) : 0;
            totalStats.riskRewardRatio = totalStats.avgLoss > 0 ? (totalStats.avgWin / totalStats.avgLoss) : 0;

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Filter to show only the selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const selectedMonthStats = monthlyStats.find(stats => stats.month === selectedMonthKey);

            // Render the monthly stats with TOTAL at the top
            const renderMonthCard = (stats, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.2em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL (All Time)' : stats.month}</div>
                    <div class="breakdown-stats" style="font-size: 0.9em;">
                        <strong>Trades:</strong> ${stats.totalTrades} (${stats.winCount}W / ${stats.lossCount}L)<br>
                        <strong>Win Rate:</strong> ${stats.winRate.toFixed(1)}%<br>
                        <strong>Net P&L:</strong> <span class="${stats.netPL >= 0 ? 'positive' : 'negative'}">${formatCurrency(stats.netPL)}</span><br>
                        <strong>Profit Factor:</strong> ${stats.profitFactor.toFixed(2)}<br>
                        <strong>Avg Win:</strong> <span class="positive">${formatCurrency(stats.avgWin)}</span><br>
                        <strong>Avg Loss:</strong> <span class="negative">${formatCurrency(stats.avgLoss)}</span><br>
                        <strong>R:R Ratio:</strong> ${stats.riskRewardRatio.toFixed(2)}<br>
                        <strong>Max DD:</strong> <span class="negative">${formatCurrency(stats.maxDrawdown)}</span>
                    </div>
                </div>
            `;

            container.innerHTML = `
                <div class="breakdown-grid">
                    ${renderMonthCard(totalStats, true)}
                    ${selectedMonthStats ? renderMonthCard(selectedMonthStats, false) : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
                </div>
            `;
        }
        
        function updateDailyStats() {
            const container = document.getElementById('dailyStats');
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Calculate TOTAL (all trades)
            const totalDailyData = {};
            daysOfWeek.forEach(day => {
                totalDailyData[day] = { trades: 0, profit: 0, wins: 0 };
            });

            appState.trades.forEach(trade => {
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const dayOfWeek = daysOfWeek[tradeDate.getDay()];
                totalDailyData[dayOfWeek].trades++;
                totalDailyData[dayOfWeek].profit += (trade.netPL || trade.profit);
                if ((trade.netPL || trade.profit) > 0) totalDailyData[dayOfWeek].wins++;
            });

            // Filter trades for selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const monthlyDailyData = {};
            daysOfWeek.forEach(day => {
                monthlyDailyData[day] = { trades: 0, profit: 0, wins: 0 };
            });

            appState.trades.forEach(trade => {
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const tradeMonth = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;

                if (tradeMonth === selectedMonthKey) {
                    const dayOfWeek = daysOfWeek[tradeDate.getDay()];
                    monthlyDailyData[dayOfWeek].trades++;
                    monthlyDailyData[dayOfWeek].profit += (trade.netPL || trade.profit);
                    if ((trade.netPL || trade.profit) > 0) monthlyDailyData[dayOfWeek].wins++;
                }
            });

            // Render function
            const renderDayCard = (day, data, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.1em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL - ' : ''}${day}</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: ${data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(1) : '0.0'}%<br>
                        P&L: <span class="${data.profit >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.profit)}</span>
                    </div>
                </div>
            `;

            const hasMonthData = Object.values(monthlyDailyData).some(d => d.trades > 0);

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${daysOfWeek.map(day => renderDayCard(day, totalDailyData[day], true)).join('')}
                    </div>
                </div>
                ${hasMonthData ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${daysOfWeek.map(day => renderDayCard(day, monthlyDailyData[day], false)).join('')}
                        </div>
                    </div>
                ` : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
            `;
        }

        function updateOpenHourlyStats() {
            const container = document.getElementById('openHourlyStats');

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Calculate TOTAL (all trades)
            const totalHourlyData = {};
            for (let i = 0; i < 24; i++) {
                totalHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                if (trade.openTime) {
                    const hour = parseInt(trade.openTime.split(':')[0]);
                    totalHourlyData[hour].trades++;
                    totalHourlyData[hour].profit += (trade.netPL || trade.profit);
                    if ((trade.netPL || trade.profit) > 0) totalHourlyData[hour].wins++;
                }
            });

            // Filter trades for selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const monthlyHourlyData = {};
            for (let i = 0; i < 24; i++) {
                monthlyHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                if (trade.openTime) {
                    const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                    const tradeMonth = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;

                    if (tradeMonth === selectedMonthKey) {
                        const hour = parseInt(trade.openTime.split(':')[0]);
                        monthlyHourlyData[hour].trades++;
                        monthlyHourlyData[hour].profit += (trade.netPL || trade.profit);
                        if ((trade.netPL || trade.profit) > 0) monthlyHourlyData[hour].wins++;
                    }
                }
            });

            // Render function
            const renderHourCard = (hour, data, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.1em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL - ' : ''}${hour}:00</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: ${data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(1) : '0.0'}%<br>
                        P&L: <span class="${data.profit >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.profit)}</span>
                    </div>
                </div>
            `;

            // Only show hours with trades
            const activeTotalHours = Object.entries(totalHourlyData).filter(([hour, data]) => data.trades > 0);
            const activeMonthHours = Object.entries(monthlyHourlyData).filter(([hour, data]) => data.trades > 0);

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${activeTotalHours.map(([hour, data]) => renderHourCard(hour, data, true)).join('')}
                    </div>
                </div>
                ${activeMonthHours.length > 0 ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${activeMonthHours.map(([hour, data]) => renderHourCard(hour, data, false)).join('')}
                        </div>
                    </div>
                ` : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
            `;
        }

        function updateHourlyStats() {
            const container = document.getElementById('hourlyStats');

            // Update the month display
            updateAnalyticsMonthDisplay();

            // Calculate TOTAL (all trades)
            const totalHourlyData = {};
            for (let i = 0; i < 24; i++) {
                totalHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                const hour = parseInt(trade.time.split(':')[0]);
                totalHourlyData[hour].trades++;
                totalHourlyData[hour].profit += (trade.netPL || trade.profit);
                if ((trade.netPL || trade.profit) > 0) totalHourlyData[hour].wins++;
            });

            // Filter trades for selected month
            const selectedMonthKey = `${appState.analyticsCurrentYear}-${String(appState.analyticsCurrentMonth + 1).padStart(2, '0')}`;
            const monthlyHourlyData = {};
            for (let i = 0; i < 24; i++) {
                monthlyHourlyData[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const tradeMonth = `${tradeDate.getFullYear()}-${String(tradeDate.getMonth() + 1).padStart(2, '0')}`;

                if (tradeMonth === selectedMonthKey) {
                    const hour = parseInt(trade.time.split(':')[0]);
                    monthlyHourlyData[hour].trades++;
                    monthlyHourlyData[hour].profit += (trade.netPL || trade.profit);
                    if ((trade.netPL || trade.profit) > 0) monthlyHourlyData[hour].wins++;
                }
            });

            // Render function
            const renderHourCard = (hour, data, isTotal = false) => `
                <div class="breakdown-item ${isTotal ? 'total-row' : ''}" style="${isTotal ? 'background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 100%); border: 2px solid #4a9eff; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);' : ''}">
                    <div class="breakdown-header" style="${isTotal ? 'font-size: 1.1em; font-weight: bold; color: #4a9eff;' : ''}">${isTotal ? 'TOTAL - ' : ''}${hour}:00</div>
                    <div class="breakdown-stats">
                        Trades: ${data.trades}<br>
                        Win Rate: ${data.trades > 0 ? ((data.wins / data.trades) * 100).toFixed(1) : '0.0'}%<br>
                        P&L: <span class="${data.profit >= 0 ? 'positive' : 'negative'}">${formatCurrency(data.profit)}</span>
                    </div>
                </div>
            `;

            // Only show hours with trades
            const activeTotalHours = Object.entries(totalHourlyData).filter(([hour, data]) => data.trades > 0);
            const activeMonthHours = Object.entries(monthlyHourlyData).filter(([hour, data]) => data.trades > 0);

            container.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #4a9eff; margin-bottom: 0.75rem;">TOTAL (All Time)</h4>
                    <div class="breakdown-grid">
                        ${activeTotalHours.map(([hour, data]) => renderHourCard(hour, data, true)).join('')}
                    </div>
                </div>
                ${activeMonthHours.length > 0 ? `
                    <div>
                        <h4 style="color: var(--color-text-secondary); margin-bottom: 0.75rem;">Selected Month</h4>
                        <div class="breakdown-grid">
                            ${activeMonthHours.map(([hour, data]) => renderHourCard(hour, data, false)).join('')}
                        </div>
                    </div>
                ` : '<div style="padding: 2rem; text-align: center; color: var(--color-text-secondary);">No data for this month</div>'}
            `;
        }
        
        // Calendar View
        function updateCalendarView() {
            updateCalendarMonth();
            renderCalendar();
        }
        
        function updateCalendarMonth() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            document.getElementById('calendarMonth').textContent = 
                `${monthNames[appState.currentMonth]} ${appState.currentYear}`;
        }
        
        // CORRECTED: Calendar generation with proper date alignment
        function generateCalendar(year, month, trades) {
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            
            // Create array with empty cells for alignment
            const calendar = Array(firstDay).fill(null);
            
            // Add days with trade data
            for (let day = 1; day <= daysInMonth; day++) {
                const dayTrades = trades.filter(t => {
                    const tradeDate = new Date(t.closeTime || `${t.date}T${t.time}:00`);
                    return tradeDate.getDate() === day && 
                           tradeDate.getMonth() === month &&
                           tradeDate.getFullYear() === year;
                });
                
                const dayPL = dayTrades.reduce((sum, t) => sum + (parseFloat(t.netPL) || parseFloat(t.profit) || 0), 0);
                
                calendar.push({
                    day: day,
                    trades: dayTrades.length,
                    pl: dayPL,
                    color: dayPL > 0 ? 'profit' : dayPL < 0 ? 'loss' : 'neutral'
                });
            }
            
            return calendar;
        }
        
        function renderCalendar() {
            const calendar = document.getElementById('calendar');

            if (!calendar) {
                console.warn('Calendar element not found');
                return;
            }

            const firstDay = new Date(appState.currentYear, appState.currentMonth, 1).getDay();
            const daysInMonth = new Date(appState.currentYear, appState.currentMonth + 1, 0).getDate();

            // Initialize monthly totals
            let monthTotalWins = 0;
            let monthTotalLosses = 0;
            let monthTotalPL = 0;

            // Group trades by date
            const monthlyTrades = {};
            appState.trades.forEach(trade => {
                try {
                    const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                    if (tradeDate.getMonth() === appState.currentMonth && tradeDate.getFullYear() === appState.currentYear) {
                        const day = tradeDate.getDate();
                        const pl = (parseFloat(trade.netPL) || parseFloat(trade.profit) || 0);

                        if (!monthlyTrades[day]) {
                            monthlyTrades[day] = { count: 0, profit: 0, wins: 0, losses: 0 };
                        }
                        monthlyTrades[day].count++;
                        monthlyTrades[day].profit += pl;

                        if (pl > 0) {
                            monthlyTrades[day].wins++;
                            monthTotalWins++;
                        } else if (pl < 0) {
                            monthlyTrades[day].losses++;
                            monthTotalLosses++;
                        }

                        monthTotalPL += pl;
                    }
                } catch (error) {
                    console.warn('Error processing trade date for calendar:', error, trade);
                }
            });

            let html = '';

            // Add day headers with week stats header
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Week'];
            dayHeaders.forEach(day => {
                html += `<div style="text-align: center; font-weight: bold; padding: 0.5rem; color: #94a3b8;">${day}</div>`;
            });

            // Track current week stats
            let weekWins = 0;
            let weekLosses = 0;
            let weekPL = 0;

            // Add empty cells for days before month start
            for (let i = 0; i < firstDay; i++) {
                html += '<div class="calendar-day"></div>';
            }

            // Add days of month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayData = monthlyTrades[day];
                let className = 'calendar-day';
                let title = `${day}`;
                let content = day.toString();

                if (dayData) {
                    className += ' has-trades';
                    className += dayData.profit >= 0 ? ' profit' : ' loss';
                    title = `${day} - ${dayData.wins}W/${dayData.losses}L (${dayData.count} trade${dayData.count > 1 ? 's' : ''}), P&L: ${formatCurrency(dayData.profit)}`;
                    content += `<br><small style="font-size: 10px; line-height: 1.2;">${dayData.wins}W/${dayData.losses}L<br>${formatCurrency(dayData.profit)}</small>`;

                    // Add to week totals
                    weekWins += dayData.wins;
                    weekLosses += dayData.losses;
                    weekPL += dayData.profit;
                }

                html += `<div class="${className}" title="${title}">${content}</div>`;

                // Calculate current day of week (0=Sun, 6=Sat)
                const currentDayOfWeek = (firstDay + day - 1) % 7;

                // End of week (Saturday = 6) or end of month
                if (currentDayOfWeek === 6 || day === daysInMonth) {
                    // If it's end of month but not Saturday, fill remaining days
                    if (day === daysInMonth && currentDayOfWeek !== 6) {
                        const remainingInWeek = 6 - currentDayOfWeek;
                        for (let i = 0; i < remainingInWeek; i++) {
                            html += '<div class="calendar-day"></div>';
                        }
                    }

                    // Add weekly summary - CENTERED
                    const weekColor = weekPL >= 0 ? 'var(--color-success)' : 'var(--color-error)';
                    const weekBgColor = weekPL > 0 ? 'rgba(16, 185, 129, 0.2)' : weekPL < 0 ? 'rgba(239, 68, 68, 0.2)' : 'transparent';
                    const weekTextColor = weekPL > 0 ? '#10b981' : weekPL < 0 ? '#ef4444' : '#94a3b8';
                    html += `
                        <div style="aspect-ratio: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 4px; font-size: 0.75rem; position: relative; min-height: 40px; border: 1px solid transparent; background: ${weekBgColor}; color: ${weekTextColor}; text-align: center; padding: 0.5rem;">
                            <div style="font-weight: bold;">${weekWins}W/${weekLosses}L</div>
                            <div style="font-weight: bold; margin-top: 2px;">${formatCurrency(weekPL)}</div>
                        </div>
                    `;

                    // Reset week counters
                    weekWins = 0;
                    weekLosses = 0;
                    weekPL = 0;
                }
            }

            // Add monthly summary
            const monthTotalTrades = monthTotalWins + monthTotalLosses;
            const monthWinRate = monthTotalTrades > 0 ? ((monthTotalWins / monthTotalTrades) * 100).toFixed(1) : '0.0';

            html += `
                <div style="grid-column: 1 / -1; margin-top: 1rem; padding: 1rem; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); text-align: center;">
                    <div style="font-weight: var(--font-weight-semibold); margin-bottom: 0.5rem; font-size: var(--font-size-md);">Month Total</div>
                    <div style="display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">W/L</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold);">
                                <span style="color: var(--color-success);">${monthTotalWins}W</span> / <span style="color: var(--color-error);">${monthTotalLosses}L</span>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">P&L</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold); color: ${monthTotalPL >= 0 ? 'var(--color-success)' : 'var(--color-error)'};">
                                ${formatCurrency(monthTotalPL)}
                            </div>
                        </div>
                        <div>
                            <div style="font-size: var(--font-size-xs); color: var(--color-text-secondary);">Win Rate</div>
                            <div style="font-size: var(--font-size-lg); font-weight: var(--font-weight-bold);">
                                ${monthWinRate}%
                            </div>
                        </div>
                    </div>
                </div>
            `;

            calendar.innerHTML = html;
        }
        function changeMonth(direction) {
            appState.currentMonth += direction;
            if (appState.currentMonth < 0) {
                appState.currentMonth = 11;
                appState.currentYear--;
            } else if (appState.currentMonth > 11) {
                appState.currentMonth = 0;
                appState.currentYear++;
            }
            updateCalendarView();
        }

        // Monthly Analytics Navigation
        function changeAnalyticsMonth(direction) {
            // If currently at TOTAL (-1) and going forward, go to the first month with trades
            // If going backward from TOTAL, stay at TOTAL
            if (appState.analyticsCurrentMonth === -1) {
                if (direction > 0) {
                    // Find the first month with trades
                    const firstTradeDate = appState.trades.length > 0
                        ? new Date(appState.trades.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date)
                        : new Date();
                    appState.analyticsCurrentMonth = firstTradeDate.getMonth();
                    appState.analyticsCurrentYear = firstTradeDate.getFullYear();
                } else {
                    // Stay at TOTAL when going backward
                    return;
                }
            } else {
                appState.analyticsCurrentMonth += direction;
                if (appState.analyticsCurrentMonth < 0) {
                    appState.analyticsCurrentMonth = 11;
                    appState.analyticsCurrentYear--;
                } else if (appState.analyticsCurrentMonth > 11) {
                    appState.analyticsCurrentMonth = 0;
                    appState.analyticsCurrentYear++;
                }
            }
            updateAnalyticsMonthDisplay();
            updateMonthlyStats();
            updateDailyStats();
            updateOpenHourlyStats();
            updateHourlyStats();
            updateStatisticsDisplay();
        }

        function resetToTotalView() {
            appState.analyticsCurrentMonth = -1;
            appState.analyticsCurrentYear = new Date().getFullYear();
            updateAnalyticsMonthDisplay();
            updateMonthlyStats();
            updateDailyStats();
            updateOpenHourlyStats();
            updateHourlyStats();
            updateStatisticsDisplay();
        }

        function updateAnalyticsMonthDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const displayText = appState.analyticsCurrentMonth === -1
                ? 'TOTAL (All Time)'
                : `${monthNames[appState.analyticsCurrentMonth]} ${appState.analyticsCurrentYear}`;

            // Update all analytics month displays
            const displayElements = [
                'analyticsMonthDisplay',
                'analyticsDailyMonthDisplay',
                'analyticsOpenHourlyMonthDisplay',
                'analyticsCloseHourlyMonthDisplay',
                'analyticsStatsMonthDisplay'
            ];

            displayElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = displayText;
                }
            });
        }

        // Rule Combinations Navigation
        function changeRuleCombinationsMonth(direction) {
            // If currently at TOTAL (-1) and going forward, go to the first month with trades
            // If going backward from TOTAL, stay at TOTAL
            if (appState.ruleCombinationsCurrentMonth === -1) {
                if (direction > 0) {
                    // Find the first month with trades
                    const firstTradeDate = appState.trades.length > 0
                        ? new Date(appState.trades.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date)
                        : new Date();
                    appState.ruleCombinationsCurrentMonth = firstTradeDate.getMonth();
                    appState.ruleCombinationsCurrentYear = firstTradeDate.getFullYear();
                } else {
                    // Stay at TOTAL when going backward
                    return;
                }
            } else {
                appState.ruleCombinationsCurrentMonth += direction;
                if (appState.ruleCombinationsCurrentMonth < 0) {
                    appState.ruleCombinationsCurrentMonth = 11;
                    appState.ruleCombinationsCurrentYear--;
                } else if (appState.ruleCombinationsCurrentMonth > 11) {
                    appState.ruleCombinationsCurrentMonth = 0;
                    appState.ruleCombinationsCurrentYear++;
                }
            }
            updateRuleCombinationsMonthDisplay();
            updateRuleCombinationsAnalysis();
        }

        function resetRuleCombinationsToTotalView() {
            appState.ruleCombinationsCurrentMonth = -1;
            appState.ruleCombinationsCurrentYear = new Date().getFullYear();
            updateRuleCombinationsMonthDisplay();
            updateRuleCombinationsAnalysis();
        }

        function updateRuleCombinationsMonthDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const displayText = appState.ruleCombinationsCurrentMonth === -1
                ? 'TOTAL (All Time)'
                : `${monthNames[appState.ruleCombinationsCurrentMonth]} ${appState.ruleCombinationsCurrentYear}`;

            const element = document.getElementById('ruleCombinationsMonthDisplay');
            if (element) {
                element.textContent = displayText;
            }
        }

        // Performance Breakdowns Navigation
        function changeBreakdownMonth(direction) {
            // If currently at TOTAL (-1) and going forward, go to the first month with trades
            // If going backward from TOTAL, stay at TOTAL
            if (appState.breakdownCurrentMonth === -1) {
                if (direction > 0) {
                    // Find the first month with trades
                    const firstTradeDate = appState.trades.length > 0
                        ? new Date(appState.trades.sort((a, b) => new Date(a.date) - new Date(b.date))[0].date)
                        : new Date();
                    appState.breakdownCurrentMonth = firstTradeDate.getMonth();
                    appState.breakdownCurrentYear = firstTradeDate.getFullYear();
                } else {
                    // Stay at TOTAL when going backward
                    return;
                }
            } else {
                appState.breakdownCurrentMonth += direction;
                if (appState.breakdownCurrentMonth < 0) {
                    appState.breakdownCurrentMonth = 11;
                    appState.breakdownCurrentYear--;
                } else if (appState.breakdownCurrentMonth > 11) {
                    appState.breakdownCurrentMonth = 0;
                    appState.breakdownCurrentYear++;
                }
            }
            updateBreakdownMonthDisplay();
            updateBreakdownDisplays();
        }

        function updateBreakdownMonthDisplay() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const displayText = appState.breakdownCurrentMonth === -1
                ? 'TOTAL (All Time)'
                : `${monthNames[appState.breakdownCurrentMonth]} ${appState.breakdownCurrentYear}`;

            // Update all breakdown month displays
            const displayElements = [
                'breakdownSetupMonthDisplay',
                'breakdownMarketMonthDisplay',
                'breakdownEmotionalMonthDisplay',
                'breakdownRuleMonthDisplay'
            ];

            displayElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = displayText;
                }
            });
        }

        function updateBreakdownDisplays() {
            updateBreakdownMonthDisplay();
            updateSetupBreakdown();
            updateMarketBreakdown();
            updateEmotionalBreakdown();
            updateRuleBreakdown();
        }

        // AI Analysis Functions
        function updateAiPromptInclusion(key, value) {
            appState.aiPromptInclusions[key] = value;
            if (key === 'tradesOption') {
                updateTradesOptionHelper();
            }
        }
        
        function updateTradesOptionHelper() {
            const option = appState.aiPromptInclusions.tradesOption;
            const helper = document.getElementById('tradesOptionHelper');
            
            // Safety check for trades array
            if (!appState.trades || !Array.isArray(appState.trades)) {
                if (helper) {
                    helper.textContent = '';
                }
                return;
            }
            
            const totalTrades = appState.trades.length;
            const winningTrades = appState.trades.filter(t => (t.netPL || t.profit) > 0).length;
            const losingTrades = appState.trades.filter(t => (t.netPL || t.profit) < 0).length;
            
            let text = '';
            switch(option) {
                case 'all':
                    text = `⚠️ Including all ${totalTrades} trades may create a very long prompt`;
                    break;
                case 'winning':
                    text = `Including ${winningTrades} winning trades`;
                    break;
                case 'losing':
                    text = `Including ${losingTrades} losing trades`;
                    break;
                case 'bestWorst':
                    text = `Including best 5 and worst 5 trades (10 total)`;
                    break;
                case 'recent10':
                case 'recent20':
                case 'recent50':
                    const count = parseInt(option.replace('recent', ''));
                    const actualCount = Math.min(count, totalTrades);
                    text = `Including ${actualCount} most recent trades`;
                    break;
                case 'none':
                default:
                    text = '';
            }
            
            if (helper) {
                helper.textContent = text;
            }
        }
        
        function generateAIAnalysisPrompt() {
            if (!appState.statistics || !appState.statistics.totalTrades) {
                showMessage('No trading data available for analysis', 'error');
                return;
            }
            
            const prompt = buildAnalysisPrompt();
            document.getElementById('promptText').value = prompt;
            document.getElementById('analysisPrompt').style.display = 'block';
            document.getElementById('copyPromptBtn').disabled = false;
        }
        
        function buildAnalysisPrompt() {
            const inclusions = appState.aiPromptInclusions;
            const format = appState.exportPromptFormat;
            const stats = appState.statistics;
            
            // Gather analysis data based on selections
            const analysisData = {};
            
            // Only include sections that are checked
            if (inclusions.overview) {
                analysisData.overview = {
                    totalTrades: stats.totalTrades,
                    winRate: stats.winRate,
                    profitFactor: stats.profitFactor,
                    netPL: stats.netPL,
                    expectancy: stats.expectancy,
                    avgWin: stats.avgWin,
                    avgLoss: stats.avgLoss,
                    accountGrowth: stats.accountGrowth,
                    startingBalance: stats.startingBalance,
                    currentBalance: stats.currentBalance
                };
            }
            
            if (inclusions.setupPerformance) {
                const setupPerf = calculateSetupPerformance();
                if (Object.keys(setupPerf).length > 0) {
                    analysisData.setupPerformance = setupPerf;
                }
            }
            
            if (inclusions.marketCondition) {
                const marketPerf = calculateMarketConditionPerformance();
                if (Object.keys(marketPerf).length > 0) {
                    analysisData.marketConditionPerformance = marketPerf;
                }
            }
            
            if (inclusions.emotionalState) {
                const emotionalPerf = calculateEmotionalStatePerformance();
                if (Object.keys(emotionalPerf).length > 0) {
                    analysisData.emotionalStatePerformance = emotionalPerf;
                }
            }
            
            if (inclusions.ruleAdherence) {
                const rulePerf = calculateRuleAdherencePerformance();
                if (Object.keys(rulePerf).length > 0) {
                    analysisData.ruleAdherencePerformance = rulePerf;
                }
            }
            
            // Calculate time-based stats if any of the time-based options are selected
            if (inclusions.monthlyPerformance || inclusions.dailyPerformance ||
                inclusions.openHourlyPerformance || inclusions.closeHourlyPerformance) {
                const timeStats = calculateTimeBasedStats();

                if (inclusions.monthlyPerformance) {
                    analysisData.monthlyPerformance = timeStats.monthly;
                }

                if (inclusions.dailyPerformance) {
                    analysisData.dailyPerformance = timeStats.daily;
                }

                if (inclusions.openHourlyPerformance) {
                    analysisData.openHourlyPerformance = timeStats.openHourly;
                }

                if (inclusions.closeHourlyPerformance) {
                    analysisData.closeHourlyPerformance = timeStats.closeHourly;
                }
            }
            
            if (inclusions.customRules && appState.customRules.length > 0) {
                analysisData.customRules = {
                    totalRules: appState.customRules.length,
                    rules: appState.customRules.map(r => r.text),
                    adherenceStats: calculateCustomRuleAdherence()
                };
            }
            
            // Include trades based on selection
            const tradesToInclude = getTradesForPrompt();
            if (tradesToInclude && tradesToInclude.length > 0) {
                analysisData.trades = {
                    count: tradesToInclude.length,
                    selection: inclusions.tradesOption,
                    data: tradesToInclude.map(t => ({
                        date: t.date,
                        time: t.time,
                        symbol: t.symbol,
                        direction: t.direction,
                        entryPrice: t.entryPrice,
                        exitPrice: t.exitPrice,
                        pips: t.pips,
                        grossPL: t.grossProfit || 0,
                        netPL: t.netPL || t.profit,
                        setupType: t.setupType || '—',
                        marketCondition: t.marketCondition || '—',
                        emotionalState: t.emotionalState || '—',
                        ruleAdherence: t.ruleAdherence || '—',
                        notes: t.notes || ''
                    }))
                };
            }
            
            // Generate prompt based on format and included sections
            if (format === 'readable') {
                return buildReadablePrompt(analysisData);
            } else {
                return buildJSONPrompt(analysisData);
            }
        }
        
        function buildReadablePrompt(data) {
            let prompt = "You are an expert trading coach. Please analyze my trading performance and provide actionable insights.\n\n";
            
            // Add Strategy Context if provided - FIRST
            if (appState.strategyContext && appState.strategyContext.trim()) {
                prompt += `📖 MY TRADING STRATEGY:\n${appState.strategyContext.trim()}\n\n`;
                prompt += `Please keep this strategy context in mind when analyzing my performance.\n\n`;
                prompt += "=".repeat(60) + "\n\n";
            }
            
            if (data.overview) {
                prompt += `📊 PERFORMANCE OVERVIEW:\n`;
                prompt += `• Total Trades: ${data.overview.totalTrades}\n`;
                prompt += `• Win Rate: ${data.overview.winRate.toFixed(1)}%\n`;
                prompt += `• Profit Factor: ${data.overview.profitFactor.toFixed(2)}\n`;
                prompt += `• Net P&L: ${formatCurrency(data.overview.netPL)}\n`;
                prompt += `• Expectancy: ${formatCurrency(data.overview.expectancy)}\n`;
                prompt += `• Average Win: ${formatCurrency(data.overview.avgWin)}\n`;
                prompt += `• Average Loss: ${formatCurrency(Math.abs(data.overview.avgLoss))}\n`;
                prompt += `• Account Growth: ${data.overview.accountGrowth.toFixed(1)}%\n\n`;
            }
            
            if (data.setupPerformance) {
                prompt += `🎯 SETUP TYPE PERFORMANCE:\n`;
                Object.entries(data.setupPerformance).forEach(([setup, perf]) => {
                    prompt += `• ${setup}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.marketConditionPerformance) {
                prompt += `🌊 MARKET CONDITION PERFORMANCE:\n`;
                Object.entries(data.marketConditionPerformance).forEach(([condition, perf]) => {
                    prompt += `• ${condition}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.emotionalStatePerformance) {
                prompt += `🧠 EMOTIONAL STATE PERFORMANCE:\n`;
                Object.entries(data.emotionalStatePerformance).forEach(([state, perf]) => {
                    prompt += `• ${state}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.ruleAdherencePerformance) {
                prompt += `📋 RULE ADHERENCE PERFORMANCE:\n`;
                Object.entries(data.ruleAdherencePerformance).forEach(([adherence, perf]) => {
                    prompt += `• ${adherence}: ${perf.trades} trades, ${perf.winRate.toFixed(1)}% win rate, ${formatCurrency(perf.totalPL)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.monthlyPerformance) {
                prompt += `📅 MONTHLY PERFORMANCE:\n`;
                Object.entries(data.monthlyPerformance).forEach(([month, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `• ${month}: ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }

            if (data.dailyPerformance) {
                prompt += `📆 DAILY PERFORMANCE (Day of Week):\n`;
                Object.entries(data.dailyPerformance).forEach(([day, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `• ${day}: ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }

            if (data.openHourlyPerformance) {
                prompt += `🕐 OPEN HOURLY PERFORMANCE:\n`;
                const activeOpenHours = Object.entries(data.openHourlyPerformance)
                    .filter(([hour, perf]) => perf.trades > 0)
                    .sort((a, b) => b[1].profit - a[1].profit);
                activeOpenHours.forEach(([hour, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `• ${hour}:00 - ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }

            if (data.closeHourlyPerformance) {
                prompt += `🕐 CLOSE HOURLY PERFORMANCE:\n`;
                const activeCloseHours = Object.entries(data.closeHourlyPerformance)
                    .filter(([hour, perf]) => perf.trades > 0)
                    .sort((a, b) => b[1].profit - a[1].profit);
                activeCloseHours.forEach(([hour, perf]) => {
                    const winRate = perf.trades > 0 ? (perf.wins / perf.trades * 100).toFixed(1) : '0.0';
                    prompt += `• ${hour}:00 - ${perf.trades} trades, ${winRate}% win rate, ${formatCurrency(perf.profit)} P&L\n`;
                });
                prompt += `\n`;
            }
            
            if (data.customRules) {
                prompt += `📏 CUSTOM TRADING RULES:\n`;
                prompt += `• Total Rules: ${data.customRules.totalRules}\n`;
                data.customRules.rules.forEach((rule, index) => {
                    prompt += `• Rule ${index + 1}: ${rule}\n`;
                });
                prompt += `\n`;
            }
            
            if (data.trades) {
                const selectionText = {
                    'recent10': 'Recent 10',
                    'recent20': 'Recent 20', 
                    'recent50': 'Recent 50',
                    'all': 'All',
                    'winning': 'Winning',
                    'losing': 'Losing',
                    'bestWorst': 'Best &amp; Worst'
                }[data.trades.selection] || 'Selected';
                
                prompt += `💼 INDIVIDUAL TRADES (${selectionText} - ${data.trades.count} trades):\n`;
                data.trades.data.forEach((trade, index) => {
                    prompt += `• ${trade.date} ${trade.time}: ${trade.symbol} ${trade.direction}, Entry: ${trade.entryPrice}, Exit: ${trade.exitPrice}, ${trade.pips} pips, ${formatCurrency(trade.netPL)} P&L`;
                    if (trade.setupType && trade.setupType !== '—') prompt += `, Setup: ${trade.setupType}`;
                    if (trade.emotionalState && trade.emotionalState !== '—') prompt += `, Emotion: ${trade.emotionalState}`;
                    if (trade.ruleAdherence && trade.ruleAdherence !== '—') prompt += `, Rules: ${trade.ruleAdherence}`;
                    if (trade.notes) prompt += `, Notes: ${trade.notes}`;
                    prompt += `\n`;
                });
                prompt += `\n`;
            }
            
            prompt += `PLEASE ANALYZE AND PROVIDE:\n`;
            prompt += `1. Overall performance assessment\n`;
            prompt += `2. Strengths and areas for improvement\n`;
            prompt += `3. Risk management evaluation\n`;
            prompt += `4. Specific recommendations for better results\n`;
            prompt += `5. Trading psychology insights\n`;
            
            return prompt;
        }
        
        function buildJSONPrompt(data) {
            const fullData = {
                strategyContext: appState.strategyContext || null,
                tradingData: data
            };
            
            let prompt = `Trading Strategy & Performance Data:\n\n`;
            prompt += JSON.stringify(fullData, null, 2);
            prompt += `\n\nPlease analyze this trading performance data`;
            if (appState.strategyContext) {
                prompt += ` in the context of the provided strategy`;
            }
            prompt += ` and provide insights.`;
            return prompt;
        }
        
        function copyAIPromptToClipboard() {
            const promptText = document.getElementById('promptText').value;
            if (!promptText.trim()) {
                showMessage('No prompt generated yet', 'error');
                return;
            }
            
            navigator.clipboard.writeText(promptText).then(() => {
                appState.showPromptCopied = true;
                document.getElementById('promptCopiedMessage').style.display = 'block';
                setTimeout(() => {
                    appState.showPromptCopied = false;
                    document.getElementById('promptCopiedMessage').style.display = 'none';
                }, 3000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.getElementById('promptText');
                textArea.select();
                textArea.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showMessage('Analysis prompt copied to clipboard');
            });
        }
        
        // Helper functions for performance calculations
        function calculateSetupPerformance() {
            const performance = {};
            setupTypes.forEach(setup => {
                const trades = appState.trades.filter(t => t.setupType === setup);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[setup] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function calculateMarketConditionPerformance() {
            const performance = {};
            marketConditions.forEach(condition => {
                const trades = appState.trades.filter(t => t.marketCondition === condition);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[condition] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function calculateEmotionalStatePerformance() {
            const performance = {};
            emotionalStates.forEach(state => {
                const trades = appState.trades.filter(t => t.emotionalState === state);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[state] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function calculateRuleAdherencePerformance() {
            const performance = {};
            ruleAdherence.forEach(adherence => {
                const trades = appState.trades.filter(t => t.ruleAdherence === adherence);
                if (trades.length > 0) {
                    const wins = trades.filter(t => (t.netPL || t.profit) > 0);
                    const totalPL = trades.reduce((sum, t) => sum + (t.netPL || t.profit), 0);
                    performance[adherence] = {
                        trades: trades.length,
                        winRate: (wins.length / trades.length * 100),
                        totalPL: totalPL
                    };
                }
            });
            return performance;
        }
        
        function getTradesForPrompt() {
            const option = appState.aiPromptInclusions.tradesOption;
            
            if (option === 'none') {
                return null;
            }
            
            // Sort trades by close time for recent selections
            const sortedTrades = [...appState.trades].sort((a, b) => {
                const dateA = new Date(a.closeTime || `${a.date}T${a.time}:00`);
                const dateB = new Date(b.closeTime || `${b.date}T${b.time}:00`);
                return dateB - dateA; // Most recent first
            });
            
            switch(option) {
                case 'recent10':
                    return sortedTrades.slice(0, 10);
                
                case 'recent20':
                    return sortedTrades.slice(0, 20);
                
                case 'recent50':
                    return sortedTrades.slice(0, 50);
                
                case 'all':
                    return sortedTrades;
                
                case 'winning':
                    return sortedTrades.filter(t => (parseFloat(t.netPL) || parseFloat(t.profit) || 0) > 0);
                
                case 'losing':
                    return sortedTrades.filter(t => (parseFloat(t.netPL) || parseFloat(t.profit) || 0) < 0);
                
                case 'bestWorst':
                    const sortedByPL = [...sortedTrades].sort((a, b) => 
                        (parseFloat(b.netPL) || parseFloat(b.profit) || 0) - (parseFloat(a.netPL) || parseFloat(a.profit) || 0)
                    );
                    const best5 = sortedByPL.slice(0, 5);
                    const worst5 = sortedByPL.slice(-5);
                    return [...best5, ...worst5];
                
                default:
                    return null;
            }
        }
        
        function calculateTimeBasedStats() {
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            // Monthly stats
            const monthlyStats = {};
            // Daily (day of week) stats
            const dailyStats = {};
            daysOfWeek.forEach(day => {
                dailyStats[day] = { trades: 0, profit: 0, wins: 0 };
            });
            // Open hourly stats
            const openHourlyStats = {};
            // Close hourly stats
            const closeHourlyStats = {};

            // Initialize hourly stats
            for (let i = 0; i < 24; i++) {
                openHourlyStats[i] = { trades: 0, profit: 0, wins: 0 };
                closeHourlyStats[i] = { trades: 0, profit: 0, wins: 0 };
            }

            appState.trades.forEach(trade => {
                const pl = trade.netPL || trade.profit;
                const isWin = pl > 0;

                // Monthly stats
                const month = trade.date.substring(0, 7); // YYYY-MM
                if (!monthlyStats[month]) {
                    monthlyStats[month] = { trades: 0, profit: 0, wins: 0 };
                }
                monthlyStats[month].trades++;
                monthlyStats[month].profit += pl;
                if (isWin) monthlyStats[month].wins++;

                // Daily (day of week) stats
                const tradeDate = new Date(trade.closeTime || `${trade.date}T${trade.time}:00`);
                const dayOfWeek = daysOfWeek[tradeDate.getDay()];
                dailyStats[dayOfWeek].trades++;
                dailyStats[dayOfWeek].profit += pl;
                if (isWin) dailyStats[dayOfWeek].wins++;

                // Open hourly stats
                if (trade.openTime) {
                    const openHour = parseInt(trade.openTime.split(':')[0]);
                    openHourlyStats[openHour].trades++;
                    openHourlyStats[openHour].profit += pl;
                    if (isWin) openHourlyStats[openHour].wins++;
                }

                // Close hourly stats
                const closeHour = parseInt(trade.time.split(':')[0]);
                closeHourlyStats[closeHour].trades++;
                closeHourlyStats[closeHour].profit += pl;
                if (isWin) closeHourlyStats[closeHour].wins++;
            });

            return {
                monthly: monthlyStats,
                daily: dailyStats,
                openHourly: openHourlyStats,
                closeHourly: closeHourlyStats
            };
        }
        
        function calculateCustomRuleAdherence() {
            const tradesWithRules = appState.trades.filter(t => t.rulesFollowed && t.rulesFollowed.length > 0);
            const rulesWins = tradesWithRules.filter(t => (t.netPL || t.profit) > 0);
            
            return {
                totalTradesWithRules: tradesWithRules.length,
                rulesWinRate: tradesWithRules.length > 0 ? (rulesWins.length / tradesWithRules.length * 100) : 0,
                averageRulesPerTrade: tradesWithRules.length > 0 ? tradesWithRules.reduce((sum, t) => sum + t.rulesFollowed.length, 0) / tradesWithRules.length : 0
            };
        }
        
        // Print Functions
        function printTrade(tradeIndex) {
            const trade = appState.trades[tradeIndex];
            const printWindow = window.open('', '', 'width=800,height=600,noopener,noreferrer');
            
            if (!printWindow) {
                showMessage('Unable to open print window. Please check pop-up blocker settings.', 'error');
                return;
            }
            
            // Security: Build DOM safely without document.write
            const doc = printWindow.document;
            doc.open();
            
            // Create HTML structure safely
            const html = doc.createElement('html');
            const head = doc.createElement('head');
            const title = doc.createElement('title');
            title.textContent = `Trade Report - ${trade.symbol} ${trade.date}`;
            head.appendChild(title);
            
            // Add styles safely
            const style = doc.createElement('style');
            style.textContent = `
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { text-align: center; border-bottom: 2px solid #333; padding-bottom: 10px; }
                .trade-info { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
                .section { margin: 20px 0; }
                .positive { color: green; }
                .negative { color: red; }
                img { max-width: 300px; margin: 10px; }
                @media print { @page { size: landscape; } }
            `;
            head.appendChild(style);
            html.appendChild(head);
            
            // Create body
            const body = doc.createElement('body');
            
            // Header section
            const headerDiv = doc.createElement('div');
            headerDiv.className = 'header';
            const h1 = doc.createElement('h1');
            h1.textContent = 'Trade Report';
            const h2 = doc.createElement('h2');
            h2.textContent = `${trade.symbol} - ${trade.date} ${trade.time}`;
            headerDiv.appendChild(h1);
            headerDiv.appendChild(h2);
            body.appendChild(headerDiv);
            
            // Trade info section
            const tradeInfoDiv = doc.createElement('div');
            tradeInfoDiv.className = 'trade-info';
            
            const leftDiv = doc.createElement('div');
            leftDiv.innerHTML = `
                <strong>Entry Price:</strong> ${escapeHtml(trade.entryPrice.toFixed(5))}<br>
                <strong>Exit Price:</strong> ${escapeHtml(trade.exitPrice.toFixed(5))}<br>
                <strong>Direction:</strong> ${escapeHtml(trade.direction)}<br>
                <strong>Volume:</strong> ${escapeHtml(String(trade.volume))}
            `;
            
            const rightDiv = doc.createElement('div');
            const pipClass = trade.pips >= 0 ? 'positive' : 'negative';
            const plClass = (trade.netPL || trade.profit) >= 0 ? 'positive' : 'negative';
            rightDiv.innerHTML = `
                <strong>Pips:</strong> <span class="${pipClass}">${escapeHtml(trade.pips.toFixed(1))}</span><br>
                <strong>P&L:</strong> <span class="${plClass}">${escapeHtml(formatCurrency(trade.netPL || trade.profit))}</span><br>
                <strong>Commission:</strong> ${escapeHtml(formatCurrency(trade.commission))}<br>
                <strong>Swap:</strong> ${escapeHtml(formatCurrency(trade.swap))}
            `;
            
            tradeInfoDiv.appendChild(leftDiv);
            tradeInfoDiv.appendChild(rightDiv);
            body.appendChild(tradeInfoDiv);
            
            // Trade analysis section
            const analysisSection = doc.createElement('div');
            analysisSection.className = 'section';
            const h3Analysis = doc.createElement('h3');
            h3Analysis.textContent = 'Trade Analysis';
            analysisSection.appendChild(h3Analysis);
            analysisSection.innerHTML += `
                <strong>Setup Type:</strong> ${escapeHtml(trade.setupType || 'Not specified')}<br>
                <strong>Market Condition:</strong> ${escapeHtml(trade.marketCondition || 'Not specified')}<br>
                <strong>Emotional State:</strong> ${escapeHtml(trade.emotionalState || 'Not specified')}<br>
                <strong>Rule Adherence:</strong> ${escapeHtml(trade.ruleAdherence || 'Not specified')}
            `;
            body.appendChild(analysisSection);
            
            // Notes section (if exists)
            if (trade.notes) {
                const notesSection = doc.createElement('div');
                notesSection.className = 'section';
                const h3Notes = doc.createElement('h3');
                h3Notes.textContent = 'Notes';
                notesSection.appendChild(h3Notes);
                const notesP = doc.createElement('p');
                notesP.textContent = trade.notes;
                notesSection.appendChild(notesP);
                body.appendChild(notesSection);
            }
            
            // Screenshots section (if exists)
            if (trade.entryScreenshot || trade.exitScreenshot) {
                const screenshotsSection = doc.createElement('div');
                screenshotsSection.className = 'section';
                const h3Screenshots = doc.createElement('h3');
                h3Screenshots.textContent = 'Screenshots';
                screenshotsSection.appendChild(h3Screenshots);
                
                if (trade.entryScreenshot) {
                    const entryDiv = doc.createElement('div');
                    const entryStrong = doc.createElement('strong');
                    entryStrong.textContent = 'Entry:';
                    entryDiv.appendChild(entryStrong);
                    entryDiv.appendChild(doc.createElement('br'));
                    const entryImg = doc.createElement('img');
                    entryImg.src = sanitizeUrl(trade.entryScreenshot) || trade.entryScreenshot;
                    entryImg.alt = 'Entry Screenshot';
                    entryDiv.appendChild(entryImg);
                    screenshotsSection.appendChild(entryDiv);
                }
                
                if (trade.exitScreenshot) {
                    const exitDiv = doc.createElement('div');
                    const exitStrong = doc.createElement('strong');
                    exitStrong.textContent = 'Exit:';
                    exitDiv.appendChild(exitStrong);
                    exitDiv.appendChild(doc.createElement('br'));
                    const exitImg = doc.createElement('img');
                    exitImg.src = sanitizeUrl(trade.exitScreenshot) || trade.exitScreenshot;
                    exitImg.alt = 'Exit Screenshot';
                    exitDiv.appendChild(exitImg);
                    screenshotsSection.appendChild(exitDiv);
                }
                
                body.appendChild(screenshotsSection);
            }
            
            html.appendChild(body);
            doc.appendChild(html);
            doc.close();
            
            // Wait for content to load before printing
            setTimeout(() => {
                printWindow.print();
            }, 250);
        }
        
        
        function printTrades() {
            // Implementation for printing all trades
            showMessage('Print all trades functionality would open print dialog with all trades');
        }
        
        // Configuration Functions
        function getStatLabel(key) {
            const labels = {
                startingBalance: 'Starting Balance',
                currentBalance: 'Current Balance',
                accountGrowth: 'Account Growth',
                totalTrades: 'Total Trades',
                winningTrades: 'Winning Trades',
                losingTrades: 'Losing Trades',
                winRate: 'Win Rate',
                rulesWinRate: 'Rules Win Rate',
                profitFactor: 'Profit Factor',
                netPL: 'Net P/L',
                avgWin: 'Average Win',
                avgLoss: 'Average Loss',
                largestWin: 'Largest Win',
                largestLoss: 'Largest Loss',
                expectancy: 'Expectancy',
                totalFees: 'Total Fees',
                // Phase 1 New Stats
                maxDrawdown: 'Max Drawdown',
                maxDrawdownPercent: 'Max Drawdown %',
                recoveryFactor: 'Recovery Factor',
                currentStreak: 'Current Streak',
                longestWinStreak: 'Longest Win Streak',
                longestLossStreak: 'Longest Loss Streak',
                riskRewardRatio: 'Risk/Reward Ratio',
                avgTradeDuration: 'Avg Trade Duration'
            };
            return labels[key] || key;
        }
        
        function getColumnLabel(key) {
            const labels = {
                openDate: 'Open Date',
                openTime: 'Open Time',
                date: 'Close Date',
                time: 'Close Time',
                symbol: 'Symbol',
                direction: 'Direction',
                entry: 'Entry Price',
                exit: 'Exit Price',
                pips: 'Pips',
                pl: 'P&L',
                setup: 'Setup Type'
            };
            return labels[key] || key;
        }
        
        function toggleStatsConfig() {
            appState.showStatsConfig = !appState.showStatsConfig;
            const panel = document.getElementById('statsConfigPanel');
            panel.style.display = appState.showStatsConfig ? 'block' : 'none';
            
            if (appState.showStatsConfig) {
                renderStatsConfig();
            }
        }
        
        function renderStatsConfig() {
            const grid = document.getElementById('statsConfigGrid');
            let html = '';
            
            Object.keys(appState.visibleStats).forEach(statKey => {
                html += `
                    <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                        <input type="checkbox" ${appState.visibleStats[statKey] ? 'checked' : ''} onchange="toggleStat('${statKey}', this.checked)" style="border-radius: var(--radius-sm);">
                        <span>${getStatLabel(statKey)}</span>
                    </label>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        function toggleStat(statKey, checked) {
            appState.visibleStats[statKey] = checked;
            updateStatisticsDisplay();
        }
        
        function showAllStats() {
            Object.keys(appState.visibleStats).forEach(key => {
                appState.visibleStats[key] = true;
            });
            renderStatsConfig();
            updateStatisticsDisplay();
        }
        
        function toggleChartsConfig() {
            appState.showChartsConfig = !appState.showChartsConfig;
            const panel = document.getElementById('chartsConfigPanel');
            panel.style.display = appState.showChartsConfig ? 'block' : 'none';
            
            if (appState.showChartsConfig) {
                // Update checkbox states
                document.getElementById('showEquityCurve').checked = appState.visibleCharts.equityCurve;
                document.getElementById('showDailyPL').checked = appState.visibleCharts.dailyPL;
                document.getElementById('showWinLoss').checked = appState.visibleCharts.winLoss;
            }
        }
        
        function toggleChart(chartKey, checked) {
            appState.visibleCharts[chartKey] = checked;
            updateChartsDisplay();
        }
        
        function updateChartZoom(zoom) {
            appState.chartZoom = parseInt(zoom);
            // Apply zoom to chart containers
            const containers = document.querySelectorAll('.chart-container');
            containers.forEach(container => {
                container.style.transform = `scale(${appState.chartZoom / 100})`;
                container.style.transformOrigin = 'top left';
                if (appState.chartZoom > 100) {
                    container.style.marginBottom = `${(appState.chartZoom - 100) * 3}px`;
                } else {
                    container.style.marginBottom = '0';
                }
            });
        }
        
        function toggleColumnConfig() {
            appState.showColumnsConfig = !appState.showColumnsConfig;
            const panel = document.getElementById('columnsConfigPanel');
            panel.style.display = appState.showColumnsConfig ? 'block' : 'none';
            
            if (appState.showColumnsConfig) {
                renderColumnsConfig();
            }
        }
        
        function renderColumnsConfig() {
            const grid = document.getElementById('columnsConfigGrid');
            let html = '';
            
            Object.keys(appState.visibleColumns).forEach(colKey => {
                html += `
                    <label style="display: flex; align-items: center; gap: var(--space-8); font-size: var(--font-size-sm); color: var(--color-text);">
                        <input type="checkbox" ${appState.visibleColumns[colKey] ? 'checked' : ''} onchange="toggleColumn('${colKey}', this.checked)" style="border-radius: var(--radius-sm);">
                        <span>${getColumnLabel(colKey)}</span>
                    </label>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        function toggleColumn(colKey, checked) {
            appState.visibleColumns[colKey] = checked;
            updateTradesTable();
        }
        
        function showAllColumns() {
            Object.keys(appState.visibleColumns).forEach(key => {
                appState.visibleColumns[key] = true;
            });
            renderColumnsConfig();
            updateTradesTable();
        }
        
        // UI Helper Functions
        function toggleCollapsible(element) {
            element.classList.toggle('open');
            const arrow = element.querySelector('.collapsible-header span:last-child');
            arrow.textContent = element.classList.contains('open') ? '▲' : '▼';
        }
        
        // NEW: Account Settings Functions
        function toggleAccountSettings() {
            appState.showAccountSettings = !appState.showAccountSettings;
            updateAccountSettingsCollapseState();
        }
        
        function updateAccountSettingsCollapseState() {
            const content = document.getElementById('accountSettingsContent');
            const arrow = document.getElementById('accountSettingsArrow');
            
            if (appState.showAccountSettings) {
                content.style.display = 'block';
                content.classList.remove('account-settings-collapsed');
                content.classList.add('account-settings-expanded');
                arrow.textContent = '▼';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.classList.remove('account-settings-expanded');
                content.classList.add('account-settings-collapsed');
                arrow.textContent = '▶';
                arrow.style.transform = 'rotate(0deg)';
                setTimeout(() => {
                    if (!appState.showAccountSettings) {
                        content.style.display = 'none';
                    }
                }, 250);
            }
        }
        
        // NEW: Trade History Collapse Functions
        function toggleTradeHistory() {
            appState.showTradeHistory = !appState.showTradeHistory;
            updateTradeHistoryCollapseState();
        }
        
        function updateTradeHistoryCollapseState() {
            const container = document.getElementById('tradeHistoryTableContainer');
            const collapsedMessage = document.getElementById('tradeHistoryCollapsedMessage');
            const toggleButton = document.getElementById('tradeHistoryToggle');
            const countSpan = document.getElementById('tradeHistoryCount');
            const collapsedCountSpan = document.getElementById('collapsedTradeCount');
            
            if (appState.showTradeHistory) {
                // Show expanded
                container.style.display = 'block';
                container.classList.remove('trade-history-collapsed');
                container.classList.add('trade-history-expanded');
                collapsedMessage.style.display = 'none';
                toggleButton.textContent = '▼';
                countSpan.style.display = 'none';
            } else {
                // Show collapsed
                container.classList.remove('trade-history-expanded');
                container.classList.add('trade-history-collapsed');
                collapsedMessage.style.display = 'block';
                toggleButton.textContent = '▶';
                countSpan.style.display = 'inline';
                countSpan.textContent = `(${appState.trades.length} trades)`;
                collapsedCountSpan.textContent = appState.trades.length;
                setTimeout(() => {
                    if (!appState.showTradeHistory) {
                        container.style.display = 'none';
                    }
                }, 250);
            }
        }
        
        // NEW: Account Settings Management Functions
        let editStartingBalanceValue = null;
        
        function updateStartingBalanceValue(value) {
            editStartingBalanceValue = value;
        }
        
        function saveStartingBalance() {
            if (editStartingBalanceValue !== null && editStartingBalanceValue !== '') {
                const newBalance = parseFloat(editStartingBalanceValue);
                if (!isNaN(newBalance) && newBalance > 0) {
                    appState.startingBalance = newBalance;
                    editStartingBalanceValue = null;
                    document.getElementById('editStartingBalance').value = '';
                    updateStartingBalanceDisplay();
                    calculateStatistics();
                    updateUI();
                    showMessage('✅ Starting balance updated successfully');
                } else {
                    showMessage('Please enter a valid positive number', 'error');
                }
            } else {
                showMessage('Please enter a starting balance', 'error');
            }
        }
        
        function cancelStartingBalance() {
            editStartingBalanceValue = null;
            document.getElementById('editStartingBalance').value = '';
        }
        
        function updateStartingBalanceDisplay() {
            const currentBalanceSpan = document.getElementById('currentStartingBalance');
            if (currentBalanceSpan) {
                currentBalanceSpan.textContent = (appState.startingBalance || 0).toLocaleString('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2
                });
            }
        }
        
        function updateImportMode(mode) {
            document.getElementById('importMode').value = mode;
        }

        function updatePlatform(platform) {
            document.getElementById('platform').value = platform;
        }

        function clearAllData() {
            if (window.confirm('⚠️ This will delete ALL trades, screenshots, and settings. This cannot be undone!\n\nAre you sure?')) {
                appState.trades = [];
                appState.customRules = [];
                appState.startingBalance = 10000;
                appState.strategyContext = '';
                document.getElementById('strategyContextTextarea').value = '';
                updateStrategyContextCounter();
                updateUI();
                showMessage('✅ All data cleared successfully');
            }
        }
        
        // REMOVED: Old updateStartingBalance function - replaced with new account settings functions
        
        // Strategy Context Functions
        function loadStrategyExample(exampleKey) {
            if (exampleKey && strategyExamples[exampleKey]) {
                const textarea = document.getElementById('strategyContextTextarea');
                textarea.value = strategyExamples[exampleKey];
                updateStrategyContext(strategyExamples[exampleKey]);
                updateStrategyContextCounter();
                
                // Reset dropdown to placeholder
                document.getElementById('strategyExampleSelector').value = '';
                
                showMessage(`✅ Loaded ${getStrategyExampleName(exampleKey)} example - customize it to match your approach`);
            }
        }
        
        function getStrategyExampleName(key) {
            const names = {
                'ict': 'ICT Strategy',
                'supplyDemand': 'Supply & Demand',
                'priceAction': 'Price Action',
                'breakout': 'Breakout Trading',
                'trendFollowing': 'Trend Following',
                'scalpingStrategy': 'Scalping',
                'swingTrading': 'Swing Trading'
            };
            return names[key] || 'Strategy';
        }
        
        function clearStrategyContext() {
            const textarea = document.getElementById('strategyContextTextarea');
            textarea.value = '';
            updateStrategyContext('');
            updateStrategyContextCounter();
            document.getElementById('strategyExampleSelector').value = '';
            showMessage('Strategy context cleared');
        }
        
        function updateStrategyContext(value) {
            appState.strategyContext = value;
        }
        
        function updateStrategyContextCounter() {
            const textarea = document.getElementById('strategyContextTextarea');
            const counter = document.getElementById('strategyContextCounter');
            const length = textarea.value.length;
            counter.textContent = `${length} / 2000 characters`;
            
            // Update app state
            appState.strategyContext = textarea.value;
        }
    </script>
</body>
</html>